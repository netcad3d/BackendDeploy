import {
  mat4_exports,
  quat_exports
} from "./chunk-GC37RKNO.js";
import {
  vtkBoundingBox
} from "./chunk-IC3JHQHE.js";
import {
  degreesFromRadians,
  radiansFromDegrees
} from "./chunk-FOWOP5PK.js";
import {
  macro
} from "./chunk-OTTIIP4A.js";
import {
  _defineProperty
} from "./chunk-HKWV5KNA.js";

// node_modules/@kitware/vtk.js/Rendering/Core/Prop/Constants.js
var CoordinateSystem = {
  DISPLAY: 0,
  WORLD: 1
};
var Constants = {
  CoordinateSystem
};

// node_modules/@kitware/vtk.js/Rendering/Core/Prop.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var CoordinateSystem2 = Constants.CoordinateSystem;
function notImplemented(method) {
  return function() {
    return macro.vtkErrorMacro("vtkProp::".concat(method, " - NOT IMPLEMENTED"));
  };
}
function vtkProp(publicAPI, model) {
  model.classHierarchy.push("vtkProp");
  publicAPI.getMTime = function() {
    var m1 = model.mtime;
    for (var index = 0; index < model.textures.length; ++index) {
      var m2 = model.textures[index].getMTime();
      if (m2 > m1) {
        m1 = m2;
      }
    }
    return m1;
  };
  publicAPI.processSelectorPixelBuffers = function(selector, pixeloffsets) {
  };
  publicAPI.getNestedProps = function() {
    return null;
  };
  publicAPI.getActors = function() {
    return [];
  };
  publicAPI.getActors2D = function() {
    return [];
  };
  publicAPI.getVolumes = function() {
    return [];
  };
  publicAPI.pick = notImplemented("pick");
  publicAPI.hasKey = notImplemented("hasKey");
  publicAPI.getNestedVisibility = function() {
    return model.visibility && (!model._parentProp || model._parentProp.getNestedVisibility());
  };
  publicAPI.getNestedPickable = function() {
    return model.pickable && (!model._parentProp || model._parentProp.getNestedPickable());
  };
  publicAPI.getNestedDragable = function() {
    return model.dragable && (!model._parentProp || model._parentProp.getNestedDragable());
  };
  publicAPI.getRedrawMTime = function() {
    return model.mtime;
  };
  publicAPI.setEstimatedRenderTime = function(t) {
    model.estimatedRenderTime = t;
    model.savedEstimatedRenderTime = t;
  };
  publicAPI.restoreEstimatedRenderTime = function() {
    model.estimatedRenderTime = model.savedEstimatedRenderTime;
  };
  publicAPI.addEstimatedRenderTime = function(t) {
    model.estimatedRenderTime += t;
  };
  publicAPI.setAllocatedRenderTime = function(t) {
    model.allocatedRenderTime = t;
    model.savedEstimatedRenderTime = model.estimatedRenderTime;
    model.estimatedRenderTime = 0;
  };
  publicAPI.getSupportsSelection = function() {
    return false;
  };
  publicAPI.getTextures = function() {
    return model.textures;
  };
  publicAPI.hasTexture = function(texture) {
    return model.textures.indexOf(texture) !== -1;
  };
  publicAPI.addTexture = function(texture) {
    if (texture && !publicAPI.hasTexture(texture)) {
      model.textures = model.textures.concat(texture);
      publicAPI.modified();
    }
  };
  publicAPI.removeTexture = function(texture) {
    var newTextureList = model.textures.filter(function(item) {
      return item !== texture;
    });
    if (model.textures.length !== newTextureList.length) {
      model.textures = newTextureList;
      publicAPI.modified();
    }
  };
  publicAPI.removeAllTextures = function() {
    model.textures = [];
    publicAPI.modified();
  };
  publicAPI.setCoordinateSystemToWorld = function() {
    return publicAPI.setCoordinateSystem(CoordinateSystem2.WORLD);
  };
  publicAPI.setCoordinateSystemToDisplay = function() {
    return publicAPI.setCoordinateSystem(CoordinateSystem2.DISPLAY);
  };
}
var DEFAULT_VALUES = {
  allocatedRenderTime: 10,
  coordinateSystem: CoordinateSystem2.WORLD,
  dragable: true,
  estimatedRenderTime: 0,
  paths: null,
  pickable: true,
  renderTimeMultiplier: 1,
  savedEstimatedRenderTime: 0,
  textures: [],
  useBounds: true,
  visibility: true
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["estimatedRenderTime", "allocatedRenderTime"]);
  macro.setGet(publicAPI, model, ["_parentProp", "coordinateSystem", "dragable", "pickable", "renderTimeMultiplier", "useBounds", "visibility"]);
  macro.moveToProtected(publicAPI, model, ["parentProp"]);
  vtkProp(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkProp");
var vtkProp$1 = _objectSpread({
  newInstance,
  extend
}, Constants);

// node_modules/@kitware/vtk.js/Rendering/Core/Prop3D.js
function vtkProp3D(publicAPI, model) {
  model.classHierarchy.push("vtkProp3D");
  publicAPI.addPosition = function(deltaXYZ) {
    model.position = model.position.map(function(value, index) {
      return value + deltaXYZ[index];
    });
    publicAPI.modified();
  };
  publicAPI.getOrientationWXYZ = function() {
    var q = quat_exports.create();
    mat4_exports.getRotation(q, model.rotation);
    var oaxis = new Float64Array(3);
    var w = quat_exports.getAxisAngle(oaxis, q);
    return [degreesFromRadians(w), oaxis[0], oaxis[1], oaxis[2]];
  };
  publicAPI.rotateX = function(val) {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateX(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateY = function(val) {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateY(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateZ = function(val) {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateZ(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateWXYZ = function(degrees, x, y, z) {
    if (degrees === 0 || x === 0 && y === 0 && z === 0) {
      return;
    }
    var angle = radiansFromDegrees(degrees);
    var q = quat_exports.create();
    quat_exports.setAxisAngle(q, [x, y, z], angle);
    var quatMat = new Float64Array(16);
    mat4_exports.fromQuat(quatMat, q);
    mat4_exports.multiply(model.rotation, model.rotation, quatMat);
    publicAPI.modified();
  };
  publicAPI.setOrientation = function(x, y, z) {
    if (x === model.orientation[0] && y === model.orientation[1] && z === model.orientation[2]) {
      return false;
    }
    model.orientation = [x, y, z];
    mat4_exports.identity(model.rotation);
    publicAPI.rotateZ(z);
    publicAPI.rotateX(x);
    publicAPI.rotateY(y);
    publicAPI.modified();
    return true;
  };
  publicAPI.setUserMatrix = function(matrix) {
    mat4_exports.copy(model.userMatrix, matrix);
    publicAPI.modified();
  };
  publicAPI.getMatrix = function() {
    publicAPI.computeMatrix();
    return model.matrix;
  };
  publicAPI.computeMatrix = function() {
    if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
      mat4_exports.identity(model.matrix);
      if (model.userMatrix) {
        mat4_exports.multiply(model.matrix, model.matrix, model.userMatrix);
      }
      mat4_exports.translate(model.matrix, model.matrix, model.origin);
      mat4_exports.translate(model.matrix, model.matrix, model.position);
      mat4_exports.multiply(model.matrix, model.matrix, model.rotation);
      mat4_exports.scale(model.matrix, model.matrix, model.scale);
      mat4_exports.translate(model.matrix, model.matrix, [-model.origin[0], -model.origin[1], -model.origin[2]]);
      mat4_exports.transpose(model.matrix, model.matrix);
      model.isIdentity = true;
      for (var i = 0; i < 4; ++i) {
        for (var j = 0; j < 4; ++j) {
          if ((i === j ? 1 : 0) !== model.matrix[i + j * 4]) {
            model.isIdentity = false;
          }
        }
      }
      model.matrixMTime.modified();
    }
  };
  publicAPI.getCenter = function() {
    return vtkBoundingBox.getCenter(model.bounds);
  };
  publicAPI.getLength = function() {
    return vtkBoundingBox.getLength(model.bounds);
  };
  publicAPI.getXRange = function() {
    return vtkBoundingBox.getXRange(model.bounds);
  };
  publicAPI.getYRange = function() {
    return vtkBoundingBox.getYRange(model.bounds);
  };
  publicAPI.getZRange = function() {
    return vtkBoundingBox.getZRange(model.bounds);
  };
  publicAPI.getUserMatrix = function() {
    return model.userMatrix;
  };
  function updateIdentityFlag() {
    publicAPI.computeMatrix();
  }
  publicAPI.onModified(updateIdentityFlag);
}
var DEFAULT_VALUES2 = {
  origin: [0, 0, 0],
  position: [0, 0, 0],
  orientation: [0, 0, 0],
  rotation: null,
  scale: [1, 1, 1],
  bounds: [1, -1, 1, -1, 1, -1],
  userMatrix: null,
  userMatrixMTime: null,
  cachedProp3D: null,
  isIdentity: true,
  matrixMTime: null
};
function extend2(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  vtkProp$1.extend(publicAPI, model, initialValues);
  model.matrixMTime = {};
  macro.obj(model.matrixMTime);
  macro.get(publicAPI, model, ["bounds", "isIdentity"]);
  macro.getArray(publicAPI, model, ["orientation"]);
  macro.setGetArray(publicAPI, model, ["origin", "position", "scale"], 3);
  model.matrix = mat4_exports.identity(new Float64Array(16));
  model.rotation = mat4_exports.identity(new Float64Array(16));
  model.userMatrix = mat4_exports.identity(new Float64Array(16));
  model.transform = null;
  vtkProp3D(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend2, "vtkProp3D");
var vtkProp3D$1 = {
  newInstance: newInstance2,
  extend: extend2
};

export {
  vtkProp$1,
  vtkProp3D$1
};
//# sourceMappingURL=chunk-N3Z342Y4.js.map
