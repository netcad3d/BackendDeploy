{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Rendering/Core/ColorTransferFunction/Constants.js", "../../@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js"],
  "sourcesContent": ["var ColorSpace = {\n  RGB: 0,\n  HSV: 1,\n  LAB: 2,\n  DIVERGING: 3\n};\nvar Scale = {\n  LINEAR: 0,\n  LOG10: 1\n};\nvar Constants = {\n  ColorSpace: ColorSpace,\n  Scale: Scale\n};\n\nexport { ColorSpace, Scale, Constants as default };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport { h as hsv2rgb, i as isNan, G as isInf, H as rgb2hsv, I as rgb2lab, J as lab2rgb, K as floor } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors.js';\nimport Constants from './ColorTransferFunction/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar ColorSpace = Constants.ColorSpace,\n    Scale = Constants.Scale;\nvar ScalarMappingTarget = vtkScalarsToColors.ScalarMappingTarget;\nvar vtkDebugMacro = macro.vtkDebugMacro,\n    vtkErrorMacro = macro.vtkErrorMacro,\n    vtkWarningMacro = macro.vtkWarningMacro; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n/* eslint-disable no-continue                                                */\n// Convert to and from a special polar version of CIELAB (useful for creating\n// continuous diverging color maps).\n\nfunction vtkColorTransferFunctionLabToMsh(lab, msh) {\n  var L = lab[0];\n  var a = lab[1];\n  var b = lab[2];\n  var M = Math.sqrt(L * L + a * a + b * b);\n  var s = M > 0.001 ? Math.acos(L / M) : 0.0;\n  var h = s > 0.001 ? Math.atan2(b, a) : 0.0;\n  msh[0] = M;\n  msh[1] = s;\n  msh[2] = h;\n}\n\nfunction vtkColorTransferFunctionMshToLab(msh, lab) {\n  var M = msh[0];\n  var s = msh[1];\n  var h = msh[2];\n  lab[0] = M * Math.cos(s);\n  lab[1] = M * Math.sin(s) * Math.cos(h);\n  lab[2] = M * Math.sin(s) * Math.sin(h);\n} // For the case when interpolating from a saturated color to an unsaturated\n// color, find a hue for the unsaturated color that makes sense.\n\n\nfunction vtkColorTransferFunctionAdjustHue(msh, unsatM) {\n  if (msh[0] >= unsatM - 0.1) {\n    // The best we can do is hold hue constant.\n    return msh[2];\n  } // This equation is designed to make the perceptual change of the\n  // interpolation to be close to constant.\n\n\n  var hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1])); // Spin hue away from 0 except in purple hues.\n\n  if (msh[2] > -0.3 * Math.PI) {\n    return msh[2] + hueSpin;\n  }\n\n  return msh[2] - hueSpin;\n}\n\nfunction vtkColorTransferFunctionAngleDiff(a1, a2) {\n  var adiff = a1 - a2;\n\n  if (adiff < 0.0) {\n    adiff = -adiff;\n  }\n\n  while (adiff >= 2.0 * Math.PI) {\n    adiff -= 2.0 * Math.PI;\n  }\n\n  if (adiff > Math.PI) {\n    adiff = 2.0 * Math.PI - adiff;\n  }\n\n  return adiff;\n} // Interpolate a diverging color map.\n\n\nfunction vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {\n  var lab1 = [];\n  var lab2 = [];\n  rgb2lab(rgb1, lab1);\n  rgb2lab(rgb2, lab2);\n  var msh1 = [];\n  var msh2 = [];\n  vtkColorTransferFunctionLabToMsh(lab1, msh1);\n  vtkColorTransferFunctionLabToMsh(lab2, msh2); // If the endpoints are distinct saturated colors, then place white in between\n  // them.\n\n  var localS = s;\n\n  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {\n    // Insert the white midpoint by setting one end to white and adjusting the\n    // scalar value.\n    var Mmid = Math.max(msh1[0], msh2[0]);\n    Mmid = Math.max(88.0, Mmid);\n\n    if (s < 0.5) {\n      msh2[0] = Mmid;\n      msh2[1] = 0.0;\n      msh2[2] = 0.0;\n      localS *= 2.0;\n    } else {\n      msh1[0] = Mmid;\n      msh1[1] = 0.0;\n      msh1[2] = 0.0;\n      localS = 2.0 * localS - 1.0;\n    }\n  } // If one color has no saturation, then its hue value is invalid.  In this\n  // case, we want to set it to something logical so that the interpolation of\n  // hue makes sense.\n\n\n  if (msh1[1] < 0.05 && msh2[1] > 0.05) {\n    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);\n  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {\n    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);\n  }\n\n  var mshTmp = [];\n  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];\n  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];\n  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2]; // Now convert back to RGB\n\n  var labTmp = [];\n  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);\n  lab2rgb(labTmp, result);\n} // ----------------------------------------------------------------------------\n// vtkColorTransferFunction methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkColorTransferFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkColorTransferFunction'); // Return the number of points which specify this function\n\n  publicAPI.getSize = function () {\n    return model.nodes.length;\n  }; //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n\n\n  publicAPI.addRGBPoint = function (x, r, g, b) {\n    return publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0);\n  }; //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n\n\n  publicAPI.addRGBPointLong = function (x, r, g, b) {\n    var midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    var sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    } // remove any node already at this X location\n\n\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    } // Create the new node\n\n\n    var node = {\n      x: x,\n      r: r,\n      g: g,\n      b: b,\n      midpoint: midpoint,\n      sharpness: sharpness\n    }; // Add it, then sort to get everything in order\n\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange(); // We need to find the index of the node we just added in order\n    // to return this value\n\n    var i = 0;\n\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    } // If we didn't find it, something went horribly wrong so\n    // return -1\n\n\n    if (i < model.nodes.length) {\n      return i;\n    }\n\n    return -1;\n  }; //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n\n\n  publicAPI.addHSVPoint = function (x, h, s, v) {\n    return publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0);\n  }; //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n\n\n  publicAPI.addHSVPointLong = function (x, h, s, v) {\n    var midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    var sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    var rgb = [];\n    var hsv = [h, s, v];\n    hsv2rgb(hsv, rgb);\n    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);\n  }; //----------------------------------------------------------------------------\n  // Set nodes directly\n\n\n  publicAPI.setNodes = function (nodes) {\n    if (model.nodes !== nodes) {\n      var before = JSON.stringify(model.nodes);\n      model.nodes = nodes;\n      var after = JSON.stringify(model.nodes);\n\n      if (publicAPI.sortAndUpdateRange() || before !== after) {\n        publicAPI.modified();\n        return true;\n      }\n    }\n\n    return false;\n  }; //----------------------------------------------------------------------------\n  // Sort the vector in increasing order, then fill in\n  // the Range\n\n\n  publicAPI.sortAndUpdateRange = function () {\n    var before = JSON.stringify(model.nodes);\n    model.nodes.sort(function (a, b) {\n      return a.x - b.x;\n    });\n    var after = JSON.stringify(model.nodes);\n    var modifiedInvoked = publicAPI.updateRange(); // If range is updated, Modified() has been called, don't call it again.\n\n    if (!modifiedInvoked && before !== after) {\n      publicAPI.modified();\n      return true;\n    }\n\n    return modifiedInvoked;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.updateRange = function () {\n    var oldRange = [2];\n    oldRange[0] = model.mappingRange[0];\n    oldRange[1] = model.mappingRange[1];\n    var size = model.nodes.length;\n\n    if (size) {\n      model.mappingRange[0] = model.nodes[0].x;\n      model.mappingRange[1] = model.nodes[size - 1].x;\n    } else {\n      model.mappingRange[0] = 0;\n      model.mappingRange[1] = 0;\n    } // If the range is the same, then no need to call Modified()\n\n\n    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {\n      return false;\n    }\n\n    publicAPI.modified();\n    return true;\n  }; //----------------------------------------------------------------------------\n  // Remove a point\n\n\n  publicAPI.removePoint = function (x) {\n    // First find the node since we need to know its\n    // index as our return value\n    var i = 0;\n\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    var retVal = i; // If the node doesn't exist, we return -1\n\n    if (i >= model.nodes.length) {\n      return -1;\n    } // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n\n\n    var modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n\n    return retVal;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.movePoint = function (oldX, newX) {\n    if (oldX === newX) {\n      // Nothing to do.\n      return;\n    }\n\n    publicAPI.removePoint(newX);\n\n    for (var i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === oldX) {\n        model.nodes[i].x = newX;\n        publicAPI.sortAndUpdateRange();\n        break;\n      }\n    }\n  }; //----------------------------------------------------------------------------\n  // Remove all points\n\n\n  publicAPI.removeAllPoints = function () {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  }; //----------------------------------------------------------------------------\n  // Add a line defined in RGB\n\n\n  publicAPI.addRGBSegment = function (x1, r1, g1, b1, x2, r2, g2, b2) {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n\n    for (var i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    } // Now add the points\n\n\n    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);\n    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n  // Add a line defined in HSV\n\n\n  publicAPI.addHSVSegment = function (x1, h1, s1, v1, x2, h2, s2, v2) {\n    var hsv1 = [h1, s1, v1];\n    var hsv2 = [h2, s2, v2];\n    var rgb1 = [];\n    var rgb2 = [];\n    hsv2rgb(hsv1, rgb1);\n    hsv2rgb(hsv2, rgb2);\n    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);\n  }; //----------------------------------------------------------------------------\n  // Returns the RGBA color evaluated at the specified location\n\n\n  publicAPI.mapValue = function (x) {\n    var rgb = [];\n    publicAPI.getColor(x, rgb);\n    return [Math.floor(255.0 * rgb[0] + 0.5), Math.floor(255.0 * rgb[1] + 0.5), Math.floor(255.0 * rgb[2] + 0.5), 255];\n  }; //----------------------------------------------------------------------------\n  // Returns the RGB color evaluated at the specified location\n\n\n  publicAPI.getColor = function (x, rgb) {\n    if (model.indexedLookup) {\n      var numNodes = publicAPI.getSize(); // todo\n\n      var idx = publicAPI.getAnnotatedValueIndexInternal(x);\n\n      if (idx < 0 || numNodes === 0) {\n        publicAPI.getNanColor(rgb);\n      } else {\n        var nodeVal = [];\n        publicAPI.getNodeValue(idx % numNodes, nodeVal);\n        rgb[0] = nodeVal.r;\n        rgb[1] = nodeVal.g;\n        rgb[2] = nodeVal.b;\n      }\n\n      return;\n    }\n\n    publicAPI.getTable(x, x, 1, rgb);\n  }; //----------------------------------------------------------------------------\n  // Returns the red color evaluated at the specified location\n\n\n  publicAPI.getRedValue = function (x) {\n    var rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[0];\n  }; //----------------------------------------------------------------------------\n  // Returns the green color evaluated at the specified location\n\n\n  publicAPI.getGreenValue = function (x) {\n    var rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[1];\n  }; //----------------------------------------------------------------------------\n  // Returns the blue color evaluated at the specified location\n\n\n  publicAPI.getBlueValue = function (x) {\n    var rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[2];\n  }; //----------------------------------------------------------------------------\n  // Returns a table of RGB colors at regular intervals along the function\n\n\n  publicAPI.getTable = function (xStart, xEnd, size, table) {\n    // Special case: If either the start or end is a NaN, then all any\n    // interpolation done on them is also a NaN.  Therefore, fill the table with\n    // the NaN color.\n    if (isNan(xStart) || isNan(xEnd)) {\n      for (var i = 0; i < size; i++) {\n        table[i * 3 + 0] = model.nanColor[0];\n        table[i * 3 + 1] = model.nanColor[1];\n        table[i * 3 + 2] = model.nanColor[2];\n      }\n\n      return;\n    }\n\n    var idx = 0;\n    var numNodes = model.nodes.length; // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n\n    var lastR = 0.0;\n    var lastG = 0.0;\n    var lastB = 0.0;\n\n    if (numNodes !== 0) {\n      lastR = model.nodes[numNodes - 1].r;\n      lastG = model.nodes[numNodes - 1].g;\n      lastB = model.nodes[numNodes - 1].b;\n    }\n\n    var x = 0.0;\n    var x1 = 0.0;\n    var x2 = 0.0;\n    var rgb1 = [0.0, 0.0, 0.0];\n    var rgb2 = [0.0, 0.0, 0.0];\n    var midpoint = 0.0;\n    var sharpness = 0.0;\n    var tmpVec = []; // If the scale is logarithmic, make sure the range is valid.\n\n    var usingLogScale = model.scale === Scale.LOG10;\n\n    if (usingLogScale) {\n      // Note: This requires range[0] <= range[1].\n      usingLogScale = model.mappingRange[0] > 0.0;\n    }\n\n    var logStart = 0.0;\n    var logEnd = 0.0;\n    var logX = 0.0;\n\n    if (usingLogScale) {\n      logStart = Math.log10(xStart);\n      logEnd = Math.log10(xEnd);\n    } // For each table entry\n\n\n    for (var _i = 0; _i < size; _i++) {\n      // Find our location in the table\n      var tidx = 3 * _i; // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n\n      if (size > 1) {\n        if (usingLogScale) {\n          logX = logStart + _i / (size - 1.0) * (logEnd - logStart);\n          x = Math.pow(10.0, logX);\n        } else {\n          x = xStart + _i / (size - 1.0) * (xEnd - xStart);\n        }\n      } else if (usingLogScale) {\n        logX = 0.5 * (logStart + logEnd);\n        x = Math.pow(10.0, logX);\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      } // Linearly map x from mappingRange to [0, numberOfValues-1],\n      // discretize (round down to the closest integer),\n      // then map back to mappingRange\n\n\n      if (model.discretize) {\n        var range = model.mappingRange;\n\n        if (x >= range[0] && x <= range[1]) {\n          var numberOfValues = model.numberOfValues;\n          var deltaRange = range[1] - range[0];\n\n          if (numberOfValues <= 1) {\n            x = range[0] + deltaRange / 2.0;\n          } else {\n            // normalize x\n            var xn = (x - range[0]) / deltaRange; // discretize\n\n            var discretizeIndex = floor(numberOfValues * xn); // get discretized x\n\n            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;\n          }\n        }\n      } // Do we need to move to the next node?\n\n\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++; // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n\n          if (usingLogScale) {\n            x1 = Math.log10(x1);\n            x2 = Math.log10(x2);\n          }\n\n          rgb1[0] = model.nodes[idx - 1].r;\n          rgb2[0] = model.nodes[idx].r;\n          rgb1[1] = model.nodes[idx - 1].g;\n          rgb2[1] = model.nodes[idx].g;\n          rgb1[2] = model.nodes[idx - 1].b;\n          rgb2[2] = model.nodes[idx].b; // We only need the previous midpoint and sharpness\n          // since these control this region\n\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness; // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      } // Are we at or past the end? If so, just use the last value\n\n\n      if (x > model.mappingRange[1]) {\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n\n        if (model.clamping) {\n          if (publicAPI.getUseAboveRangeColor()) {\n            table[tidx] = model.aboveRangeColor[0];\n            table[tidx + 1] = model.aboveRangeColor[1];\n            table[tidx + 2] = model.aboveRangeColor[2];\n          } else {\n            table[tidx] = lastR;\n            table[tidx + 1] = lastG;\n            table[tidx + 2] = lastB;\n          }\n        }\n      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {\n        // we are before the first node? If so, duplicate this node's values.\n        // We have to deal with -inf here\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n\n        if (model.clamping) {\n          if (publicAPI.getUseBelowRangeColor()) {\n            table[tidx] = model.belowRangeColor[0];\n            table[tidx + 1] = model.belowRangeColor[1];\n            table[tidx + 2] = model.belowRangeColor[2];\n          } else if (numNodes > 0) {\n            table[tidx] = model.nodes[0].r;\n            table[tidx + 1] = model.nodes[0].g;\n            table[tidx + 2] = model.nodes[0].b;\n          }\n        }\n      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {\n        if (numNodes > 0) {\n          table[tidx] = model.nodes[0].r;\n          table[tidx + 1] = model.nodes[0].g;\n          table[tidx + 2] = model.nodes[0].b;\n        } else {\n          table[tidx] = 0.0;\n          table[tidx + 1] = 0.0;\n          table[tidx + 2] = 0.0;\n        }\n      } else {\n        // OK, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        var s = 0.0;\n\n        if (usingLogScale) {\n          s = (logX - x1) / (x2 - x1);\n        } else {\n          s = (x - x1) / (x2 - x1);\n        } // Readjust based on the midpoint - linear adjustment\n\n\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        } // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n\n\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = rgb1[0];\n            table[tidx + 1] = rgb1[1];\n            table[tidx + 2] = rgb1[2];\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = rgb2[0];\n            table[tidx + 1] = rgb2[1];\n            table[tidx + 2] = rgb2[2];\n            continue;\n          }\n        } // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n\n\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          if (model.colorSpace === ColorSpace.RGB) {\n            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];\n            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];\n            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];\n          } else if (model.colorSpace === ColorSpace.HSV) {\n            var hsv1 = [];\n            var hsv2 = [];\n            rgb2hsv(rgb1, hsv1);\n            rgb2hsv(rgb2, hsv2);\n\n            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n              if (hsv1[0] > hsv2[0]) {\n                hsv1[0] -= 1.0;\n              } else {\n                hsv2[0] -= 1.0;\n              }\n            }\n\n            var hsvTmp = [];\n            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];\n\n            if (hsvTmp[0] < 0.0) {\n              hsvTmp[0] += 1.0;\n            }\n\n            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];\n            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2]; // Now convert this back to RGB\n\n            hsv2rgb(hsvTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.LAB) {\n            var lab1 = [];\n            var lab2 = [];\n            rgb2lab(rgb1, lab1);\n            rgb2lab(rgb2, lab2);\n            var labTmp = [];\n            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];\n            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];\n            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2]; // Now convert back to RGB\n\n            lab2rgb(labTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.DIVERGING) {\n            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else {\n            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);\n          }\n\n          continue;\n        } // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n\n\n        if (s < 0.5) {\n          s = 0.5 * Math.pow(s * 2.0, 1.0 + 10.0 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * Math.pow((1.0 - s) * 2, 1 + 10.0 * sharpness);\n        } // Compute some coefficients we will need for the hermite curve\n\n\n        var ss = s * s;\n        var sss = ss * s;\n        var h1 = 2.0 * sss - 3 * ss + 1;\n        var h2 = -2 * sss + 3 * ss;\n        var h3 = sss - 2 * ss + s;\n        var h4 = sss - ss;\n        var slope = void 0;\n        var t = void 0;\n\n        if (model.colorSpace === ColorSpace.RGB) {\n          for (var j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = rgb2[j] - rgb1[j];\n            t = (1.0 - sharpness) * slope; // Compute the value\n\n            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;\n          }\n        } else if (model.colorSpace === ColorSpace.HSV) {\n          var _hsv = [];\n          var _hsv2 = [];\n          rgb2hsv(rgb1, _hsv);\n          rgb2hsv(rgb2, _hsv2);\n\n          if (model.hSVWrap && (_hsv[0] - _hsv2[0] > 0.5 || _hsv2[0] - _hsv[0] > 0.5)) {\n            if (_hsv[0] > _hsv2[0]) {\n              _hsv[0] -= 1.0;\n            } else {\n              _hsv2[0] -= 1.0;\n            }\n          }\n\n          var _hsvTmp = [];\n\n          for (var _j = 0; _j < 3; _j++) {\n            // Use one slope for both end points\n            slope = _hsv2[_j] - _hsv[_j];\n            t = (1.0 - sharpness) * slope; // Compute the value\n\n            _hsvTmp[_j] = h1 * _hsv[_j] + h2 * _hsv2[_j] + h3 * t + h4 * t;\n\n            if (_j === 0 && _hsvTmp[_j] < 0.0) {\n              _hsvTmp[_j] += 1.0;\n            }\n          } // Now convert this back to RGB\n\n\n          hsv2rgb(_hsvTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.LAB) {\n          var _lab = [];\n          var _lab2 = [];\n          rgb2lab(rgb1, _lab);\n          rgb2lab(rgb2, _lab2);\n          var _labTmp = [];\n\n          for (var _j2 = 0; _j2 < 3; _j2++) {\n            // Use one slope for both end points\n            slope = _lab2[_j2] - _lab[_j2];\n            t = (1.0 - sharpness) * slope; // Compute the value\n\n            _labTmp[_j2] = h1 * _lab[_j2] + h2 * _lab2[_j2] + h3 * t + h4 * t;\n          } // Now convert this back to RGB\n\n\n          lab2rgb(_labTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.DIVERGING) {\n          // I have not implemented proper interpolation by a hermite curve for\n          // the diverging color map, but I cannot think of a good use case for\n          // that anyway.\n          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else {\n          vtkErrorMacro('ColorSpace set to invalid value.');\n        } // Final error check to make sure we don't go outside [0,1]\n\n\n        for (var _j3 = 0; _j3 < 3; _j3++) {\n          table[tidx + _j3] = table[tidx + _j3] < 0.0 ? 0.0 : table[tidx + _j3];\n          table[tidx + _j3] = table[tidx + _j3] > 1.0 ? 1.0 : table[tidx + _j3];\n        }\n      }\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getUint8Table = function (xStart, xEnd, size) {\n    var withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {\n      return model.table;\n    }\n\n    if (model.nodes.length === 0) {\n      vtkErrorMacro('Attempting to lookup a value with no points in the function');\n      return model.table;\n    }\n\n    var nbChannels = withAlpha ? 4 : 3;\n\n    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {\n      model.table = new Uint8Array(size * nbChannels);\n      model.tableSize = size;\n      model.tableWithAlpha = withAlpha;\n    }\n\n    var tmpTable = [];\n    publicAPI.getTable(xStart, xEnd, size, tmpTable);\n\n    for (var i = 0; i < size; i++) {\n      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255.0 + 0.5);\n      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255.0 + 0.5);\n      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255.0 + 0.5);\n\n      if (withAlpha) {\n        model.table[i * nbChannels + 3] = 255;\n      }\n    }\n\n    model.buildTime.modified();\n    return model.table;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.buildFunctionFromTable = function (xStart, xEnd, size, table) {\n    var inc = 0.0;\n    publicAPI.removeAllPoints();\n\n    if (size > 1) {\n      inc = (xEnd - xStart) / (size - 1.0);\n    }\n\n    for (var i = 0; i < size; i++) {\n      var node = {\n        x: xStart + inc * i,\n        r: table[i * 3],\n        g: table[i * 3 + 1],\n        b: table[i * 3 + 2],\n        sharpness: 0.0,\n        midpoint: 0.5\n      };\n      model.nodes.push(node);\n    }\n\n    publicAPI.sortAndUpdateRange();\n  }; //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n\n\n  publicAPI.getNodeValue = function (index, val) {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].r;\n    val[2] = model.nodes[index].g;\n    val[3] = model.nodes[index].b;\n    val[4] = model.nodes[index].midpoint;\n    val[5] = model.nodes[index].sharpness;\n    return 1;\n  }; //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n\n\n  publicAPI.setNodeValue = function (index, val) {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    var oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].r = val[1];\n    model.nodes[index].g = val[2];\n    model.nodes[index].b = val[3];\n    model.nodes[index].midpoint = val[4];\n    model.nodes[index].sharpness = val[5];\n\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange(); // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n\n    return 1;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getNumberOfAvailableColors = function () {\n    if (model.indexedLookup && publicAPI.getSize()) {\n      return publicAPI.getSize();\n    }\n\n    if (model.tableSize) {\n      // Not sure if this is correct since it is only set if\n      // \"const unsigned char *::GetTable(double xStart, double xEnd,int size)\"\n      // has been called.\n      return model.tableSize;\n    }\n\n    return 16777216; // 2^24\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getIndexedColor = function (idx, rgba) {\n    var n = publicAPI.getSize();\n\n    if (n > 0 && idx >= 0) {\n      var nodeValue = [];\n      publicAPI.getNodeValue(idx % n, nodeValue);\n\n      for (var j = 0; j < 3; ++j) {\n        rgba[j] = nodeValue[j + 1];\n      }\n\n      rgba[3] = 1.0; // NodeColor is RGB-only.\n\n      return;\n    }\n\n    publicAPI.getNanColor(rgba);\n    rgba[3] = 1.0; // NanColor is RGB-only.\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.fillFromDataPointer = function (nb, ptr) {\n    if (nb <= 0 || !ptr) {\n      return;\n    }\n\n    publicAPI.removeAllPoints();\n\n    for (var i = 0; i < nb; i++) {\n      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.setMappingRange = function (min, max) {\n    var range = [min, max];\n    var originalRange = publicAPI.getRange();\n\n    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {\n      return;\n    }\n\n    if (range[1] === range[0]) {\n      vtkErrorMacro('attempt to set zero width color range');\n      return;\n    }\n\n    var scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);\n    var shift = range[0] - originalRange[0] * scale;\n\n    for (var i = 0; i < model.nodes.length; ++i) {\n      model.nodes[i].x = model.nodes[i].x * scale + shift;\n    }\n\n    model.mappingRange[0] = range[0];\n    model.mappingRange[1] = range[1];\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.adjustRange = function (range) {\n    var functionRange = publicAPI.getRange(); // Make sure we have points at each end of the range\n\n    var rgb = [];\n\n    if (functionRange[0] < range[0]) {\n      publicAPI.getColor(range[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    }\n\n    if (functionRange[1] > range[1]) {\n      publicAPI.getColor(range[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } // Remove all points out-of-range\n\n\n    publicAPI.sortAndUpdateRange();\n\n    for (var i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n\n    return 1;\n  }; //--------------------------------------------------------------------------\n\n\n  publicAPI.estimateMinNumberOfSamples = function (x1, x2) {\n    var d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.findMinimumXDistance = function () {\n    if (model.nodes.length < 2) {\n      return -1.0;\n    }\n\n    var distance = Number.MAX_VALUE;\n\n    for (var i = 0; i < model.nodes.length - 1; i++) {\n      var currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n\n    return distance;\n  };\n\n  publicAPI.mapScalarsThroughTable = function (input, output, outFormat, inputOffset) {\n    if (publicAPI.getSize() === 0) {\n      vtkDebugMacro('Transfer Function Has No Points!');\n      return;\n    }\n\n    if (model.indexedLookup) {\n      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);\n    } else {\n      publicAPI.mapData(input, output, outFormat, inputOffset);\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.mapData = function (input, output, outFormat, inputOffset) {\n    if (publicAPI.getSize() === 0) {\n      vtkWarningMacro('Transfer Function Has No Points!');\n      return;\n    }\n\n    var alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);\n    var length = input.getNumberOfTuples();\n    var inIncr = input.getNumberOfComponents();\n    var outputV = output.getData();\n    var inputV = input.getData();\n    var rgb = [];\n\n    if (outFormat === ScalarMappingTarget.RGBA) {\n      for (var i = 0; i < length; i++) {\n        var x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n        outputV[i * 4 + 3] = alpha;\n      }\n    }\n\n    if (outFormat === ScalarMappingTarget.RGB) {\n      for (var _i2 = 0; _i2 < length; _i2++) {\n        var _x = inputV[_i2 * inIncr + inputOffset];\n        publicAPI.getColor(_x, rgb);\n        outputV[_i2 * 3] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[_i2 * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[_i2 * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n      }\n    }\n\n    if (outFormat === ScalarMappingTarget.LUMINANCE) {\n      for (var _i3 = 0; _i3 < length; _i3++) {\n        var _x2 = inputV[_i3 * inIncr + inputOffset];\n        publicAPI.getColor(_x2, rgb);\n        outputV[_i3] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n      }\n    }\n\n    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {\n      for (var _i4 = 0; _i4 < length; _i4++) {\n        var _x3 = inputV[_i4 * inIncr + inputOffset];\n        publicAPI.getColor(_x3, rgb);\n        outputV[_i4 * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n        outputV[_i4 * 2 + 1] = alpha;\n      }\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.applyColorMap = function (colorMap) {\n    if (colorMap.ColorSpace) {\n      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];\n\n      if (model.colorSpace === undefined) {\n        vtkErrorMacro(\"ColorSpace \".concat(colorMap.ColorSpace, \" not supported, using RGB instead\"));\n        model.colorSpace = ColorSpace.RGB;\n      }\n    }\n\n    if (colorMap.NanColor) {\n      model.nanColor = [].concat(colorMap.NanColor);\n\n      while (model.nanColor.length < 4) {\n        model.nanColor.push(1.0);\n      }\n    }\n\n    if (colorMap.RGBPoints) {\n      var size = colorMap.RGBPoints.length;\n      model.nodes = [];\n      var midpoint = 0.5;\n      var sharpness = 0.0;\n\n      for (var i = 0; i < size; i += 4) {\n        model.nodes.push({\n          x: colorMap.RGBPoints[i],\n          r: colorMap.RGBPoints[i + 1],\n          g: colorMap.RGBPoints[i + 2],\n          b: colorMap.RGBPoints[i + 3],\n          midpoint: midpoint,\n          sharpness: sharpness\n        });\n      }\n    } // FIXME: not supported ?\n    // if (colorMap.IndexedColors) {\n    // }\n    // if (colorMap.Annotations) {\n    // }\n\n\n    publicAPI.sortAndUpdateRange();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  clamping: true,\n  colorSpace: ColorSpace.RGB,\n  hSVWrap: true,\n  scale: Scale.LINEAR,\n  nanColor: null,\n  belowRangeColor: null,\n  aboveRangeColor: null,\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n  allowDuplicateScalars: false,\n  table: null,\n  tableSize: 0,\n  buildTime: null,\n  nodes: null,\n  discretize: false,\n  numberOfValues: 256\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkScalarsToColors.extend(publicAPI, model, initialValues); // Internal objects initialization\n\n  model.table = [];\n  model.nodes = [];\n  model.nanColor = [0.5, 0.0, 0.0, 1.0];\n  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];\n  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];\n  model.buildTime = {};\n  macro.obj(model.buildTime); // Create get-only macros\n\n  macro.get(publicAPI, model, ['buildTime', 'mappingRange']); // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['useAboveRangeColor', 'useBelowRangeColor', 'colorSpace', 'discretize', 'numberOfValues']);\n  macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4); // Create get macros for array\n\n  macro.getArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkColorTransferFunction(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkColorTransferFunction'); // ----------------------------------------------------------------------------\n\nvar vtkColorTransferFunction$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, Constants);\n\nexport { vtkColorTransferFunction$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["ColorSpace", "Scale"]
}
