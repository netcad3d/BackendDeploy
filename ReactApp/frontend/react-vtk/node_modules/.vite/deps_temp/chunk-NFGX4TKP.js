import {
  macro
} from "./chunk-OTTIIP4A.js";

// node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js
var vtkErrorMacro = macro.vtkErrorMacro;
function vtkPiecewiseFunction(publicAPI, model) {
  model.classHierarchy.push("vtkPiecewiseFunction");
  publicAPI.getSize = function() {
    return model.nodes.length;
  };
  publicAPI.getType = function() {
    var value;
    var prevValue = 0;
    var functionType = 0;
    if (model.nodes.length > 0) {
      prevValue = model.nodes[0].y;
    }
    for (var i = 1; i < model.nodes.length; i++) {
      value = model.nodes[i].y;
      if (value !== prevValue) {
        if (value > prevValue) {
          switch (functionType) {
            case 0:
            case 1:
              functionType = 1;
              break;
            case 2:
            default:
              functionType = 3;
              break;
          }
        } else {
          switch (functionType) {
            case 0:
            case 2:
              functionType = 2;
              break;
            case 1:
            default:
              functionType = 3;
              break;
          }
        }
      }
      prevValue = value;
      if (functionType === 3) {
        break;
      }
    }
    switch (functionType) {
      case 0:
        return "Constant";
      case 1:
        return "NonDecreasing";
      case 2:
        return "NonIncreasing";
      case 3:
      default:
        return "Varied";
    }
  };
  publicAPI.getDataPointer = function() {
    var size = model.nodes.length;
    model.function = null;
    if (size > 0) {
      model.function = [];
      for (var i = 0; i < size; i++) {
        model.function[2 * i] = model.nodes[i].x;
        model.function[2 * i + 1] = model.nodes[i].y;
      }
    }
    return model.function;
  };
  publicAPI.getFirstNonZeroValue = function() {
    if (model.nodes.length === 0) {
      return 0;
    }
    var allZero = 1;
    var x = 0;
    var i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].y !== 0) {
        allZero = 0;
        break;
      }
    }
    if (allZero) {
      x = Number.MAX_VALUE;
    } else if (i > 0) {
      x = model.nodes[i - 1].x;
    } else if (model.clamping) {
      x = -Number.MAX_VALUE;
    } else {
      x = model.nodes[0].x;
    }
    return x;
  };
  publicAPI.getNodeValue = function(index, val) {
    var size = model.nodes.length;
    if (index < 0 || index >= size) {
      vtkErrorMacro("Index out of range!");
      return -1;
    }
    val[0] = model.nodes[index].x;
    val[1] = model.nodes[index].y;
    val[2] = model.nodes[index].midpoint;
    val[3] = model.nodes[index].sharpness;
    return 1;
  };
  publicAPI.setNodeValue = function(index, val) {
    var size = model.nodes.length;
    if (index < 0 || index >= size) {
      vtkErrorMacro("Index out of range!");
      return -1;
    }
    var oldX = model.nodes[index].x;
    model.nodes[index].x = val[0];
    model.nodes[index].y = val[1];
    model.nodes[index].midpoint = val[2];
    model.nodes[index].sharpness = val[3];
    if (oldX !== val[0]) {
      publicAPI.sortAndUpdateRange();
    } else {
      publicAPI.modified();
    }
    return 1;
  };
  publicAPI.addPoint = function(x, y) {
    return publicAPI.addPointLong(x, y, 0.5, 0);
  };
  publicAPI.addPointLong = function(x, y, midpoint, sharpness) {
    if (midpoint < 0 || midpoint > 1) {
      vtkErrorMacro("Midpoint outside range [0.0, 1.0]");
      return -1;
    }
    if (sharpness < 0 || sharpness > 1) {
      vtkErrorMacro("Sharpness outside range [0.0, 1.0]");
      return -1;
    }
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }
    var node = {
      x,
      y,
      midpoint,
      sharpness
    };
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();
    var i;
    for (i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };
  publicAPI.setNodes = function(nodes) {
    if (model.nodes !== nodes) {
      model.nodes = nodes;
      publicAPI.sortAndUpdateRange();
    }
  };
  publicAPI.sortAndUpdateRange = function() {
    model.nodes.sort(function(a, b) {
      return a.x - b.x;
    });
    var modifiedInvoked = publicAPI.updateRange();
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
  };
  publicAPI.updateRange = function() {
    var oldRange = model.range.slice();
    var size = model.nodes.length;
    if (size) {
      model.range[0] = model.nodes[0].x;
      model.range[1] = model.nodes[size - 1].x;
    } else {
      model.range[0] = 0;
      model.range[1] = 0;
    }
    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };
  publicAPI.removePoint = function(x) {
    var i;
    for (i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i >= model.nodes.length) {
      return -1;
    }
    var retVal = i;
    var modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };
  publicAPI.removeAllPoints = function() {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.addSegment = function(x1, y1, x2, y2) {
    publicAPI.sortAndUpdateRange();
    for (var i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }
    publicAPI.addPoint(x1, y1, 0.5, 0);
    publicAPI.addPoint(x2, y2, 0.5, 0);
  };
  publicAPI.getValue = function(x) {
    var table = [];
    publicAPI.getTable(x, x, 1, table);
    return table[0];
  };
  publicAPI.adjustRange = function(range) {
    if (range.length < 2) {
      return 0;
    }
    var functionRange = publicAPI.getRange();
    if (functionRange[0] < range[0]) {
      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));
    } else {
      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));
    }
    if (functionRange[1] > range[1]) {
      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));
    } else {
      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));
    }
    publicAPI.sortAndUpdateRange();
    for (var i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    publicAPI.sortAndUpdateRange();
    return 1;
  };
  publicAPI.estimateMinNumberOfSamples = function(x1, x2) {
    var d = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d);
  };
  publicAPI.findMinimumXDistance = function() {
    var size = model.nodes.length;
    if (size < 2) {
      return -1;
    }
    var distance = model.nodes[1].x - model.nodes[0].x;
    for (var i = 0; i < size - 1; i++) {
      var currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance) {
        distance = currentDist;
      }
    }
    return distance;
  };
  publicAPI.getTable = function(xStart, xEnd, size, table) {
    var stride = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
    var i;
    var idx = 0;
    var numNodes = model.nodes.length;
    var lastValue = 0;
    if (numNodes !== 0) {
      lastValue = model.nodes[numNodes - 1].y;
    }
    var x = 0;
    var x1 = 0;
    var x2 = 0;
    var y1 = 0;
    var y2 = 0;
    var midpoint = 0;
    var sharpness = 0;
    for (i = 0; i < size; i++) {
      var tidx = stride * i;
      if (size > 1) {
        x = xStart + i / (size - 1) * (xEnd - xStart);
      } else {
        x = 0.5 * (xStart + xEnd);
      }
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          y1 = model.nodes[idx - 1].y;
          y2 = model.nodes[idx].y;
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;
          if (midpoint < 1e-5) {
            midpoint = 1e-5;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }
      if (idx >= numNodes) {
        table[tidx] = model.clamping ? lastValue : 0;
      } else if (idx === 0) {
        table[tidx] = model.clamping ? model.nodes[0].y : 0;
      } else {
        var s = (x - x1) / (x2 - x1);
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1 - midpoint);
        }
        if (sharpness > 0.99) {
          if (s < 0.5) {
            table[tidx] = y1;
            continue;
          } else {
            table[tidx] = y2;
            continue;
          }
        }
        if (sharpness < 0.01) {
          table[tidx] = (1 - s) * y1 + s * y2;
          continue;
        }
        if (s < 0.5) {
          s = 0.5 * Math.pow(s * 2, 1 + 10 * sharpness);
        } else if (s > 0.5) {
          s = 1 - 0.5 * Math.pow((1 - s) * 2, 1 + 10 * sharpness);
        }
        var ss = s * s;
        var sss = ss * s;
        var h1 = 2 * sss - 3 * ss + 1;
        var h2 = -2 * sss + 3 * ss;
        var h3 = sss - 2 * ss + s;
        var h4 = sss - ss;
        var slope = y2 - y1;
        var t = (1 - sharpness) * slope;
        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t;
        var min = y1 < y2 ? y1 : y2;
        var max = y1 > y2 ? y1 : y2;
        table[tidx] = table[tidx] < min ? min : table[tidx];
        table[tidx] = table[tidx] > max ? max : table[tidx];
      }
    }
  };
}
var DEFAULT_VALUES = {
  range: [0, 0],
  clamping: true,
  allowDuplicateScalars: false
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  model.nodes = [];
  macro.setGet(publicAPI, model, ["allowDuplicateScalars", "clamping"]);
  macro.setArray(publicAPI, model, ["range"], 2);
  macro.getArray(publicAPI, model, ["range"]);
  vtkPiecewiseFunction(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkPiecewiseFunction");
var vtkPiecewiseFunction$1 = {
  newInstance,
  extend
};

export {
  extend,
  newInstance,
  vtkPiecewiseFunction$1
};
//# sourceMappingURL=chunk-NFGX4TKP.js.map
