import {
  vtkDataArray$1
} from "./chunk-Z5OKWKLG.js";
import {
  macro,
  vtk
} from "./chunk-OTTIIP4A.js";
import {
  _defineProperty
} from "./chunk-HKWV5KNA.js";

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/FieldData.js
var vtkErrorMacro = macro.vtkErrorMacro;
var vtkWarningMacro = macro.vtkWarningMacro;
function vtkFieldData(publicAPI, model) {
  model.classHierarchy.push("vtkFieldData");
  var superGetState = publicAPI.getState;
  if (model.arrays) {
    model.arrays = model.arrays.map(function(item) {
      return {
        data: vtk(item.data)
      };
    });
  }
  publicAPI.initialize = function() {
    publicAPI.initializeFields();
    publicAPI.copyAllOn();
    publicAPI.clearFieldFlags();
  };
  publicAPI.initializeFields = function() {
    model.arrays = [];
    model.copyFieldFlags = {};
    publicAPI.modified();
  };
  publicAPI.copyStructure = function(other) {
    publicAPI.initializeFields();
    model.copyFieldFlags = other.getCopyFieldFlags().map(function(x) {
      return x;
    });
    model.arrays = other.arrays().map(function(x) {
      return {
        array: x
      };
    });
  };
  publicAPI.getNumberOfArrays = function() {
    return model.arrays.length;
  };
  publicAPI.getNumberOfActiveArrays = function() {
    return model.arrays.length;
  };
  publicAPI.addArray = function(arr) {
    var name = arr.getName();
    var _publicAPI$getArrayWi = publicAPI.getArrayWithIndex(name), array = _publicAPI$getArrayWi.array, index = _publicAPI$getArrayWi.index;
    if (array != null) {
      model.arrays[index] = {
        data: arr
      };
      return index;
    }
    model.arrays = [].concat(model.arrays, {
      data: arr
    });
    return model.arrays.length - 1;
  };
  publicAPI.removeAllArrays = function() {
    model.arrays = [];
  };
  publicAPI.removeArray = function(arrayName) {
    model.arrays = model.arrays.filter(function(entry) {
      return arrayName !== entry.data.getName();
    });
  };
  publicAPI.removeArrayByIndex = function(arrayIdx) {
    model.arrays = model.arrays.filter(function(entry, idx) {
      return idx !== arrayIdx;
    });
  };
  publicAPI.getArrays = function() {
    return model.arrays.map(function(entry) {
      return entry.data;
    });
  };
  publicAPI.getArray = function(arraySpec) {
    return typeof arraySpec === "number" ? publicAPI.getArrayByIndex(arraySpec) : publicAPI.getArrayByName(arraySpec);
  };
  publicAPI.getArrayByName = function(arrayName) {
    return model.arrays.reduce(function(a, b, i) {
      return b.data.getName() === arrayName ? b.data : a;
    }, null);
  };
  publicAPI.getArrayWithIndex = function(arrayName) {
    return model.arrays.reduce(function(a, b, i) {
      return b.data && b.data.getName() === arrayName ? {
        array: b.data,
        index: i
      } : a;
    }, {
      array: null,
      index: -1
    });
  };
  publicAPI.getArrayByIndex = function(idx) {
    return idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;
  };
  publicAPI.hasArray = function(arrayName) {
    return publicAPI.getArrayWithIndex(arrayName).index >= 0;
  };
  publicAPI.getArrayName = function(idx) {
    var arr = model.arrays[idx];
    return arr ? arr.data.getName() : "";
  };
  publicAPI.getCopyFieldFlags = function() {
    return model.copyFieldFlags;
  };
  publicAPI.getFlag = function(arrayName) {
    return model.copyFieldFlags[arrayName];
  };
  publicAPI.passData = function(other) {
    var fromId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    var toId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    other.getArrays().forEach(function(arr) {
      var copyFlag = publicAPI.getFlag(arr.getName());
      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
        var destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId < 0 || fromId > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
            other.getAttributes(arr).forEach(function(attrType) {
              publicAPI.setAttribute(arr, attrType);
            });
          } else {
            var ncomps = arr.getNumberOfComponents();
            var newSize = arr.getNumberOfValues();
            var tId = toId > -1 ? toId : fromId;
            if (newSize <= tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtkDataArray$1.newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: ncomps,
              values: macro.newTypedArray(arr.getDataType(), newSize),
              size: 0
            });
            destArr.insertTuple(tId, arr.getTuple(fromId));
            publicAPI.addArray(destArr);
            other.getAttributes(arr).forEach(function(attrType) {
              publicAPI.setAttribute(destArr, attrType);
            });
          }
        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
          if (fromId > -1 && fromId < arr.getNumberOfTuples()) {
            var _tId = toId > -1 ? toId : fromId;
            destArr.insertTuple(_tId, arr.getTuple(fromId));
          } else {
            destArr.insertTuples(0, arr.getTuples());
          }
        } else {
          vtkErrorMacro("Unhandled case in passData");
        }
      }
    });
  };
  publicAPI.interpolateData = function(other) {
    var fromId1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    var fromId2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    var toId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;
    var t = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
    other.getArrays().forEach(function(arr) {
      var copyFlag = publicAPI.getFlag(arr.getName());
      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
        var destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId1 < 0 || fromId2 < 0 || fromId1 > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
            other.getAttributes(arr).forEach(function(attrType) {
              publicAPI.setAttribute(arr, attrType);
            });
          } else {
            var ncomps = arr.getNumberOfComponents();
            var newSize = arr.getNumberOfValues();
            var tId = toId > -1 ? toId : fromId1;
            if (newSize <= tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtkDataArray$1.newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: ncomps,
              values: macro.newTypedArray(arr.getDataType(), newSize),
              size: 0
            });
            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);
            publicAPI.addArray(destArr);
            other.getAttributes(arr).forEach(function(attrType) {
              publicAPI.setAttribute(destArr, attrType);
            });
          }
        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
          if (fromId1 > -1 && fromId1 < arr.getNumberOfTuples()) {
            var _tId2 = toId > -1 ? toId : fromId1;
            destArr.interpolateTuple(_tId2, arr, fromId1, arr, fromId2, t);
            vtkWarningMacro("Unexpected case in interpolateData");
          } else {
            destArr.insertTuples(arr.getTuples());
          }
        } else {
          vtkErrorMacro("Unhandled case in interpolateData");
        }
      }
    });
  };
  publicAPI.copyFieldOn = function(arrayName) {
    model.copyFieldFlags[arrayName] = true;
  };
  publicAPI.copyFieldOff = function(arrayName) {
    model.copyFieldFlags[arrayName] = false;
  };
  publicAPI.copyAllOn = function() {
    if (!model.doCopyAllOn || model.doCopyAllOff) {
      model.doCopyAllOn = true;
      model.doCopyAllOff = false;
      publicAPI.modified();
    }
  };
  publicAPI.copyAllOff = function() {
    if (model.doCopyAllOn || !model.doCopyAllOff) {
      model.doCopyAllOn = false;
      model.doCopyAllOff = true;
      publicAPI.modified();
    }
  };
  publicAPI.clearFieldFlags = function() {
    model.copyFieldFlags = {};
  };
  publicAPI.deepCopy = function(other) {
    model.arrays = other.getArrays().map(function(arr) {
      var arrNew = arr.newClone();
      arrNew.deepCopy(arr);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.copyFlags = function(other) {
    return other.getCopyFieldFlags().map(function(x) {
      return x;
    });
  };
  publicAPI.reset = function() {
    return model.arrays.forEach(function(entry) {
      return entry.data.reset();
    });
  };
  publicAPI.getMTime = function() {
    return model.arrays.reduce(function(a, b) {
      return b.data.getMTime() > a ? b.data.getMTime() : a;
    }, model.mtime);
  };
  publicAPI.getNumberOfComponents = function() {
    return model.arrays.reduce(function(a, b) {
      return a + b.data.getNumberOfComponents();
    }, 0);
  };
  publicAPI.getNumberOfTuples = function() {
    return model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;
  };
  publicAPI.getState = function() {
    var result = superGetState();
    if (result) {
      result.arrays = model.arrays.map(function(item) {
        return {
          data: item.data.getState()
        };
      });
    }
    return result;
  };
}
var DEFAULT_VALUES = {
  arrays: [],
  copyFieldFlags: [],
  doCopyAllOn: true,
  doCopyAllOff: false
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  vtkFieldData(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkFieldData");
var vtkFieldData$1 = {
  newInstance,
  extend
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js
var AttributeTypes = {
  SCALARS: 0,
  VECTORS: 1,
  NORMALS: 2,
  TCOORDS: 3,
  TENSORS: 4,
  GLOBALIDS: 5,
  PEDIGREEIDS: 6,
  EDGEFLAG: 7,
  NUM_ATTRIBUTES: 8
};
var AttributeLimitTypes = {
  MAX: 0,
  EXACT: 1,
  NOLIMIT: 2
};
var CellGhostTypes = {
  DUPLICATECELL: 1,
  HIGHCONNECTIVITYCELL: 2,
  LOWCONNECTIVITYCELL: 4,
  REFINEDCELL: 8,
  EXTERIORCELL: 16,
  HIDDENCELL: 32
};
var PointGhostTypes = {
  DUPLICATEPOINT: 1,
  HIDDENPOINT: 2
};
var AttributeCopyOperations = {
  COPYTUPLE: 0,
  INTERPOLATE: 1,
  PASSDATA: 2,
  ALLCOPY: 3
};
var ghostArrayName = "vtkGhostType";
var DesiredOutputPrecision = {
  DEFAULT: 0,
  SINGLE: 1,
  DOUBLE: 2
};
var Constants = {
  AttributeCopyOperations,
  AttributeLimitTypes,
  AttributeTypes,
  CellGhostTypes,
  DesiredOutputPrecision,
  PointGhostTypes,
  ghostArrayName
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var AttributeTypes2 = Constants.AttributeTypes;
var AttributeCopyOperations2 = Constants.AttributeCopyOperations;
var vtkWarningMacro2 = macro.vtkWarningMacro;
function vtkDataSetAttributes(publicAPI, model) {
  var attrTypes = ["Scalars", "Vectors", "Normals", "TCoords", "Tensors", "GlobalIds", "PedigreeIds"];
  function cleanAttributeType(attType) {
    var cleanAttType = attrTypes.find(function(ee) {
      return AttributeTypes2[ee.toUpperCase()] === attType || typeof attType !== "number" && ee.toLowerCase() === attType.toLowerCase();
    });
    if (typeof cleanAttType === "undefined") {
      cleanAttType = null;
    }
    return cleanAttType;
  }
  model.classHierarchy.push("vtkDataSetAttributes");
  publicAPI.checkNumberOfComponents = function(x) {
    return true;
  };
  publicAPI.setAttribute = function(arr, uncleanAttType) {
    var attType = cleanAttributeType(uncleanAttType);
    if (arr && attType.toUpperCase() === "PEDIGREEIDS" && !arr.isA("vtkDataArray")) {
      vtkWarningMacro2("Cannot set attribute ".concat(attType, ". The attribute must be a vtkDataArray."));
      return -1;
    }
    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {
      vtkWarningMacro2("Cannot set attribute ".concat(attType, ". Incorrect number of components."));
      return -1;
    }
    var currentAttribute = model["active".concat(attType)];
    if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {
      if (model.arrays[currentAttribute] === arr) {
        return currentAttribute;
      }
      publicAPI.removeArrayByIndex(currentAttribute);
    }
    if (arr) {
      currentAttribute = publicAPI.addArray(arr);
      model["active".concat(attType)] = currentAttribute;
    } else {
      model["active".concat(attType)] = -1;
    }
    publicAPI.modified();
    return model["active".concat(attType)];
  };
  publicAPI.getAttributes = function(arr) {
    return attrTypes.filter(function(attrType) {
      return publicAPI["get".concat(attrType)]() === arr;
    });
  };
  publicAPI.setActiveAttributeByName = function(arrayName, attType) {
    return publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);
  };
  publicAPI.setActiveAttributeByIndex = function(arrayIdx, uncleanAttType) {
    var attType = cleanAttributeType(uncleanAttType);
    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {
      if (attType.toUpperCase() !== "PEDIGREEIDS") {
        var arr = publicAPI.getArrayByIndex(arrayIdx);
        if (!arr.isA("vtkDataArray")) {
          vtkWarningMacro2("Cannot set attribute ".concat(attType, ". Only vtkDataArray subclasses can be set as active attributes."));
          return -1;
        }
        if (!publicAPI.checkNumberOfComponents(arr, attType)) {
          vtkWarningMacro2("Cannot set attribute ".concat(attType, ". Incorrect number of components."));
          return -1;
        }
      }
      model["active".concat(attType)] = arrayIdx;
      publicAPI.modified();
      return arrayIdx;
    }
    if (arrayIdx === -1) {
      model["active".concat(attType)] = arrayIdx;
      publicAPI.modified();
    }
    return -1;
  };
  publicAPI.getActiveAttribute = function(attType) {
    var cleanAttType = cleanAttributeType(attType);
    return publicAPI["get".concat(cleanAttType)]();
  };
  publicAPI.removeAllArrays = function() {
    model.arrays = [];
    attrTypes.forEach(function(attType) {
      model["active".concat(attType)] = -1;
    });
  };
  publicAPI.removeArray = function(arrayName) {
    model.arrays = model.arrays.filter(function(entry, idx) {
      if (arrayName === entry.data.getName()) {
        attrTypes.forEach(function(attType) {
          if (idx === model["active".concat(attType)]) {
            model["active".concat(attType)] = -1;
          }
        });
        return false;
      }
      return true;
    });
  };
  publicAPI.removeArrayByIndex = function(arrayIdx) {
    model.arrays = model.arrays.filter(function(entry, idx) {
      return idx !== arrayIdx;
    });
    attrTypes.forEach(function(attType) {
      if (arrayIdx === model["active".concat(attType)]) {
        model["active".concat(attType)] = -1;
      }
    });
  };
  attrTypes.forEach(function(value) {
    var activeVal = "active".concat(value);
    publicAPI["get".concat(value)] = function() {
      return publicAPI.getArrayByIndex(model[activeVal]);
    };
    publicAPI["set".concat(value)] = function(da) {
      return publicAPI.setAttribute(da, value);
    };
    publicAPI["setActive".concat(value)] = function(arrayName) {
      return publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);
    };
    publicAPI["copy".concat(value, "Off")] = function() {
      var attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations2.PASSDATA][AttributeTypes2[attType]] = false;
    };
    publicAPI["copy".concat(value, "On")] = function() {
      var attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations2.PASSDATA][AttributeTypes2[attType]] = true;
    };
  });
  publicAPI.initializeAttributeCopyFlags = function() {
    model.copyAttributeFlags = [];
    Object.keys(AttributeCopyOperations2).filter(function(op) {
      return op !== "ALLCOPY";
    }).forEach(function(attCopyOp) {
      model.copyAttributeFlags[AttributeCopyOperations2[attCopyOp]] = Object.keys(AttributeTypes2).filter(function(ty) {
        return ty !== "NUM_ATTRIBUTES";
      }).reduce(function(a, b) {
        a[AttributeTypes2[b]] = true;
        return a;
      }, []);
    });
    model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations2.INTERPOLATE][AttributeTypes2.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.PEDIGREEIDS] = false;
  };
  publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags);
  if (model.dataArrays && Object.keys(model.dataArrays).length) {
    Object.keys(model.dataArrays).forEach(function(name) {
      if (!model.dataArrays[name].ref && model.dataArrays[name].type === "vtkDataArray") {
        publicAPI.addArray(vtkDataArray$1.newInstance(model.dataArrays[name]));
      }
    });
  }
  var superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other, debug) {
    superShallowCopy(other, debug);
    model.arrays = other.getArrays().map(function(arr) {
      var arrNew = arr.newClone();
      arrNew.shallowCopy(arr, debug);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.initializeAttributeCopyFlags();
}
var DEFAULT_VALUES2 = {
  activeScalars: -1,
  activeVectors: -1,
  activeTensors: -1,
  activeNormals: -1,
  activeTCoords: -1,
  activeGlobalIds: -1,
  activePedigreeIds: -1
};
function extend2(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  vtkFieldData$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["activeScalars", "activeNormals", "activeTCoords", "activeVectors", "activeTensors", "activeGlobalIds", "activePedigreeIds"]);
  if (!model.arrays) {
    model.arrays = {};
  }
  vtkDataSetAttributes(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend2, "vtkDataSetAttributes");
var vtkDataSetAttributes$1 = _objectSpread({
  newInstance: newInstance2,
  extend: extend2
}, Constants);

// node_modules/@kitware/vtk.js/Common/DataModel/DataSet/Constants.js
var FieldDataTypes = {
  UNIFORM: 0,
  DATA_OBJECT_FIELD: 0,
  COORDINATE: 1,
  POINT_DATA: 1,
  POINT: 2,
  POINT_FIELD_DATA: 2,
  CELL: 3,
  CELL_FIELD_DATA: 3,
  VERTEX: 4,
  VERTEX_FIELD_DATA: 4,
  EDGE: 5,
  EDGE_FIELD_DATA: 5,
  ROW: 6,
  ROW_DATA: 6
};
var FieldAssociations = {
  FIELD_ASSOCIATION_POINTS: 0,
  FIELD_ASSOCIATION_CELLS: 1,
  FIELD_ASSOCIATION_NONE: 2,
  FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,
  FIELD_ASSOCIATION_VERTICES: 4,
  FIELD_ASSOCIATION_EDGES: 5,
  FIELD_ASSOCIATION_ROWS: 6,
  NUMBER_OF_ASSOCIATIONS: 7
};
var Constants2 = {
  FieldDataTypes,
  FieldAssociations
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSet.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var DATASET_FIELDS = ["pointData", "cellData", "fieldData"];
function vtkDataSet(publicAPI, model) {
  model.classHierarchy.push("vtkDataSet");
  DATASET_FIELDS.forEach(function(fieldName) {
    if (!model[fieldName]) {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
    } else {
      model[fieldName] = vtk(model[fieldName]);
    }
  });
  var superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    var debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    DATASET_FIELDS.forEach(function(fieldName) {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
      model[fieldName].shallowCopy(other.getReferenceByName(fieldName));
    });
  };
}
var DEFAULT_VALUES3 = {};
function extend3(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, DATASET_FIELDS);
  vtkDataSet(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend3, "vtkDataSet");
var vtkDataSet$1 = _objectSpread2({
  newInstance: newInstance3,
  extend: extend3
}, Constants2);

export {
  vtkDataSet$1
};
//# sourceMappingURL=chunk-Z2LVQNSU.js.map
