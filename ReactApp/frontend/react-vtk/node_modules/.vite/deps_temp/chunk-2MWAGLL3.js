// node_modules/@kitware/vtk.js/Common/Core/Endian.js
function getEndianness() {
  var a = new ArrayBuffer(4);
  var b = new Uint8Array(a);
  var c = new Uint32Array(a);
  b[0] = 161;
  b[1] = 178;
  b[2] = 195;
  b[3] = 212;
  if (c[0] === 3569595041)
    return "LittleEndian";
  if (c[0] === 2712847316)
    return "BigEndian";
  return null;
}
var ENDIANNESS = getEndianness();
function swapBytes(buffer, wordSize) {
  if (wordSize < 2) {
    return;
  }
  var bytes = new Int8Array(buffer);
  var size = bytes.length;
  var tempBuffer = [];
  for (var i = 0; i < size; i += wordSize) {
    for (var j = 0; j < wordSize; j++) {
      tempBuffer.push(bytes[i + j]);
    }
    for (var _j = 0; _j < wordSize; _j++) {
      bytes[i + _j] = tempBuffer.pop();
    }
  }
}
var Endian = {
  ENDIANNESS,
  getEndianness,
  swapBytes
};

// node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper.js
var TYPE_MAPPING = {};
function has(type) {
  return !!TYPE_MAPPING[type];
}
function get() {
  var type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "http";
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return TYPE_MAPPING[type](options);
}
function registerType(type, fn) {
  TYPE_MAPPING[type] = fn;
}
var DataAccessHelper = {
  get,
  has,
  registerType
};

export {
  Endian,
  has,
  registerType,
  DataAccessHelper
};
//# sourceMappingURL=chunk-2MWAGLL3.js.map
