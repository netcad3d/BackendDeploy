import {
  vtkDataSet$1
} from "./chunk-Z2LVQNSU.js";
import {
  vtkDataArray$1
} from "./chunk-Z5OKWKLG.js";
import {
  VtkDataTypes
} from "./chunk-SWDS6M4V.js";
import {
  vtkPlane$1
} from "./chunk-SXNZFZKA.js";
import {
  cross,
  determinant2x2,
  distance2BetweenPoints,
  dot,
  multiplyAccumulate,
  normalize,
  solveLinearSystem,
  subtract,
  uninitializeBounds
} from "./chunk-FOWOP5PK.js";
import {
  _toConsumableArray,
  macro,
  vtk
} from "./chunk-OTTIIP4A.js";
import {
  _defineProperty
} from "./chunk-HKWV5KNA.js";

// node_modules/@kitware/vtk.js/Common/Core/Points.js
var vtkErrorMacro = macro.vtkErrorMacro;
var INVALID_BOUNDS = [1, -1, 1, -1, 1, -1];
function vtkPoints(publicAPI, model) {
  model.classHierarchy.push("vtkPoints");
  publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;
  publicAPI.setNumberOfPoints = function(nbPoints) {
    var dimension = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
    if (publicAPI.getNumberOfPoints() !== nbPoints) {
      model.size = nbPoints * dimension;
      model.values = macro.newTypedArray(model.dataType, model.size);
      publicAPI.setNumberOfComponents(dimension);
      publicAPI.modified();
    }
  };
  publicAPI.setPoint = function(idx) {
    for (var _len = arguments.length, xyz = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      xyz[_key - 1] = arguments[_key];
    }
    publicAPI.setTuple(idx, xyz);
  };
  publicAPI.getPoint = publicAPI.getTuple;
  publicAPI.insertNextPoint = function(x, y, z) {
    return publicAPI.insertNextTuple([x, y, z]);
  };
  publicAPI.getBounds = function() {
    if (publicAPI.getNumberOfComponents() === 3) {
      var _xRange = publicAPI.getRange(0);
      model.bounds[0] = _xRange[0];
      model.bounds[1] = _xRange[1];
      var _yRange = publicAPI.getRange(1);
      model.bounds[2] = _yRange[0];
      model.bounds[3] = _yRange[1];
      var zRange = publicAPI.getRange(2);
      model.bounds[4] = zRange[0];
      model.bounds[5] = zRange[1];
      return model.bounds;
    }
    if (publicAPI.getNumberOfComponents() !== 2) {
      vtkErrorMacro("getBounds called on an array with components of\n        ".concat(publicAPI.getNumberOfComponents()));
      return INVALID_BOUNDS;
    }
    var xRange = publicAPI.getRange(0);
    model.bounds[0] = xRange[0];
    model.bounds[1] = xRange[1];
    var yRange = publicAPI.getRange(1);
    model.bounds[2] = yRange[0];
    model.bounds[3] = yRange[1];
    model.bounds[4] = 0;
    model.bounds[5] = 0;
    return model.bounds;
  };
  publicAPI.computeBounds = publicAPI.getBounds;
  publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);
}
var DEFAULT_VALUES = {
  empty: true,
  numberOfComponents: 3,
  dataType: VtkDataTypes.FLOAT,
  bounds: [1, -1, 1, -1, 1, -1]
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  vtkDataArray$1.extend(publicAPI, model, initialValues);
  vtkPoints(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkPoints");
var vtkPoints$1 = {
  newInstance,
  extend
};

// node_modules/@kitware/vtk.js/Common/Core/CellArray.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function extractCellSizes(cellArray) {
  var currentIdx = 0;
  return cellArray.filter(function(value, index) {
    if (index === currentIdx) {
      currentIdx += value + 1;
      return true;
    }
    return false;
  });
}
function getNumberOfCells(cellArray) {
  var cellId = 0;
  for (var cellArrayIndex = 0; cellArrayIndex < cellArray.length; ) {
    cellArrayIndex += cellArray[cellArrayIndex] + 1;
    cellId++;
  }
  return cellId;
}
var STATIC = {
  extractCellSizes,
  getNumberOfCells
};
function vtkCellArray(publicAPI, model) {
  model.classHierarchy.push("vtkCellArray");
  publicAPI.getNumberOfCells = function(recompute) {
    if (model.numberOfCells !== void 0 && !recompute) {
      return model.numberOfCells;
    }
    if (model.cellSizes) {
      model.numberOfCells = model.cellSizes.length;
    } else {
      model.numberOfCells = getNumberOfCells(publicAPI.getData());
    }
    return model.numberOfCells;
  };
  publicAPI.getCellSizes = function(recompute) {
    if (model.cellSizes !== void 0 && !recompute) {
      return model.cellSizes;
    }
    model.cellSizes = extractCellSizes(publicAPI.getData());
    return model.cellSizes;
  };
  var superSetData = publicAPI.setData;
  publicAPI.setData = function(typedArray) {
    superSetData(typedArray, 1);
    model.numberOfCells = void 0;
    model.cellSizes = void 0;
  };
  publicAPI.getCell = function(loc) {
    var cellLoc = loc;
    var numberOfPoints = model.values[cellLoc++];
    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);
  };
  var superInitialize = publicAPI.initialize;
  publicAPI.initialize = function() {
    superInitialize();
    model.numberOfCells = void 0;
    model.cellSizes = void 0;
  };
  publicAPI.insertNextCell = function(cellPointIds) {
    var cellId = publicAPI.getNumberOfCells();
    publicAPI.insertNextTuples([cellPointIds.length].concat(_toConsumableArray(cellPointIds)));
    ++model.numberOfCells;
    if (model.cellSizes != null) {
      model.cellSizes.push(cellPointIds.length);
    }
    return cellId;
  };
}
function defaultValues(initialValues) {
  return _objectSpread({
    empty: true,
    numberOfComponents: 1,
    dataType: VtkDataTypes.UNSIGNED_INT
  }, initialValues);
}
function extend2(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkDataArray$1.extend(publicAPI, model, defaultValues(initialValues));
  vtkCellArray(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend2, "vtkCellArray");
var vtkCellArray$1 = _objectSpread({
  newInstance: newInstance2,
  extend: extend2
}, STATIC);

// node_modules/@kitware/vtk.js/Common/DataModel/Cell.js
function vtkCell(publicAPI, model) {
  model.classHierarchy.push("vtkCell");
  publicAPI.initialize = function(points) {
    var pointIdsList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!pointIdsList) {
      model.points = points;
      model.pointsIds = new Array(points.getNumberOfPoints());
      for (var i = points.getNumberOfPoints() - 1; i >= 0; --i) {
        model.pointsIds[i] = i;
      }
    } else {
      model.pointsIds = pointIdsList;
      var triangleData = model.points.getData();
      if (triangleData.length !== 3 * model.pointsIds.length) {
        triangleData = macro.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);
      }
      var pointsData = points.getData();
      model.pointsIds.forEach(function(pointId, index) {
        var pointOffset = 3 * pointId;
        var trianglePointOffset = 3 * index;
        triangleData[trianglePointOffset] = pointsData[pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
      });
      model.points.setData(triangleData);
    }
  };
  publicAPI.getBounds = function() {
    var nbPoints = model.points.getNumberOfPoints();
    var x = [];
    if (nbPoints) {
      model.points.getPoint(0, x);
      model.bounds[0] = x[0];
      model.bounds[1] = x[0];
      model.bounds[2] = x[1];
      model.bounds[3] = x[1];
      model.bounds[4] = x[2];
      model.bounds[5] = x[2];
      for (var i = 1; i < nbPoints; i++) {
        model.points.getPoint(i, x);
        model.bounds[0] = x[0] < model.bounds[0] ? x[0] : model.bounds[0];
        model.bounds[1] = x[0] > model.bounds[1] ? x[0] : model.bounds[1];
        model.bounds[2] = x[1] < model.bounds[2] ? x[1] : model.bounds[2];
        model.bounds[3] = x[1] > model.bounds[3] ? x[1] : model.bounds[3];
        model.bounds[4] = x[2] < model.bounds[4] ? x[2] : model.bounds[4];
        model.bounds[5] = x[2] > model.bounds[5] ? x[2] : model.bounds[5];
      }
    } else {
      uninitializeBounds(model.bounds);
    }
    return model.bounds;
  };
  publicAPI.getLength2 = function() {
    publicAPI.getBounds();
    var length = 0;
    var diff = 0;
    for (var i = 0; i < 3; i++) {
      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];
      length += diff * diff;
    }
    return length;
  };
  publicAPI.getParametricDistance = function(pcoords) {
    var pDist;
    var pDistMax = 0;
    for (var i = 0; i < 3; i++) {
      if (pcoords[i] < 0) {
        pDist = -pcoords[i];
      } else if (pcoords[i] > 1) {
        pDist = pcoords[i] - 1;
      } else {
        pDist = 0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
  publicAPI.getNumberOfPoints = function() {
    return model.points.getNumberOfPoints();
  };
  publicAPI.deepCopy = function(cell) {
    cell.initialize(model.points, model.pointsIds);
  };
  publicAPI.getCellDimension = function() {
  };
  publicAPI.intersectWithLine = function(p1, p2, tol, t, x, pcoords, subId) {
  };
  publicAPI.evaluatePosition = function(x, closestPoint, subId, pcoords, dist2, weights) {
    macro.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.");
  };
}
var DEFAULT_VALUES2 = {
  bounds: [-1, -1, -1, -1, -1, -1],
  pointsIds: []
};
function extend3(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  macro.obj(publicAPI, model);
  if (!model.points) {
    model.points = vtkPoints$1.newInstance();
  }
  macro.get(publicAPI, model, ["points", "pointsIds"]);
  vtkCell(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend3, "vtkCell");
var vtkCell$1 = {
  newInstance: newInstance3,
  extend: extend3
};

// node_modules/@kitware/vtk.js/Common/DataModel/CellLinks.js
function resize(model, sz) {
  var newSize = sz;
  if (sz >= model.array.length) {
    newSize += model.array.length;
  }
  while (newSize > model.array.length) {
    model.array.push({
      ncells: 0,
      cells: null
    });
  }
  model.array.length = newSize;
}
function vtkCellLinks(publicAPI, model) {
  model.classHierarchy.push("vtkCellLinks");
  publicAPI.buildLinks = function(data) {
    var numPts = data.getPoints().getNumberOfPoints();
    var numCells = data.getNumberOfCells();
    var linkLoc = new Uint32Array(numPts);
    if (data.isA("vtkPolyData")) {
      for (var cellId = 0; cellId < numCells; ++cellId) {
        var _data$getCellPoints = data.getCellPoints(cellId), cellPointIds = _data$getCellPoints.cellPointIds;
        cellPointIds.forEach(function(cellPointId) {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      var _loop = function _loop3(_cellId4) {
        var _data$getCellPoints2 = data.getCellPoints(_cellId4), cellPointIds2 = _data$getCellPoints2.cellPointIds;
        cellPointIds2.forEach(function(cellPointId) {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, _cellId4);
        });
      };
      for (var _cellId = 0; _cellId < numCells; ++_cellId) {
        _loop(_cellId);
      }
    } else {
      for (var _cellId2 = 0; _cellId2 < numCells; _cellId2++) {
        var cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach(function(cellPointId) {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      var _loop2 = function _loop22(_cellId32) {
        var cell2 = vtkCell$1.newInstance();
        cell2.getPointsIds().forEach(function(cellPointId) {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, _cellId32);
        });
      };
      for (var _cellId3 = 0; _cellId3 < numCells; ++_cellId3) {
        _loop2(_cellId3);
      }
    }
  };
  publicAPI.allocate = function(numLinks) {
    var ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    model.array = Array(numLinks).fill().map(function() {
      return {
        ncells: 0,
        cells: null
      };
    });
    model.extend = ext;
    model.maxId = -1;
  };
  publicAPI.initialize = function() {
    model.array = null;
  };
  publicAPI.getLink = function(ptId) {
    return model.array[ptId];
  };
  publicAPI.getNcells = function(ptId) {
    return model.array[ptId].ncells;
  };
  publicAPI.getCells = function(ptId) {
    return model.array[ptId].cells;
  };
  publicAPI.insertNextPoint = function(numLinks) {
    model.array.push({
      ncells: numLinks,
      cells: Array(numLinks)
    });
    ++model.maxId;
  };
  publicAPI.insertNextCellReference = function(ptId, cellId) {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.deletePoint = function(ptId) {
    model.array[ptId].ncells = 0;
    model.array[ptId].cells = null;
  };
  publicAPI.removeCellReference = function(cellId, ptId) {
    model.array[ptId].cells = model.array[ptId].cells.filter(function(cell) {
      return cell !== cellId;
    });
    model.array[ptId].ncells = model.array[ptId].cells.length;
  };
  publicAPI.addCellReference = function(cellId, ptId) {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.resizeCellList = function(ptId, size) {
    model.array[ptId].cells.length = size;
  };
  publicAPI.squeeze = function() {
    resize(model, model.maxId + 1);
  };
  publicAPI.reset = function() {
    model.maxId = -1;
  };
  publicAPI.deepCopy = function(src) {
    model.array = _toConsumableArray(src.array);
    model.extend = src.extend;
    model.maxId = src.maxId;
  };
  publicAPI.incrementLinkCount = function(ptId) {
    ++model.array[ptId].ncells;
  };
  publicAPI.allocateLinks = function(n) {
    for (var i = 0; i < n; ++i) {
      model.array[i].cells = new Array(model.array[i].ncells);
    }
  };
  publicAPI.insertCellReference = function(ptId, pos, cellId) {
    model.array[ptId].cells[pos] = cellId;
  };
}
var DEFAULT_VALUES3 = {
  array: null,
  maxId: 0,
  extend: 0
};
function extend4(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  macro.obj(publicAPI, model);
  vtkCellLinks(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend4, "vtkCellLinks");
var vtkCellLinks$1 = {
  newInstance: newInstance4,
  extend: extend4
};

// node_modules/@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js
var CellType = {
  VTK_EMPTY_CELL: 0,
  VTK_VERTEX: 1,
  VTK_POLY_VERTEX: 2,
  VTK_LINE: 3,
  VTK_POLY_LINE: 4,
  VTK_TRIANGLE: 5,
  VTK_TRIANGLE_STRIP: 6,
  VTK_POLYGON: 7,
  VTK_PIXEL: 8,
  VTK_QUAD: 9,
  VTK_TETRA: 10,
  VTK_VOXEL: 11,
  VTK_HEXAHEDRON: 12,
  VTK_WEDGE: 13,
  VTK_PYRAMID: 14,
  VTK_PENTAGONAL_PRISM: 15,
  VTK_HEXAGONAL_PRISM: 16,
  VTK_QUADRATIC_EDGE: 21,
  VTK_QUADRATIC_TRIANGLE: 22,
  VTK_QUADRATIC_QUAD: 23,
  VTK_QUADRATIC_POLYGON: 36,
  VTK_QUADRATIC_TETRA: 24,
  VTK_QUADRATIC_HEXAHEDRON: 25,
  VTK_QUADRATIC_WEDGE: 26,
  VTK_QUADRATIC_PYRAMID: 27,
  VTK_BIQUADRATIC_QUAD: 28,
  VTK_TRIQUADRATIC_HEXAHEDRON: 29,
  VTK_QUADRATIC_LINEAR_QUAD: 30,
  VTK_QUADRATIC_LINEAR_WEDGE: 31,
  VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,
  VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,
  VTK_BIQUADRATIC_TRIANGLE: 34,
  VTK_CUBIC_LINE: 35,
  VTK_CONVEX_POINT_SET: 41,
  VTK_POLYHEDRON: 42,
  VTK_PARAMETRIC_CURVE: 51,
  VTK_PARAMETRIC_SURFACE: 52,
  VTK_PARAMETRIC_TRI_SURFACE: 53,
  VTK_PARAMETRIC_QUAD_SURFACE: 54,
  VTK_PARAMETRIC_TETRA_REGION: 55,
  VTK_PARAMETRIC_HEX_REGION: 56,
  VTK_HIGHER_ORDER_EDGE: 60,
  VTK_HIGHER_ORDER_TRIANGLE: 61,
  VTK_HIGHER_ORDER_QUAD: 62,
  VTK_HIGHER_ORDER_POLYGON: 63,
  VTK_HIGHER_ORDER_TETRAHEDRON: 64,
  VTK_HIGHER_ORDER_WEDGE: 65,
  VTK_HIGHER_ORDER_PYRAMID: 66,
  VTK_HIGHER_ORDER_HEXAHEDRON: 67,
  VTK_LAGRANGE_CURVE: 68,
  VTK_LAGRANGE_TRIANGLE: 69,
  VTK_LAGRANGE_QUADRILATERAL: 70,
  VTK_LAGRANGE_TETRAHEDRON: 71,
  VTK_LAGRANGE_HEXAHEDRON: 72,
  VTK_LAGRANGE_WEDGE: 73,
  VTK_LAGRANGE_PYRAMID: 74,
  VTK_NUMBER_OF_CELL_TYPES: 75
};
var CellTypesStrings = ["vtkEmptyCell", "vtkVertex", "vtkPolyVertex", "vtkLine", "vtkPolyLine", "vtkTriangle", "vtkTriangleStrip", "vtkPolygon", "vtkPixel", "vtkQuad", "vtkTetra", "vtkVoxel", "vtkHexahedron", "vtkWedge", "vtkPyramid", "vtkPentagonalPrism", "vtkHexagonalPrism", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkQuadraticEdge", "vtkQuadraticTriangle", "vtkQuadraticQuad", "vtkQuadraticTetra", "vtkQuadraticHexahedron", "vtkQuadraticWedge", "vtkQuadraticPyramid", "vtkBiQuadraticQuad", "vtkTriQuadraticHexahedron", "vtkQuadraticLinearQuad", "vtkQuadraticLinearWedge", "vtkBiQuadraticQuadraticWedge", "vtkBiQuadraticQuadraticHexahedron", "vtkBiQuadraticTriangle", "vtkCubicLine", "vtkQuadraticPolygon", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkConvexPointSet", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkParametricCurve", "vtkParametricSurface", "vtkParametricTriSurface", "vtkParametricQuadSurface", "vtkParametricTetraRegion", "vtkParametricHexRegion", "UnknownClass", "UnknownClass", "UnknownClass", "vtkHigherOrderEdge", "vtkHigherOrderTriangle", "vtkHigherOrderQuad", "vtkHigherOrderPolygon", "vtkHigherOrderTetrahedron", "vtkHigherOrderWedge", "vtkHigherOrderPyramid", "vtkHigherOrderHexahedron"];

// node_modules/@kitware/vtk.js/Common/DataModel/CellTypes.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function getClassNameFromTypeId(typeId) {
  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : "UnknownClass";
}
function getTypeIdFromClassName(cellTypeString) {
  return CellTypesStrings.findIndex(cellTypeString);
}
function isLinear(type) {
  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;
}
function hasSubCells(cellType) {
  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;
}
var STATIC2 = {
  getClassNameFromTypeId,
  getTypeIdFromClassName,
  isLinear,
  hasSubCells
};
function vtkCellTypes(publicAPI, model) {
  model.classHierarchy.push("vtkCellTypes");
  publicAPI.allocate = function() {
    var sz = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 512;
    var ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    model.size = sz > 0 ? sz : 1;
    model.extend = ext > 0 ? ext : 1;
    model.maxId = -1;
    model.typeArray = new Uint8Array(sz);
    model.locationArray = new Uint32Array(sz);
  };
  publicAPI.insertCell = function(cellId, type, loc) {
    model.typeArray[cellId] = type;
    model.locationArray[cellId] = loc;
    if (cellId > model.maxId) {
      model.maxId = cellId;
    }
  };
  publicAPI.insertNextCell = function(type, loc) {
    publicAPI.insertCell(++model.maxId, type, loc);
    return model.maxId;
  };
  publicAPI.setCellTypes = function(ncells, cellTypes, cellLocations) {
    model.size = ncells;
    model.typeArray = cellTypes;
    model.locationArray = cellLocations;
    model.maxId = ncells - 1;
  };
  publicAPI.getCellLocation = function(cellId) {
    return model.locationArray[cellId];
  };
  publicAPI.deleteCell = function(cellId) {
    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;
  };
  publicAPI.getNumberOfTypes = function() {
    return model.maxId + 1;
  };
  publicAPI.isType = function(type) {
    var numTypes = publicAPI.getNumberOfTypes();
    for (var i = 0; i < numTypes; ++i) {
      if (type === publicAPI.getCellType(i)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.insertNextType = function(type) {
    return publicAPI.insertNextCell(type, -1);
  };
  publicAPI.getCellType = function(cellId) {
    return model.typeArray[cellId];
  };
  publicAPI.reset = function() {
    model.maxId = -1;
  };
  publicAPI.deepCopy = function(src) {
    publicAPI.allocate(src.getSize(), src.getExtend());
    model.typeArray.set(src.getTypeArray());
    model.locationArray.set(src.getLocationArray());
    model.maxId = src.getMaxId();
  };
}
var DEFAULT_VALUES4 = {
  size: 0,
  maxId: -1,
  extend: 1e3
};
function extend5(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["size", "maxId", "extend"]);
  macro.getArray(publicAPI, model, ["typeArray", "locationArray"]);
  vtkCellTypes(publicAPI, model);
}
var newInstance5 = macro.newInstance(extend5, "vtkCellTypes");
var vtkCellTypes$1 = _objectSpread2({
  newInstance: newInstance5,
  extend: extend5
}, STATIC2);

// node_modules/@kitware/vtk.js/Common/DataModel/Line/Constants.js
var IntersectionState = {
  NO_INTERSECTION: 0,
  YES_INTERSECTION: 1,
  ON_LINE: 2
};
var Constants = {
  IntersectionState
};

// node_modules/@kitware/vtk.js/Common/DataModel/Line.js
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var IntersectionState2 = Constants.IntersectionState;
function distanceToLine(x, p1, p2) {
  var closestPoint = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var outObj = {
    t: Number.MIN_VALUE,
    distance: 0
  };
  var p21 = [];
  var closest;
  p21[0] = p2[0] - p1[0];
  p21[1] = p2[1] - p1[1];
  p21[2] = p2[2] - p1[2];
  var num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);
  var denom = dot(p21, p21);
  var tolerance = 1e-5 * num;
  if (denom !== 0) {
    outObj.t = num / denom;
  }
  if (tolerance < 0) {
    tolerance = -tolerance;
  }
  if (-tolerance < denom && denom < tolerance) {
    closest = p1;
  } else if (denom <= 0 || outObj.t < 0) {
    closest = p1;
  } else if (outObj.t > 1) {
    closest = p2;
  } else {
    closest = p21;
    p21[0] = p1[0] + outObj.t * p21[0];
    p21[1] = p1[1] + outObj.t * p21[1];
    p21[2] = p1[2] + outObj.t * p21[2];
  }
  if (closestPoint) {
    closestPoint[0] = closest[0];
    closestPoint[1] = closest[1];
    closestPoint[2] = closest[2];
  }
  outObj.distance = distance2BetweenPoints(closest, x);
  return outObj;
}
function intersection(a1, a2, b1, b2, u, v) {
  var a21 = [];
  var b21 = [];
  var b1a1 = [];
  u[0] = 0;
  v[0] = 0;
  subtract(a2, a1, a21);
  subtract(b2, b1, b21);
  subtract(b1, a1, b1a1);
  var A = [dot(a21, a21), -dot(a21, b21), -dot(a21, b21), dot(b21, b21)];
  var c = [];
  c[0] = dot(a21, b1a1);
  c[1] = -dot(b21, b1a1);
  if (solveLinearSystem(A, c, 2) === 0) {
    var minDist = Number.MAX_VALUE;
    var p = [a1, a2, b1, b2];
    var l1 = [b1, b1, a1, a1];
    var l2 = [b2, b2, a2, a2];
    var uv1 = [v[0], v[0], u[0], u[0]];
    var uv2 = [u[0], u[0], v[0], v[0]];
    var obj;
    for (var i = 0; i < 4; i++) {
      obj = distanceToLine(p[i], l1[i], l2[i]);
      if (obj.distance < minDist) {
        minDist = obj.distance;
        uv1[i] = obj.t;
        uv2[i] = i % 2;
      }
    }
    return IntersectionState2.ON_LINE;
  }
  u[0] = c[0];
  v[0] = c[1];
  if (u[0] >= 0 && u[0] <= 1 && v[0] >= 0 && v[0] <= 1) {
    return IntersectionState2.YES_INTERSECTION;
  }
  return IntersectionState2.NO_INTERSECTION;
}
var STATIC3 = {
  distanceToLine,
  intersection
};
function vtkLine(publicAPI, model) {
  model.classHierarchy.push("vtkLine");
  function isBetweenPoints(t) {
    return t >= 0 && t <= 1;
  }
  publicAPI.getCellDimension = function() {
    return 1;
  };
  publicAPI.intersectWithLine = function(p1, p2, tol, x, pcoords) {
    var outObj = {
      intersect: 0,
      t: Number.MAX_VALUE,
      subId: 0,
      betweenPoints: null
    };
    pcoords[1] = 0;
    pcoords[2] = 0;
    var projXYZ = [];
    var a1 = [];
    var a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);
    var u = [];
    var v = [];
    var intersect = intersection(p1, p2, a1, a2, u, v);
    outObj.t = u[0];
    outObj.betweenPoints = isBetweenPoints(outObj.t);
    pcoords[0] = v[0];
    if (intersect === IntersectionState2.YES_INTERSECTION) {
      for (var i = 0; i < 3; i++) {
        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);
      }
      if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {
        outObj.intersect = 1;
        return outObj;
      }
    } else {
      var outDistance;
      if (outObj.t < 0) {
        outDistance = distanceToLine(p1, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 0;
          outObj.intersect = 1;
          outObj.betweenPoints = true;
          return outObj;
        }
        return outObj;
      }
      if (outObj.t > 1) {
        outDistance = distanceToLine(p2, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 1;
          outObj.intersect = 1;
          outObj.betweenPoints = true;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] < 0) {
        pcoords[0] = 0;
        outDistance = distanceToLine(a1, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] > 1) {
        pcoords[0] = 1;
        outDistance = distanceToLine(a2, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
    }
    return outObj;
  };
  publicAPI.evaluateLocation = function(pcoords, x, weights) {
    var a1 = [];
    var a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);
    for (var i = 0; i < 3; i++) {
      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
    }
    weights[0] = 1 - pcoords[0];
    weights[1] = pcoords[0];
  };
}
var DEFAULT_VALUES5 = {};
function extend6(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  vtkLine(publicAPI, model);
}
var newInstance6 = macro.newInstance(extend6, "vtkLine");
var vtkLine$1 = _objectSpread3(_objectSpread3({
  newInstance: newInstance6,
  extend: extend6
}, STATIC3), Constants);

// node_modules/@kitware/vtk.js/Common/DataModel/PointSet.js
function vtkPointSet(publicAPI, model) {
  model.classHierarchy.push("vtkPointSet");
  if (!model.points) {
    model.points = vtkPoints$1.newInstance();
  } else {
    model.points = vtk(model.points);
  }
  publicAPI.getNumberOfPoints = function() {
    return model.points.getNumberOfPoints();
  };
  publicAPI.getBounds = function() {
    return model.points.getBounds();
  };
  publicAPI.computeBounds = function() {
    publicAPI.getBounds();
  };
  var superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    var debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    model.points = vtkPoints$1.newInstance();
    model.points.shallowCopy(other.getPoints());
  };
}
var DEFAULT_VALUES6 = {};
function extend7(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  vtkDataSet$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["points"]);
  vtkPointSet(publicAPI, model);
}
var newInstance7 = macro.newInstance(extend7, "vtkPointSet");
var vtkPointSet$1 = {
  newInstance: newInstance7,
  extend: extend7
};

// node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys4(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function computeNormalDirection(v1, v2, v3, n) {
  var ax = v3[0] - v2[0];
  var ay = v3[1] - v2[1];
  var az = v3[2] - v2[2];
  var bx = v1[0] - v2[0];
  var by = v1[1] - v2[1];
  var bz = v1[2] - v2[2];
  n[0] = ay * bz - az * by;
  n[1] = az * bx - ax * bz;
  n[2] = ax * by - ay * bx;
}
function computeNormal(v1, v2, v3, n) {
  computeNormalDirection(v1, v2, v3, n);
  var length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
  if (length !== 0) {
    n[0] /= length;
    n[1] /= length;
    n[2] /= length;
  }
}
function intersectWithTriangle(p1, q1, r1, p2, q2, r2) {
  var tolerance = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1e-6;
  var coplanar = false;
  var pt1 = [];
  var pt2 = [];
  var surfaceId = [];
  var n1 = [];
  var n2 = [];
  computeNormal(p1, q1, r1, n1);
  computeNormal(p2, q2, r2, n2);
  var s1 = -dot(n1, p1);
  var s2 = -dot(n2, p2);
  var dist1 = [dot(n2, p1) + s2, dot(n2, q1) + s2, dot(n2, r1) + s2];
  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  var dist2 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1];
  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {
    coplanar = true;
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  var pts1 = [p1, q1, r1];
  var pts2 = [p2, q2, r2];
  var n1n2 = dot(n1, n2);
  var a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1);
  var b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1);
  var p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];
  var v = cross(n1, n2, []);
  normalize(v);
  var index1 = 0;
  var index2 = 0;
  var t1 = [];
  var t2 = [];
  var ts1 = 50;
  var ts2 = 50;
  for (var i = 0; i < 3; i++) {
    var id1 = i;
    var id2 = (i + 1) % 3;
    var val1 = vtkPlane$1.intersectWithLine(pts1[id1], pts1[id2], p2, n2);
    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {
      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {
        ts1 = index1;
      }
      t1[index1++] = dot(val1.x, v) - dot(p, v);
    }
    var val2 = vtkPlane$1.intersectWithLine(pts2[id1], pts2[id2], p1, n1);
    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {
      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {
        ts2 = index2;
      }
      t2[index2++] = dot(val2.x, v) - dot(p, v);
    }
  }
  if (index1 > 2) {
    index1--;
    var t12 = t1[2];
    t1[2] = t1[ts1];
    t1[ts1] = t12;
  }
  if (index2 > 2) {
    index2--;
    var t22 = t2[2];
    t2[2] = t2[ts2];
    t2[ts2] = t22;
  }
  if (index1 !== 2 || index2 !== 2) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t1[0] > t1[1]) {
    var t11 = t1[1];
    t1[1] = t1[0];
    t1[0] = t11;
  }
  if (t2[0] > t2[1]) {
    var t21 = t2[1];
    t2[1] = t2[0];
    t2[0] = t21;
  }
  var tt1;
  var tt2;
  if (t1[1] < t2[0] || t2[1] < t1[0]) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t1[0] < t2[0]) {
    if (t1[1] < t2[1]) {
      surfaceId[0] = 2;
      surfaceId[1] = 1;
      tt1 = t2[0];
      tt2 = t1[1];
    } else {
      surfaceId[0] = 2;
      surfaceId[1] = 2;
      tt1 = t2[0];
      tt2 = t2[1];
    }
  } else if (t1[1] < t2[1]) {
    surfaceId[0] = 1;
    surfaceId[1] = 1;
    tt1 = t1[0];
    tt2 = t1[1];
  } else {
    surfaceId[0] = 1;
    surfaceId[1] = 2;
    tt1 = t1[0];
    tt2 = t2[1];
  }
  multiplyAccumulate(p, v, tt1, pt1);
  multiplyAccumulate(p, v, tt2, pt2);
  return {
    intersect: true,
    coplanar,
    pt1,
    pt2,
    surfaceId
  };
}
var STATIC4 = {
  computeNormalDirection,
  computeNormal,
  intersectWithTriangle
};
function vtkTriangle(publicAPI, model) {
  model.classHierarchy.push("vtkTriangle");
  publicAPI.getCellDimension = function() {
    return 2;
  };
  publicAPI.intersectWithLine = function(p1, p2, tol, x, pcoords) {
    var outObj = {
      subId: 0,
      t: Number.MAX_VALUE,
      intersect: 0,
      betweenPoints: false
    };
    pcoords[2] = 0;
    var closestPoint = [];
    var tol2 = tol * tol;
    var pt1 = [];
    var pt2 = [];
    var pt3 = [];
    model.points.getPoint(0, pt1);
    model.points.getPoint(1, pt2);
    model.points.getPoint(2, pt3);
    var n = [];
    var weights = [];
    computeNormal(pt1, pt2, pt3, n);
    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {
      var plane = vtkPlane$1.intersectWithLine(p1, p2, pt1, n);
      outObj.betweenPoints = plane.betweenPoints;
      outObj.t = plane.t;
      x[0] = plane.x[0];
      x[1] = plane.x[1];
      x[2] = plane.x[2];
      if (!plane.intersection) {
        pcoords[0] = 0;
        pcoords[1] = 0;
        outObj.intersect = 0;
        return outObj;
      }
      var inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);
      if (inside.evaluation >= 0) {
        if (inside.dist2 <= tol2) {
          outObj.intersect = 1;
          return outObj;
        }
        outObj.intersect = inside.evaluation;
        return outObj;
      }
    }
    var dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);
    var dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);
    var dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);
    if (!model.line) {
      model.line = vtkLine$1.newInstance();
    }
    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {
      model.line.getPoints().setPoint(0, pt1);
      model.line.getPoints().setPoint(1, pt2);
    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {
      model.line.getPoints().setPoint(0, pt2);
      model.line.getPoints().setPoint(1, pt3);
    } else {
      model.line.getPoints().setPoint(0, pt3);
      model.line.getPoints().setPoint(1, pt1);
    }
    var intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);
    outObj.betweenPoints = intersectLine.betweenPoints;
    outObj.t = intersectLine.t;
    if (intersectLine.intersect) {
      var pt3Pt1 = [];
      var pt3Pt2 = [];
      var pt3X = [];
      for (var i = 0; i < 3; i++) {
        pt3Pt1[i] = pt1[i] - pt3[i];
        pt3Pt2[i] = pt2[i] - pt3[i];
        pt3X[i] = x[i] - pt3[i];
      }
      pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;
      pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;
      outObj.intersect = 1;
      return outObj;
    }
    pcoords[0] = 0;
    pcoords[1] = 0;
    outObj.intersect = 0;
    return outObj;
  };
  publicAPI.evaluatePosition = function(x, closestPoint, pcoords, weights) {
    var outObj = {
      subId: 0,
      dist2: 0,
      evaluation: -1
    };
    var i;
    var j;
    var pt1 = [];
    var pt2 = [];
    var pt3 = [];
    var n = [];
    var fabsn;
    var rhs = [];
    var c1 = [];
    var c2 = [];
    var det = 0;
    var idx = 0;
    var indices = [];
    var dist2Point;
    var dist2Line1;
    var dist2Line2;
    var closest = [];
    var closestPoint1 = [];
    var closestPoint2 = [];
    var cp = [];
    outObj.subId = 0;
    pcoords[2] = 0;
    model.points.getPoint(1, pt1);
    model.points.getPoint(2, pt2);
    model.points.getPoint(0, pt3);
    computeNormalDirection(pt1, pt2, pt3, n);
    vtkPlane$1.generalizedProjectPoint(x, pt1, n, cp);
    var maxComponent = 0;
    for (i = 0; i < 3; i++) {
      if (n[i] < 0) {
        fabsn = -n[i];
      } else {
        fabsn = n[i];
      }
      if (fabsn > maxComponent) {
        maxComponent = fabsn;
        idx = i;
      }
    }
    for (j = 0, i = 0; i < 3; i++) {
      if (i !== idx) {
        indices[j++] = i;
      }
    }
    for (i = 0; i < 2; i++) {
      rhs[i] = cp[indices[i]] - pt3[indices[i]];
      c1[i] = pt1[indices[i]] - pt3[indices[i]];
      c2[i] = pt2[indices[i]] - pt3[indices[i]];
    }
    det = determinant2x2(c1, c2);
    if (det === 0) {
      pcoords[0] = 0;
      pcoords[1] = 0;
      outObj.evaluation = -1;
      return outObj;
    }
    pcoords[0] = determinant2x2(rhs, c2) / det;
    pcoords[1] = determinant2x2(c1, rhs) / det;
    weights[0] = 1 - (pcoords[0] + pcoords[1]);
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
    if (weights[0] >= 0 && weights[0] <= 1 && weights[1] >= 0 && weights[1] <= 1 && weights[2] >= 0 && weights[2] <= 1) {
      if (closestPoint) {
        outObj.dist2 = distance2BetweenPoints(cp, x);
        closestPoint[0] = cp[0];
        closestPoint[1] = cp[1];
        closestPoint[2] = cp[2];
      }
      outObj.evaluation = 1;
    } else {
      var t;
      if (closestPoint) {
        if (weights[1] < 0 && weights[2] < 0) {
          dist2Point = distance2BetweenPoints(x, pt3);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt3, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt3;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[2] < 0 && weights[0] < 0) {
          dist2Point = distance2BetweenPoints(x, pt1);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt1;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[1] < 0 && weights[0] < 0) {
          dist2Point = distance2BetweenPoints(x, pt2);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt2, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt2;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[0] < 0) {
          var lineDistance = vtkLine$1.distanceToLine(x, pt1, pt2, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[1] < 0) {
          var _lineDistance = vtkLine$1.distanceToLine(x, pt2, pt3, closestPoint);
          outObj.dist2 = _lineDistance.distance;
        } else if (weights[2] < 0) {
          var _lineDistance2 = vtkLine$1.distanceToLine(x, pt1, pt3, closestPoint);
          outObj.dist2 = _lineDistance2.distance;
        }
      }
      outObj.evaluation = 0;
    }
    return outObj;
  };
  publicAPI.evaluateLocation = function(pcoords, x, weights) {
    var p0 = [];
    var p1 = [];
    var p2 = [];
    model.points.getPoint(0, p0);
    model.points.getPoint(1, p1);
    model.points.getPoint(2, p2);
    var u3 = 1 - pcoords[0] - pcoords[1];
    for (var i = 0; i < 3; i++) {
      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];
    }
    weights[0] = u3;
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
  };
  publicAPI.getParametricDistance = function(pcoords) {
    var pDist;
    var pDistMax = 0;
    var pc = [];
    pc[0] = pcoords[0];
    pc[1] = pcoords[1];
    pc[2] = 1 - pcoords[0] - pcoords[1];
    for (var i = 0; i < 3; i++) {
      if (pc[i] < 0) {
        pDist = -pc[i];
      } else if (pc[i] > 1) {
        pDist = pc[i] - 1;
      } else {
        pDist = 0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
}
var DEFAULT_VALUES7 = {};
function extend8(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES7, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  vtkTriangle(publicAPI, model);
}
var newInstance8 = macro.newInstance(extend8, "vtkTriangle");
var vtkTriangle$1 = _objectSpread4({
  newInstance: newInstance8,
  extend: extend8
}, STATIC4);

// node_modules/@kitware/vtk.js/Common/DataModel/PolyData/Constants.js
var POLYDATA_FIELDS = ["verts", "lines", "polys", "strips"];

// node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js
var _CELL_FACTORY;
var vtkWarningMacro = macro.vtkWarningMacro;
var CELL_FACTORY = (_CELL_FACTORY = {}, _defineProperty(_CELL_FACTORY, CellType.VTK_LINE, vtkLine$1), _defineProperty(_CELL_FACTORY, CellType.VTK_POLY_LINE, vtkLine$1), _defineProperty(_CELL_FACTORY, CellType.VTK_TRIANGLE, vtkTriangle$1), _CELL_FACTORY);
function vtkPolyData(publicAPI, model) {
  model.classHierarchy.push("vtkPolyData");
  function camelize(str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w)/g, function(letter) {
      return letter.toUpperCase();
    }).replace(/\s+/g, "");
  }
  POLYDATA_FIELDS.forEach(function(type) {
    publicAPI["getNumberOf".concat(camelize(type))] = function() {
      return model[type].getNumberOfCells();
    };
    if (!model[type]) {
      model[type] = vtkCellArray$1.newInstance();
    } else {
      model[type] = vtk(model[type]);
    }
  });
  publicAPI.getNumberOfCells = function() {
    return POLYDATA_FIELDS.reduce(function(num, cellType) {
      return num + model[cellType].getNumberOfCells();
    }, 0);
  };
  var superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    var debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    POLYDATA_FIELDS.forEach(function(type) {
      model[type] = vtkCellArray$1.newInstance();
      model[type].shallowCopy(other.getReferenceByName(type));
    });
  };
  publicAPI.buildCells = function() {
    var nVerts = publicAPI.getNumberOfVerts();
    var nLines = publicAPI.getNumberOfLines();
    var nPolys = publicAPI.getNumberOfPolys();
    var nStrips = publicAPI.getNumberOfStrips();
    var nCells = nVerts + nLines + nPolys + nStrips;
    var types = new Uint8Array(nCells);
    var pTypes = types;
    var locs = new Uint32Array(nCells);
    var pLocs = locs;
    if (nVerts) {
      var nextCellPts = 0;
      model.verts.getCellSizes().forEach(function(numCellPts, index) {
        pLocs[index] = nextCellPts;
        pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nVerts);
      pTypes = pTypes.subarray(nVerts);
    }
    if (nLines) {
      var _nextCellPts = 0;
      model.lines.getCellSizes().forEach(function(numCellPts, index) {
        pLocs[index] = _nextCellPts;
        pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;
        if (numCellPts === 1) {
          vtkWarningMacro("Building VTK_LINE ", index, " with only one point, but VTK_LINE needs at least two points. Check the input.");
        }
        _nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nLines);
      pTypes = pTypes.subarray(nLines);
    }
    if (nPolys) {
      var _nextCellPts2 = 0;
      model.polys.getCellSizes().forEach(function(numCellPts, index) {
        pLocs[index] = _nextCellPts2;
        switch (numCellPts) {
          case 3:
            pTypes[index] = CellType.VTK_TRIANGLE;
            break;
          case 4:
            pTypes[index] = CellType.VTK_QUAD;
            break;
          default:
            pTypes[index] = CellType.VTK_POLYGON;
            break;
        }
        if (numCellPts < 3) {
          vtkWarningMacro("Building VTK_TRIANGLE ", index, " with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.");
        }
        _nextCellPts2 += numCellPts + 1;
      });
      pLocs += pLocs.subarray(nPolys);
      pTypes += pTypes.subarray(nPolys);
    }
    if (nStrips) {
      var _nextCellPts3 = 0;
      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);
      model.strips.getCellSizes().forEach(function(numCellPts, index) {
        pLocs[index] = _nextCellPts3;
        _nextCellPts3 += numCellPts + 1;
      });
    }
    model.cells = vtkCellTypes$1.newInstance();
    model.cells.setCellTypes(nCells, types, locs);
  };
  publicAPI.buildLinks = function() {
    var initialSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.cells === void 0) {
      publicAPI.buildCells();
    }
    model.links = vtkCellLinks$1.newInstance();
    if (initialSize > 0) {
      model.links.allocate(initialSize);
    } else {
      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());
    }
    model.links.buildLinks(publicAPI);
  };
  publicAPI.getCellType = function(cellId) {
    return model.cells.getCellType(cellId);
  };
  publicAPI.getCellPoints = function(cellId) {
    var cellType = publicAPI.getCellType(cellId);
    var cells = null;
    switch (cellType) {
      case CellType.VTK_VERTEX:
      case CellType.VTK_POLY_VERTEX:
        cells = model.verts;
        break;
      case CellType.VTK_LINE:
      case CellType.VTK_POLY_LINE:
        cells = model.lines;
        break;
      case CellType.VTK_TRIANGLE:
      case CellType.VTK_QUAD:
      case CellType.VTK_POLYGON:
        cells = model.polys;
        break;
      case CellType.VTK_TRIANGLE_STRIP:
        cells = model.strips;
        break;
      default:
        cells = null;
        return {
          type: 0,
          cellPointIds: null
        };
    }
    var loc = model.cells.getCellLocation(cellId);
    var cellPointIds = cells.getCell(loc);
    return {
      cellType,
      cellPointIds
    };
  };
  publicAPI.getPointCells = function(ptId) {
    return model.links.getCells(ptId);
  };
  publicAPI.getCellEdgeNeighbors = function(cellId, point1, point2) {
    var link1 = model.links.getLink(point1);
    var link2 = model.links.getLink(point2);
    return link1.cells.filter(function(cell) {
      return cell !== cellId && link2.cells.indexOf(cell) !== -1;
    });
  };
  publicAPI.getCell = function(cellId) {
    var cellHint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var cellInfo = publicAPI.getCellPoints(cellId);
    var cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();
    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);
    return cell;
  };
}
var DEFAULT_VALUES8 = {};
function extend9(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES8, initialValues);
  vtkPointSet$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["cells", "links"]);
  macro.setGet(publicAPI, model, ["verts", "lines", "polys", "strips"]);
  vtkPolyData(publicAPI, model);
}
var newInstance9 = macro.newInstance(extend9, "vtkPolyData");
var vtkPolyData$1 = {
  newInstance: newInstance9,
  extend: extend9
};

export {
  vtkPoints$1,
  vtkPolyData$1
};
//# sourceMappingURL=chunk-XT2DETPC.js.map
