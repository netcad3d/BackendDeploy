import {
  fromArrayBuffer
} from "./chunk-RUO4W2U5.js";
import {
  decompressSync,
  strFromU8,
  strToU8,
  unzipSync
} from "./chunk-PCBY7TQL.js";
import {
  Endian,
  registerType
} from "./chunk-2MWAGLL3.js";
import {
  DataTypeByteSize
} from "./chunk-SWDS6M4V.js";
import {
  macro
} from "./chunk-OTTIIP4A.js";
import "./chunk-HKWV5KNA.js";
import "./chunk-XL65WI7U.js";
import "./chunk-HUBM7RA2.js";

// node_modules/@kitware/vtk.js/IO/Core/DataAccessHelper/JSZipDataAccessHelper.js
var vtkErrorMacro = macro.vtkErrorMacro;
var vtkDebugMacro = macro.vtkDebugMacro;
function toMimeType(url) {
  var ext = url.split(".").pop().toLowerCase();
  if (ext === "jpg") {
    return "jpeg";
  }
  return ext;
}
function handleUint8Array(array, compression, done) {
  return function(uint8array) {
    array.buffer = new ArrayBuffer(uint8array.length);
    var view = new Uint8Array(array.buffer);
    view.set(uint8array);
    if (compression) {
      if (array.dataType === "string" || array.dataType === "JSON") {
        array.buffer = strFromU8(decompressSync(new Uint8Array(array.buffer)));
      } else {
        array.buffer = decompressSync(new Uint8Array(array.buffer)).buffer;
      }
    }
    if (array.ref.encode === "JSON") {
      array.values = JSON.parse(array.buffer);
    } else {
      if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {
        vtkDebugMacro("Swap bytes of ".concat(array.name));
        Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);
      }
      array.values = macro.newTypedArray(array.dataType, array.buffer);
    }
    if (array.values.length !== array.size) {
      vtkErrorMacro("Error in FetchArray: ".concat(array.name, " does not have the proper array size. Got ").concat(array.values.length, ", instead of ").concat(array.size));
    }
    done();
  };
}
function handleString(array, compression, done) {
  return function(string) {
    if (compression) {
      array.values = JSON.parse(strFromU8(decompressSync(string)));
    } else {
      array.values = JSON.parse(string);
    }
    done();
  };
}
function removeLeadingSlash(str) {
  return str[0] === "/" ? str.substr(1) : str;
}
function normalizePath(str) {
  return new URL(str, "http://any").pathname;
}
function cleanUpPath(str) {
  return removeLeadingSlash(normalizePath(str));
}
function unpack(zipContent) {
  return new Promise(function(resolve, reject) {
    if (typeof zipContent === "string") {
      resolve(strToU8(zipContent));
    } else if (zipContent instanceof Blob) {
      resolve(zipContent.arrayBuffer().then(function(ab) {
        return new Uint8Array(ab);
      }));
    } else if (zipContent instanceof ArrayBuffer) {
      resolve(new Uint8Array(zipContent));
    } else if ((zipContent === null || zipContent === void 0 ? void 0 : zipContent.buffer) instanceof ArrayBuffer) {
      resolve(new Uint8Array(zipContent.buffer));
    } else {
      reject(new Error("Invalid datatype to unpack."));
    }
  });
}
function create(createOptions) {
  var ready = false;
  var requestCount = 0;
  var decompressedFiles = null;
  var fullRootPath = "";
  unpack(createOptions.zipContent).then(function(zipFileData) {
    decompressedFiles = unzipSync(zipFileData);
    ready = true;
    var metaFiles = [];
    Object.keys(decompressedFiles).forEach(function(relativePath) {
      if (relativePath.endsWith("index.json")) {
        metaFiles.push(relativePath);
      }
    });
    metaFiles.sort(function(a, b) {
      return a.length - b.length;
    });
    fullRootPath = metaFiles[0].replace(/index\.json$/, "");
    if (createOptions.callback) {
      createOptions.callback(decompressedFiles);
    }
  });
  return {
    fetchArray: function fetchArray(instance, baseURL, array) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return new Promise(function(resolve, reject) {
        if (!ready) {
          vtkErrorMacro("ERROR!!! zip not ready...");
        }
        var url = cleanUpPath([baseURL, array.ref.basepath, options.compression ? "".concat(array.ref.id, ".gz") : array.ref.id].join("/"));
        if (++requestCount === 1 && instance !== null && instance !== void 0 && instance.invokeBusy) {
          instance.invokeBusy(true);
        }
        function doneCleanUp() {
          delete array.ref;
          if (--requestCount === 0 && instance !== null && instance !== void 0 && instance.invokeBusy) {
            instance.invokeBusy(false);
          }
          if (instance !== null && instance !== void 0 && instance.modified) {
            instance.modified();
          }
          resolve(array);
        }
        var fileData = decompressedFiles["".concat(fullRootPath).concat(url)];
        if (array.dataType === "string" && !options.compression) {
          var handler = handleString(array, options.compression, doneCleanUp);
          handler(strFromU8(fileData));
        } else {
          var _handler = handleUint8Array(array, options.compression, doneCleanUp);
          _handler(fileData);
        }
      });
    },
    fetchJSON: function fetchJSON(instance, url) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var path = cleanUpPath(url);
      if (!ready) {
        vtkErrorMacro("ERROR!!! zip not ready...");
      }
      var fileData = decompressedFiles["".concat(fullRootPath).concat(path)];
      if (options.compression) {
        if (options.compression === "gz") {
          var str = strFromU8(decompressSync(fileData));
          return Promise.resolve(JSON.parse(str));
        }
        return Promise.reject(new Error("Invalid compression"));
      }
      return Promise.resolve(JSON.parse(strFromU8(fileData)));
    },
    fetchText: function fetchText(instance, url) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var path = cleanUpPath(url);
      if (!ready) {
        vtkErrorMacro("ERROR!!! zip not ready...");
      }
      var fileData = decompressedFiles["".concat(fullRootPath).concat(path)];
      if (options.compression) {
        if (options.compression === "gz") {
          return Promise.resolve(strFromU8(unzipSync(fileData)));
        }
        return Promise.reject(new Error("Invalid compression"));
      }
      return Promise.resolve(strFromU8(fileData));
    },
    fetchImage: function fetchImage(instance, url) {
      var path = cleanUpPath(url);
      if (!ready) {
        vtkErrorMacro("ERROR!!! zip not ready...");
      }
      var fileData = decompressedFiles["".concat(fullRootPath).concat(path)];
      return new Promise(function(resolve, reject) {
        var img = new Image();
        img.onload = function() {
          return resolve(img);
        };
        img.onerror = reject;
        var str = fromArrayBuffer(fileData.buffer);
        img.src = "data:image/".concat(toMimeType(path), ";base64,").concat(str);
      });
    },
    fetchBinary: function fetchBinary(instance, url) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var path = cleanUpPath(url);
      if (!ready) {
        vtkErrorMacro("ERROR!!! zip not ready...");
      }
      var fileData = decompressedFiles["".concat(fullRootPath).concat(path)];
      if (options.compression) {
        if (options.compression === "gz") {
          return Promise.resolve(decompressSync(fileData).buffer);
        }
        return Promise.reject(new Error("Invalid compression"));
      }
      return Promise.resolve(fileData.buffer);
    }
  };
}
var JSZipDataAccessHelper = {
  create
};
registerType("zip", function(options) {
  return JSZipDataAccessHelper.create(options);
});

// dep:@kitware_vtk__js_IO_Core_DataAccessHelper_JSZipDataAccessHelper
var kitware_vtk_js_IO_Core_DataAccessHelper_JSZipDataAccessHelper_default = JSZipDataAccessHelper;
export {
  kitware_vtk_js_IO_Core_DataAccessHelper_JSZipDataAccessHelper_default as default
};
//# sourceMappingURL=@kitware_vtk__js_IO_Core_DataAccessHelper_JSZipDataAccessHelper.js.map
