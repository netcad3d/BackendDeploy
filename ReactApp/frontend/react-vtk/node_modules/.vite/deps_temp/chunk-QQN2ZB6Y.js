import {
  vtkWebGPUTexture$1,
  vtkWebGPUTextureView$1
} from "./chunk-ECMUJBJB.js";
import {
  vtkOpenGLFramebuffer
} from "./chunk-XMTP2BGC.js";
import {
  BlendMode
} from "./chunk-CPX3F44X.js";
import {
  HalfFloat,
  vtkHelper,
  vtkOpenGLTexture$1,
  vtkShaderProgram$1,
  vtkVertexArrayObject,
  vtkViewNode$1,
  vtkViewNodeFactory,
  vtkWebGPUBuffer$1,
  vtkWebGPUBufferManager$1,
  vtkWebGPUFullScreenQuad$1,
  vtkWebGPUSampler$1,
  vtkWebGPUShaderCache$1,
  vtkWebGPUSimpleMapper$1,
  vtkWebGPUStorageBuffer$1,
  vtkWebGPUTypes,
  vtkWebGPUUniformBuffer$1,
  vtkWebGPUViewNodeFactory$1
} from "./chunk-WDDAGUM6.js";
import {
  registerViewConstructor
} from "./chunk-5C4CJZQ5.js";
import {
  Constants
} from "./chunk-DG5VRK2V.js";
import {
  vtkProperty$1
} from "./chunk-PIUKKK4M.js";
import {
  vtkPolyData$1
} from "./chunk-XT2DETPC.js";
import {
  vtkDataSet$1
} from "./chunk-Z2LVQNSU.js";
import {
  vtkDataArray$1
} from "./chunk-Z5OKWKLG.js";
import {
  VtkDataTypes
} from "./chunk-SWDS6M4V.js";
import {
  mat4_exports
} from "./chunk-GC37RKNO.js";
import {
  distance2BetweenPoints
} from "./chunk-FOWOP5PK.js";
import {
  _assertThisInitialized,
  _classCallCheck,
  _createClass,
  _get,
  _getPrototypeOf,
  _inherits,
  _possibleConstructorReturn,
  _toConsumableArray,
  _typeof,
  _wrapNativeSuper,
  get,
  macro,
  newInstance,
  obj,
  setGet
} from "./chunk-OTTIIP4A.js";
import {
  _defineProperty
} from "./chunk-HKWV5KNA.js";
import {
  _slicedToArray
} from "./chunk-XL65WI7U.js";
import {
  __commonJS,
  __toESM
} from "./chunk-HUBM7RA2.js";

// node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "node_modules/regenerator-runtime/runtime.js"(exports, module) {
    var runtime = function(exports2) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj2, key, value) {
        Object.defineProperty(obj2, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj2[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function(obj2, key, value) {
          return obj2[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        generator._invoke = makeInvokeMethod(innerFn, self2, context);
        return generator;
      }
      exports2.wrap = wrap;
      function tryCatch(fn, obj2, arg) {
        try {
          return { type: "normal", arg: fn.call(obj2, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      define2(Gp, "constructor", GeneratorFunctionPrototype);
      define2(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
      GeneratorFunction.displayName = define2(
        GeneratorFunctionPrototype,
        toStringTagSymbol,
        "GeneratorFunction"
      );
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports2.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports2.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define2(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports2.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
        }
        this._invoke = enqueue;
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports2.AsyncIterator = AsyncIterator;
      exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0)
          PromiseImpl = Promise;
        var iter = new AsyncIterator(
          wrap(innerFn, outerFn, self2, tryLocsList),
          PromiseImpl
        );
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (method === undefined2) {
          context.delegate = null;
          if (context.method === "throw") {
            if (delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined2;
              maybeInvokeDelegate(delegate, context);
              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }
            context.method = "throw";
            context.arg = new TypeError(
              "The iterator does not provide a 'throw' method"
            );
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define2(Gp, toStringTagSymbol, "Generator");
      define2(Gp, iteratorSymbol, function() {
        return this;
      });
      define2(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports2.keys = function(object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key2 = keys.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next2.value = iterable[i];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports2.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports2;
    }(
      typeof module === "object" ? module.exports : {}
    );
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    module.exports = require_runtime();
  }
});

// node_modules/spark-md5/spark-md5.js
var require_spark_md5 = __commonJS({
  "node_modules/spark-md5/spark-md5.js"(exports, module) {
    (function(factory) {
      if (typeof exports === "object") {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        var glob;
        try {
          glob = window;
        } catch (e) {
          glob = self;
        }
        glob.SparkMD5 = factory();
      }
    })(function(undefined2) {
      "use strict";
      var add32 = function(a, b) {
        return a + b & 4294967295;
      }, hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32(a << s | a >>> 32 - s, b);
      }
      function md5cycle(x, k) {
        var a = x[0], b = x[1], c = x[2], d = x[3];
        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
      }
      function md5blk(s) {
        var md5blks = [], i;
        for (i = 0; i < 64; i += 4) {
          md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
      }
      function md5blk_array(a) {
        var md5blks = [], i;
        for (i = 0; i < 64; i += 4) {
          md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
      }
      function md51(s) {
        var n = s.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
        for (i = 64; i <= n; i += 64) {
          md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
        }
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(state, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function md51_array(a) {
        var n = a.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
        for (i = 64; i <= n; i += 64) {
          md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }
        a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);
        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= a[i] << (i % 4 << 3);
        }
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(state, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function rhex(n) {
        var s = "", j;
        for (j = 0; j < 4; j += 1) {
          s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
        }
        return s;
      }
      function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
          x[i] = rhex(x[i]);
        }
        return x.join("");
      }
      if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") {
        add32 = function(x, y) {
          var lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        };
      }
      if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
        (function() {
          function clamp(val, length) {
            val = val | 0 || 0;
            if (val < 0) {
              return Math.max(val + length, 0);
            }
            return Math.min(val, length);
          }
          ArrayBuffer.prototype.slice = function(from, to) {
            var length = this.byteLength, begin = clamp(from, length), end = length, num, target, targetArray, sourceArray;
            if (to !== undefined2) {
              end = clamp(to, length);
            }
            if (begin > end) {
              return new ArrayBuffer(0);
            }
            num = end - begin;
            target = new ArrayBuffer(num);
            targetArray = new Uint8Array(target);
            sourceArray = new Uint8Array(this, begin, num);
            targetArray.set(sourceArray);
            return target;
          };
        })();
      }
      function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
          str = unescape(encodeURIComponent(str));
        }
        return str;
      }
      function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i;
        for (i = 0; i < length; i += 1) {
          arr[i] = str.charCodeAt(i);
        }
        return returnUInt8Array ? arr : buff;
      }
      function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
      }
      function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);
        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);
        return returnUInt8Array ? result : result.buffer;
      }
      function hexToBinaryString(hex2) {
        var bytes = [], length = hex2.length, x;
        for (x = 0; x < length - 1; x += 2) {
          bytes.push(parseInt(hex2.substr(x, 2), 16));
        }
        return String.fromCharCode.apply(String, bytes);
      }
      function SparkMD5() {
        this.reset();
      }
      SparkMD5.prototype.append = function(str) {
        this.appendBinary(toUtf8(str));
        return this;
      };
      SparkMD5.prototype.appendBinary = function(contents) {
        this._buff += contents;
        this._length += contents.length;
        var length = this._buff.length, i;
        for (i = 64; i <= length; i += 64) {
          md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }
        this._buff = this._buff.substring(i - 64);
        return this;
      };
      SparkMD5.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, i, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD5.prototype.reset = function() {
        this._buff = "";
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD5.prototype.getState = function() {
        return {
          buff: this._buff,
          length: this._length,
          hash: this._hash.slice()
        };
      };
      SparkMD5.prototype.setState = function(state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;
        return this;
      };
      SparkMD5.prototype.destroy = function() {
        delete this._hash;
        delete this._buff;
        delete this._length;
      };
      SparkMD5.prototype._finish = function(tail, length) {
        var i = length, tmp, lo, hi;
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(this._hash, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
      };
      SparkMD5.hash = function(str, raw) {
        return SparkMD5.hashBinary(toUtf8(str), raw);
      };
      SparkMD5.hashBinary = function(content, raw) {
        var hash = md51(content), ret = hex(hash);
        return raw ? hexToBinaryString(ret) : ret;
      };
      SparkMD5.ArrayBuffer = function() {
        this.reset();
      };
      SparkMD5.ArrayBuffer.prototype.append = function(arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i;
        this._length += arr.byteLength;
        for (i = 64; i <= length; i += 64) {
          md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }
        this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);
        return this;
      };
      SparkMD5.ArrayBuffer.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i, ret;
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= buff[i] << (i % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD5.ArrayBuffer.prototype.reset = function() {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD5.ArrayBuffer.prototype.getState = function() {
        var state = SparkMD5.prototype.getState.call(this);
        state.buff = arrayBuffer2Utf8Str(state.buff);
        return state;
      };
      SparkMD5.ArrayBuffer.prototype.setState = function(state) {
        state.buff = utf8Str2ArrayBuffer(state.buff, true);
        return SparkMD5.prototype.setState.call(this, state);
      };
      SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
      SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
      SparkMD5.ArrayBuffer.hash = function(arr, raw) {
        var hash = md51_array(new Uint8Array(arr)), ret = hex(hash);
        return raw ? hexToBinaryString(ret) : ret;
      };
      return SparkMD5;
    });
  }
});

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}

// node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow.js
var import_regenerator3 = __toESM(require_regenerator());

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderPass.js
function vtkRenderPass(publicAPI, model) {
  model.classHierarchy.push("vtkRenderPass");
  publicAPI.getOperation = function() {
    return model.currentOperation;
  };
  publicAPI.setCurrentOperation = function(val) {
    model.currentOperation = val;
    model.currentTraverseOperation = "traverse".concat(macro.capitalize(model.currentOperation));
  };
  publicAPI.getTraverseOperation = function() {
    return model.currentTraverseOperation;
  };
  publicAPI.traverse = function(viewNode) {
    var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (model.deleted) {
      return;
    }
    model.currentParent = parent;
    model.preDelegateOperations.forEach(function(val) {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
    model.delegates.forEach(function(val) {
      val.traverse(viewNode, publicAPI);
    });
    model.postDelegateOperations.forEach(function(val) {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
  };
}
var DEFAULT_VALUES = {
  delegates: [],
  currentOperation: null,
  preDelegateOperations: [],
  postDelegateOperations: [],
  currentParent: null
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["currentOperation"]);
  macro.setGet(publicAPI, model, ["delegates", "currentParent", "preDelegateOperations", "postDelegateOperations"]);
  vtkRenderPass(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend, "vtkRenderPass");
var vtkRenderPass$1 = {
  newInstance: newInstance2,
  extend
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/OrderIndependentTranslucentPass.js
var Representation = vtkProperty$1.Representation;
var vtkErrorMacro2 = macro.vtkErrorMacro;
function translucentShaderReplacement(shaders) {
  var substituteRes = vtkShaderProgram$1.substitute(shaders.Fragment, "//VTK::RenderPassFragmentShader::Impl", "\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ", false);
  shaders.Fragment = substituteRes.result;
}
var oitpFragTemplate = "//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n";
function vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass");
  publicAPI.createVertexBuffer = function() {
    var ptsArray = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1]);
    var tcoordArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
    var cellArray = new Uint16Array([4, 0, 1, 3, 2]);
    var points = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      values: ptsArray
    });
    points.setName("points");
    var tcoords = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcoordArray
    });
    tcoords.setName("tcoords");
    var cells = vtkDataArray$1.newInstance({
      numberOfComponents: 1,
      values: cellArray
    });
    model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
      points,
      tcoords,
      cellOffset: 0
    });
    model.VBOBuildTime.modified();
  };
  publicAPI.createFramebuffer = function(viewNode) {
    var _model$framebuffer;
    var size = viewNode.getSize();
    var gl = viewNode.getContext();
    model.framebuffer = vtkOpenGLFramebuffer.newInstance();
    model.framebuffer.setOpenGLRenderWindow(viewNode);
    (_model$framebuffer = model.framebuffer).create.apply(_model$framebuffer, _toConsumableArray(size));
    model.framebuffer.saveCurrentBindingsAndBuffers();
    model.framebuffer.bind();
    model.translucentRGBATexture = vtkOpenGLTexture$1.newInstance();
    model.translucentRGBATexture.setInternalFormat(gl.RGBA16F);
    model.translucentRGBATexture.setFormat(gl.RGBA);
    model.translucentRGBATexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRGBATexture.setOpenGLRenderWindow(viewNode);
    model.translucentRGBATexture.create2DFromRaw(size[0], size[1], 4, "Float32Array", null);
    model.translucentRTexture = vtkOpenGLTexture$1.newInstance();
    model.translucentRTexture.setInternalFormat(gl.R16F);
    model.translucentRTexture.setFormat(gl.RED);
    model.translucentRTexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRTexture.setOpenGLRenderWindow(viewNode);
    model.translucentRTexture.create2DFromRaw(size[0], size[1], 1, "Float32Array", null);
    model.translucentZTexture = vtkOpenGLTexture$1.newInstance();
    model.translucentZTexture.setOpenGLRenderWindow(viewNode);
    model.translucentZTexture.createDepthFromRaw(size[0], size[1], "Float32Array", null);
    model.framebuffer.setColorBuffer(model.translucentRGBATexture, 0);
    model.framebuffer.setColorBuffer(model.translucentRTexture, 1);
    model.framebuffer.setDepthBuffer(model.translucentZTexture);
  };
  publicAPI.createCopyShader = function(viewNode) {
    model.copyShader = viewNode.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec", "attribute vec4 vertexDC;", "attribute vec2 tcoordTC;", "varying vec2 tcoord;", "void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"), oitpFragTemplate, "");
  };
  publicAPI.createVBO = function(viewNode) {
    var gl = viewNode.getContext();
    model.tris.setOpenGLRenderWindow(viewNode);
    publicAPI.createVertexBuffer();
    var program = model.copyShader;
    model.tris.getCABO().bind();
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "vertexDC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 3, gl.FALSE)) {
      vtkErrorMacro2("Error setting vertexDC in copy shader VAO.");
    }
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "tcoordTC", model.tris.getCABO().getTCoordOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 2, gl.FALSE)) {
      vtkErrorMacro2("Error setting vertexDC in copy shader VAO.");
    }
  };
  publicAPI.traverse = function(viewNode, renNode, forwardPass) {
    if (model.deleted) {
      return;
    }
    var size = viewNode.getSize();
    var gl = viewNode.getContext();
    model._supported = false;
    if (renNode.getSelector() || !gl || !viewNode.getWebgl2() || !gl.getExtension("EXT_color_buffer_half_float") && !gl.getExtension("EXT_color_buffer_float")) {
      publicAPI.setCurrentOperation("translucentPass");
      renNode.traverse(publicAPI);
      return;
    }
    model._supported = true;
    if (model.framebuffer === null) {
      publicAPI.createFramebuffer(viewNode);
    } else {
      var fbSize = model.framebuffer.getSize();
      if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
        model.framebuffer.releaseGraphicsResources();
        model.translucentRGBATexture.releaseGraphicsResources(viewNode);
        model.translucentRTexture.releaseGraphicsResources(viewNode);
        model.translucentZTexture.releaseGraphicsResources(viewNode);
        publicAPI.createFramebuffer(viewNode);
      } else {
        model.framebuffer.saveCurrentBindingsAndBuffers();
        model.framebuffer.bind();
      }
    }
    gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
    gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 0]);
    gl.clearBufferfv(gl.DEPTH, 0, [1]);
    gl.colorMask(false, false, false, false);
    if (forwardPass.getOpaqueActorCount() > 0) {
      forwardPass.setCurrentOperation("opaquePass");
      renNode.traverse(forwardPass);
    }
    gl.colorMask(true, true, true, true);
    gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
    gl.viewport(0, 0, size[0], size[1]);
    gl.scissor(0, 0, size[0], size[1]);
    gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 1]);
    gl.clearBufferfv(gl.COLOR, 1, [0, 0, 0, 0]);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
    publicAPI.setCurrentOperation("translucentPass");
    renNode.traverse(publicAPI);
    gl.drawBuffers([gl.NONE]);
    model.framebuffer.restorePreviousBindingsAndBuffers();
    if (model.copyShader === null) {
      publicAPI.createCopyShader(viewNode);
    } else {
      viewNode.getShaderCache().readyShaderProgram(model.copyShader);
    }
    if (!model.copyVAO) {
      model.copyVAO = vtkVertexArrayObject.newInstance();
      model.copyVAO.setOpenGLRenderWindow(viewNode);
    }
    model.copyVAO.bind();
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime()) {
      publicAPI.createVBO(viewNode);
    }
    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthMask(false);
    gl.depthFunc(gl.ALWAYS);
    gl.viewport(0, 0, size[0], size[1]);
    gl.scissor(0, 0, size[0], size[1]);
    model.translucentRGBATexture.activate();
    model.copyShader.setUniformi("translucentRGBATexture", model.translucentRGBATexture.getTextureUnit());
    model.translucentRTexture.activate();
    model.copyShader.setUniformi("translucentRTexture", model.translucentRTexture.getTextureUnit());
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    gl.depthMask(true);
    gl.depthFunc(gl.LEQUAL);
    model.translucentRGBATexture.deactivate();
    model.translucentRTexture.deactivate();
  };
  publicAPI.getShaderReplacement = function() {
    if (model._supported) {
      return translucentShaderReplacement;
    }
    return null;
  };
  publicAPI.releaseGraphicsResources = function(viewNode) {
    if (model.framebuffer) {
      model.framebuffer.releaseGraphicsResources(viewNode);
      model.framebuffer = null;
    }
    if (model.translucentRGBATexture) {
      model.translucentRGBATexture.releaseGraphicsResources(viewNode);
      model.translucentRGBATexture = null;
    }
    if (model.translucentRTexture) {
      model.translucentRTexture.releaseGraphicsResources(viewNode);
      model.translucentRTexture = null;
    }
    if (model.translucentZTexture) {
      model.translucentZTexture.releaseGraphicsResources(viewNode);
      model.translucentZTexture = null;
    }
    if (model.copyVAO) {
      model.copyVAO.releaseGraphicsResources(viewNode);
      model.copyVAO = null;
    }
    if (model.copyShader) {
      model.copyShader.releaseGraphicsResources(viewNode);
      model.copyShader = null;
    }
    if (model.tris) {
      model.tris.releaseGraphicsResources(viewNode);
      model.tris = null;
    }
    publicAPI.modified();
  };
}
var DEFAULT_VALUES2 = {
  framebuffer: null,
  copyShader: null,
  tris: null
};
function extend2(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  macro.obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = vtkHelper.newInstance();
  macro.get(publicAPI, model, ["framebuffer"]);
  vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend2, "vtkOpenGLOrderIndependentTranslucentPass");
var vtkOpenGLOrderIndependentTranslucentPass$1 = {
  newInstance: newInstance3,
  extend: extend2
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ForwardPass.js
function vtkForwardPass(publicAPI, model) {
  model.classHierarchy.push("vtkForwardPass");
  publicAPI.traverse = function(viewNode) {
    var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (model.deleted) {
      return;
    }
    model.currentParent = parent;
    publicAPI.setCurrentOperation("buildPass");
    viewNode.traverse(publicAPI);
    var numlayers = viewNode.getRenderable().getNumberOfLayers();
    var renderers = viewNode.getChildren();
    for (var i = 0; i < numlayers; i++) {
      for (var index = 0; index < renderers.length; index++) {
        var renNode = renderers[index];
        var ren = viewNode.getRenderable().getRenderers()[index];
        if (ren.getDraw() && ren.getLayer() === i) {
          model.opaqueActorCount = 0;
          model.translucentActorCount = 0;
          model.volumeCount = 0;
          model.overlayActorCount = 0;
          publicAPI.setCurrentOperation("queryPass");
          renNode.traverse(publicAPI);
          if (model.opaqueActorCount > 0 && model.volumeCount > 0 || model.depthRequested) {
            var size = viewNode.getFramebufferSize();
            if (model.framebuffer === null) {
              model.framebuffer = vtkOpenGLFramebuffer.newInstance();
            }
            model.framebuffer.setOpenGLRenderWindow(viewNode);
            model.framebuffer.saveCurrentBindingsAndBuffers();
            var fbSize = model.framebuffer.getSize();
            if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
              model.framebuffer.create(size[0], size[1]);
              model.framebuffer.populateFramebuffer();
            }
            model.framebuffer.bind();
            publicAPI.setCurrentOperation("opaqueZBufferPass");
            renNode.traverse(publicAPI);
            model.framebuffer.restorePreviousBindingsAndBuffers();
            model.depthRequested = false;
          }
          publicAPI.setCurrentOperation("cameraPass");
          renNode.traverse(publicAPI);
          if (model.opaqueActorCount > 0) {
            publicAPI.setCurrentOperation("opaquePass");
            renNode.traverse(publicAPI);
          }
          if (model.translucentActorCount > 0) {
            if (!model.translucentPass) {
              model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass$1.newInstance();
            }
            model.translucentPass.traverse(viewNode, renNode, publicAPI);
          }
          if (model.volumeCount > 0) {
            publicAPI.setCurrentOperation("volumePass");
            renNode.traverse(publicAPI);
          }
          if (model.overlayActorCount > 0) {
            publicAPI.setCurrentOperation("overlayPass");
            renNode.traverse(publicAPI);
          }
        }
      }
    }
  };
  publicAPI.getZBufferTexture = function() {
    if (model.framebuffer) {
      return model.framebuffer.getColorTexture();
    }
    return null;
  };
  publicAPI.requestDepth = function() {
    model.depthRequested = true;
  };
  publicAPI.incrementOpaqueActorCount = function() {
    return model.opaqueActorCount++;
  };
  publicAPI.incrementTranslucentActorCount = function() {
    return model.translucentActorCount++;
  };
  publicAPI.incrementVolumeCount = function() {
    return model.volumeCount++;
  };
  publicAPI.incrementOverlayActorCount = function() {
    return model.overlayActorCount++;
  };
}
var DEFAULT_VALUES3 = {
  opaqueActorCount: 0,
  translucentActorCount: 0,
  volumeCount: 0,
  overlayActorCount: 0,
  framebuffer: null,
  depthRequested: false
};
function extend3(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["framebuffer", "opaqueActorCount", "translucentActorCount", "volumeCount"]);
  vtkForwardPass(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend3, "vtkForwardPass");
var vtkForwardPass$1 = {
  newInstance: newInstance4,
  extend: extend3
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector.js
var import_regenerator2 = __toESM(require_regenerator());

// node_modules/@kitware/vtk.js/Rendering/Core/HardwareSelector.js
var import_regenerator = __toESM(require_regenerator());
var FieldAssociations = vtkDataSet$1.FieldAssociations;
function vtkHardwareSelector(publicAPI, model) {
  model.classHierarchy.push("vtkHardwareSelector");
  publicAPI.getSourceDataAsync = function() {
    var _ref = _asyncToGenerator(import_regenerator.default.mark(function _callee(renderer, fx1, fy1, fx2, fy2) {
      return import_regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function(_x, _x2, _x3, _x4, _x5) {
      return _ref.apply(this, arguments);
    };
  }();
  publicAPI.selectAsync = function() {
    var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee2(renderer, fx1, fy1, fx2, fy2) {
      var srcData;
      return import_regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return publicAPI.getSourceDataAsync(renderer, fx1, fy1, fx2, fy2);
            case 2:
              srcData = _context2.sent;
              if (!srcData) {
                _context2.next = 5;
                break;
              }
              return _context2.abrupt("return", srcData.generateSelection(fx1, fy1, fx2, fy2));
            case 5:
              return _context2.abrupt("return", []);
            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return function(_x6, _x7, _x8, _x9, _x10) {
      return _ref2.apply(this, arguments);
    };
  }();
}
var DEFAULT_VALUES4 = {
  fieldAssociation: FieldAssociations.FIELD_ASSOCIATION_CELLS,
  captureZValues: false
};
function extend4(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["fieldAssociation", "captureZValues"]);
  vtkHardwareSelector(publicAPI, model);
}
var newInstance5 = macro.newInstance(extend4, "vtkHardwareSelector");
var vtkHardwareSelector$1 = {
  newInstance: newInstance5,
  extend: extend4
};

// node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode/Constants.js
var SelectionContent = {
  GLOBALIDS: 0,
  PEDIGREEIDS: 1,
  VALUES: 2,
  INDICES: 3,
  FRUSTUM: 4,
  LOCATIONS: 5,
  THRESHOLDS: 6,
  BLOCKS: 7,
  QUERY: 8
};
var SelectionField = {
  CELL: 0,
  POINT: 1,
  FIELD: 2,
  VERTEX: 3,
  EDGE: 4,
  ROW: 5
};
var Constants2 = {
  SelectionContent,
  SelectionField
};

// node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtkSelectionNode(publicAPI, model) {
  model.classHierarchy.push("vtkSelectionNode");
  publicAPI.getBounds = function() {
    return model.points.getBounds();
  };
}
var DEFAULT_VALUES5 = {
  contentType: -1,
  fieldType: -1,
  properties: null,
  selectionList: []
};
function extend5(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  macro.obj(publicAPI, model);
  model.properties = {};
  macro.setGet(publicAPI, model, ["contentType", "fieldType", "properties", "selectionList"]);
  vtkSelectionNode(publicAPI, model);
}
var newInstance6 = macro.newInstance(extend5, "vtkSelectionNode");
var vtkSelectionNode$1 = _objectSpread({
  newInstance: newInstance6,
  extend: extend5
}, Constants2);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var PassTypes = Constants.PassTypes;
var SelectionContent2 = vtkSelectionNode$1.SelectionContent;
var SelectionField2 = vtkSelectionNode$1.SelectionField;
var FieldAssociations2 = vtkDataSet$1.FieldAssociations;
var vtkErrorMacro3 = macro.vtkErrorMacro;
var idOffset = 1;
function getInfoHash(info) {
  return "".concat(info.propID, " ").concat(info.compositeID);
}
function getAlpha(xx, yy, pb, area) {
  if (!pb) {
    return 0;
  }
  var offset = (yy * (area[2] - area[0] + 1) + xx) * 4;
  return pb[offset + 3];
}
function convert(xx, yy, pb, area) {
  if (!pb) {
    return 0;
  }
  var offset = (yy * (area[2] - area[0] + 1) + xx) * 4;
  var rgb = [];
  rgb[0] = pb[offset];
  rgb[1] = pb[offset + 1];
  rgb[2] = pb[offset + 2];
  var val = rgb[2];
  val *= 256;
  val += rgb[1];
  val *= 256;
  val += rgb[0];
  return val;
}
function getID(low24, high8) {
  var val = high8;
  val <<= 24;
  val |= low24;
  return val;
}
function getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
  var maxDist = maxDistance < 0 ? 0 : maxDistance;
  if (maxDist === 0) {
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    if (inDisplayPosition[0] < buffdata.area[0] || inDisplayPosition[0] > buffdata.area[2] || inDisplayPosition[1] < buffdata.area[1] || inDisplayPosition[1] > buffdata.area[3]) {
      return null;
    }
    var displayPosition = [inDisplayPosition[0] - buffdata.area[0], inDisplayPosition[1] - buffdata.area[1]];
    var actorid = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ACTOR_PASS], buffdata.area);
    if (actorid <= 0 || actorid - idOffset >= buffdata.props.length) {
      return null;
    }
    var _info = {};
    _info.valid = true;
    _info.propID = actorid - idOffset;
    _info.prop = buffdata.props[_info.propID];
    var compositeID = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], buffdata.area);
    if (compositeID < 0 || compositeID > 16777215) {
      compositeID = 0;
    }
    _info.compositeID = compositeID - idOffset;
    if (buffdata.captureZValues) {
      var offset = (displayPosition[1] * (buffdata.area[2] - buffdata.area[0] + 1) + displayPosition[0]) * 4;
      _info.zValue = (256 * buffdata.zBuffer[offset] + buffdata.zBuffer[offset + 1]) / 65535;
      _info.displayPosition = inDisplayPosition;
    }
    if (buffdata.pixBuffer[PassTypes.ID_LOW24]) {
      if (getAlpha(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area) === 0) {
        return _info;
      }
    }
    var low24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area);
    var high24 = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_HIGH24], buffdata.area);
    _info.attributeID = getID(low24, high24);
    return _info;
  }
  var dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
  var curPos = [0, 0];
  var info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);
  if (info && info.valid) {
    return info;
  }
  for (var dist = 1; dist < maxDist; ++dist) {
    for (var y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
      curPos[1] = y;
      if (dispPos[0] >= dist) {
        curPos[0] = dispPos[0] - dist;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[0] = dispPos[0] + dist;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
    for (var x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
      curPos[0] = x;
      if (dispPos[1] >= dist) {
        curPos[1] = dispPos[1] - dist;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[1] = dispPos[1] + dist;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
  }
  outSelectedPosition[0] = inDisplayPosition[0];
  outSelectedPosition[1] = inDisplayPosition[1];
  return null;
}
function convertSelection(fieldassociation, dataMap, captureZValues, renderer, openGLRenderWindow) {
  var sel = [];
  var count = 0;
  dataMap.forEach(function(value, key) {
    var child = vtkSelectionNode$1.newInstance();
    child.setContentType(SelectionContent2.INDICES);
    switch (fieldassociation) {
      case FieldAssociations2.FIELD_ASSOCIATION_CELLS:
        child.setFieldType(SelectionField2.CELL);
        break;
      case FieldAssociations2.FIELD_ASSOCIATION_POINTS:
        child.setFieldType(SelectionField2.POINT);
        break;
      default:
        vtkErrorMacro3("Unknown field association");
    }
    child.getProperties().propID = value.info.propID;
    child.getProperties().prop = value.info.prop;
    child.getProperties().compositeID = value.info.compositeID;
    child.getProperties().attributeID = value.info.attributeID;
    child.getProperties().pixelCount = value.pixelCount;
    if (captureZValues) {
      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
      child.getProperties().worldPosition = openGLRenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, renderer);
    }
    child.setSelectionList(value.attributeIDs);
    sel[count] = child;
    count++;
  });
  return sel;
}
function generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {
  var x1 = Math.floor(fx1);
  var y1 = Math.floor(fy1);
  var x2 = Math.floor(fx2);
  var y2 = Math.floor(fy2);
  var dataMap = /* @__PURE__ */ new Map();
  var outSelectedPosition = [0, 0];
  for (var yy = y1; yy <= y2; yy++) {
    for (var xx = x1; xx <= x2; xx++) {
      var pos = [xx, yy];
      var info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);
      if (info && info.valid) {
        var hash = getInfoHash(info);
        if (!dataMap.has(hash)) {
          dataMap.set(hash, {
            info,
            pixelCount: 1,
            attributeIDs: [info.attributeID]
          });
        } else {
          var dmv = dataMap.get(hash);
          dmv.pixelCount++;
          if (buffdata.captureZValues) {
            if (info.zValue < dmv.info.zValue) {
              dmv.info = info;
            }
          }
          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
            dmv.attributeIDs.push(info.attributeID);
          }
        }
      }
    }
  }
  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata.captureZValues, buffdata.renderer, buffdata.openGLRenderWindow);
}
function vtkOpenGLHardwareSelector(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLHardwareSelector");
  publicAPI.releasePixBuffers = function() {
    model.rawPixBuffer = [];
    model.pixBuffer = [];
    model.zBuffer = null;
  };
  publicAPI.beginSelection = function() {
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);
    model.maxAttributeId = 0;
    var size = model._openGLRenderWindow.getSize();
    if (!model.framebuffer) {
      model.framebuffer = vtkOpenGLFramebuffer.newInstance();
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      model.framebuffer.create(size[0], size[1]);
      model.framebuffer.populateFramebuffer();
    } else {
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      var fbSize = model.framebuffer.getSize();
      if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
        model.framebuffer.create(size[0], size[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        model.framebuffer.bind();
      }
    }
    model._openGLRenderer.clear();
    model._openGLRenderer.setSelector(publicAPI);
    model.hitProps = {};
    model.propPixels = {};
    model.props = [];
    publicAPI.releasePixBuffers();
    if (model.fieldAssociation === FieldAssociations2.FIELD_ASSOCIATION_POINTS) {
      var gl = model._openGLRenderWindow.getContext();
      var originalBlending = gl.isEnabled(gl.BLEND);
      gl.disable(gl.BLEND);
      model._openGLRenderWindow.traverseAllPasses();
      model._renderer.setPreserveDepthBuffer(true);
      if (originalBlending) {
        gl.enable(gl.BLEND);
      }
    }
  };
  publicAPI.endSelection = function() {
    model.hitProps = {};
    model._openGLRenderer.setSelector(null);
    model.framebuffer.restorePreviousBindingsAndBuffers();
    model._renderer.setPreserveDepthBuffer(false);
  };
  publicAPI.preCapturePass = function() {
    var gl = model._openGLRenderWindow.getContext();
    model.originalBlending = gl.isEnabled(gl.BLEND);
    gl.disable(gl.BLEND);
  };
  publicAPI.postCapturePass = function() {
    var gl = model._openGLRenderWindow.getContext();
    if (model.originalBlending) {
      gl.enable(gl.BLEND);
    }
  };
  publicAPI.select = function() {
    var sel = null;
    if (publicAPI.captureBuffers()) {
      sel = publicAPI.generateSelection(model.area[0], model.area[1], model.area[2], model.area[3]);
      publicAPI.releasePixBuffers();
    }
    return sel;
  };
  publicAPI.getSourceDataAsync = function() {
    var _ref = _asyncToGenerator(import_regenerator2.default.mark(function _callee(renderer, fx1, fy1, fx2, fy2) {
      var size, result;
      return import_regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              model._renderer = renderer;
              if (fx1 === void 0) {
                size = model._openGLRenderWindow.getSize();
                publicAPI.setArea(0, 0, size[0] - 1, size[1] - 1);
              } else {
                publicAPI.setArea(fx1, fy1, fx2, fy2);
              }
              if (publicAPI.captureBuffers()) {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return", false);
            case 4:
              result = {
                area: _toConsumableArray(model.area),
                pixBuffer: _toConsumableArray(model.pixBuffer),
                captureZValues: model.captureZValues,
                zBuffer: model.zBuffer,
                props: _toConsumableArray(model.props),
                fieldAssociation: model.fieldAssociation,
                renderer,
                openGLRenderWindow: model._openGLRenderWindow
              };
              result.generateSelection = function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return generateSelectionWithData.apply(void 0, [result].concat(args));
              };
              return _context.abrupt("return", result);
            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function(_x, _x2, _x3, _x4, _x5) {
      return _ref.apply(this, arguments);
    };
  }();
  publicAPI.captureBuffers = function() {
    if (!model._renderer || !model._openGLRenderWindow) {
      vtkErrorMacro3("Renderer and view must be set before calling Select.");
      return false;
    }
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);
    model._openGLRenderWindow.getRenderable().preRender();
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.originalBackground = model._renderer.getBackgroundByReference();
    model._renderer.setBackground(0, 0, 0, 0);
    var rpasses = model._openGLRenderWindow.getRenderPasses();
    publicAPI.beginSelection();
    for (model.currentPass = PassTypes.MIN_KNOWN_PASS; model.currentPass <= PassTypes.MAX_KNOWN_PASS; model.currentPass++) {
      if (publicAPI.passRequired(model.currentPass)) {
        publicAPI.preCapturePass(model.currentPass);
        if (model.captureZValues && model.currentPass === PassTypes.ACTOR_PASS && typeof rpasses[0].requestDepth === "function" && typeof rpasses[0].getFramebuffer === "function") {
          rpasses[0].requestDepth();
          model._openGLRenderWindow.traverseAllPasses();
        } else {
          model._openGLRenderWindow.traverseAllPasses();
        }
        publicAPI.postCapturePass(model.currentPass);
        publicAPI.savePixelBuffer(model.currentPass);
        publicAPI.processPixelBuffers();
      }
    }
    publicAPI.endSelection();
    model._renderer.setBackground(model.originalBackground);
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    return true;
  };
  publicAPI.processPixelBuffers = function() {
    model.props.forEach(function(prop, index) {
      if (publicAPI.isPropHit(index)) {
        prop.processSelectorPixelBuffers(publicAPI, model.propPixels[index]);
      }
    });
  };
  publicAPI.passRequired = function(pass) {
    if (pass === PassTypes.ID_HIGH24) {
      if (model.fieldAssociation === FieldAssociations2.FIELD_ASSOCIATION_POINTS) {
        return model.maximumPointId > 16777215;
      }
      if (model.fieldAssociation === FieldAssociations2.FIELD_ASSOCIATION_CELLS) {
        return model.maximumCellId > 16777215;
      }
    }
    return true;
  };
  publicAPI.savePixelBuffer = function(passNo) {
    model.pixBuffer[passNo] = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
    if (!model.rawPixBuffer[passNo]) {
      var size = (model.area[2] - model.area[0] + 1) * (model.area[3] - model.area[1] + 1) * 4;
      model.rawPixBuffer[passNo] = new Uint8Array(size);
      model.rawPixBuffer[passNo].set(model.pixBuffer[passNo]);
    }
    if (passNo === PassTypes.ACTOR_PASS) {
      if (model.captureZValues) {
        var rpasses = model._openGLRenderWindow.getRenderPasses();
        if (typeof rpasses[0].requestDepth === "function" && typeof rpasses[0].getFramebuffer === "function") {
          var fb = rpasses[0].getFramebuffer();
          fb.saveCurrentBindingsAndBuffers();
          fb.bind();
          model.zBuffer = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
          fb.restorePreviousBindingsAndBuffers();
        }
      }
      publicAPI.buildPropHitList(model.rawPixBuffer[passNo]);
    }
  };
  publicAPI.buildPropHitList = function(pixelbuffer) {
    var offset = 0;
    for (var yy = 0; yy <= model.area[3] - model.area[1]; yy++) {
      for (var xx = 0; xx <= model.area[2] - model.area[0]; xx++) {
        var val = convert(xx, yy, pixelbuffer, model.area);
        if (val > 0) {
          val--;
          if (!(val in model.hitProps)) {
            model.hitProps[val] = true;
            model.propPixels[val] = [];
          }
          model.propPixels[val].push(offset * 4);
        }
        ++offset;
      }
    }
  };
  publicAPI.renderProp = function(prop) {
    if (model.currentPass === PassTypes.ACTOR_PASS) {
      publicAPI.setPropColorValueFromInt(model.props.length + idOffset);
      model.props.push(prop);
    }
  };
  publicAPI.renderCompositeIndex = function(index) {
    if (model.currentPass === PassTypes.COMPOSITE_INDEX_PASS) {
      publicAPI.setPropColorValueFromInt(index + idOffset);
    }
  };
  publicAPI.renderAttributeId = function(attribid) {
    if (attribid < 0) {
      return;
    }
    model.maxAttributeId = attribid > model.maxAttributeId ? attribid : model.maxAttributeId;
  };
  publicAPI.passTypeToString = function(type) {
    return macro.enumToString(PassTypes, type);
  };
  publicAPI.isPropHit = function(id) {
    return Boolean(model.hitProps[id]);
  };
  publicAPI.setPropColorValueFromInt = function(val) {
    model.propColorValue[0] = val % 256 / 255;
    model.propColorValue[1] = Math.floor(val / 256) % 256 / 255;
    model.propColorValue[2] = Math.floor(val / 65536) % 256 / 255;
  };
  publicAPI.getPixelInformation = function(inDisplayPosition, maxDistance, outSelectedPosition) {
    var maxDist = maxDistance < 0 ? 0 : maxDistance;
    if (maxDist === 0) {
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      if (inDisplayPosition[0] < model.area[0] || inDisplayPosition[0] > model.area[2] || inDisplayPosition[1] < model.area[1] || inDisplayPosition[1] > model.area[3]) {
        return null;
      }
      var displayPosition = [inDisplayPosition[0] - model.area[0], inDisplayPosition[1] - model.area[1]];
      var actorid = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ACTOR_PASS], model.area);
      if (actorid <= 0 || actorid - idOffset >= model.props.length) {
        return null;
      }
      var _info2 = {};
      _info2.valid = true;
      _info2.propID = actorid - idOffset;
      _info2.prop = model.props[_info2.propID];
      var compositeID = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], model.area);
      if (compositeID < 0 || compositeID > 16777215) {
        compositeID = 0;
      }
      _info2.compositeID = compositeID - idOffset;
      if (model.captureZValues) {
        var offset = (displayPosition[1] * (model.area[2] - model.area[0] + 1) + displayPosition[0]) * 4;
        _info2.zValue = (256 * model.zBuffer[offset] + model.zBuffer[offset + 1]) / 65535;
        _info2.displayPosition = inDisplayPosition;
      }
      if (model.pixBuffer[PassTypes.ID_LOW24]) {
        if (getAlpha(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area) === 0) {
          return _info2;
        }
      }
      var low24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area);
      var high24 = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_HIGH24], model.area);
      _info2.attributeID = getID(low24, high24);
      return _info2;
    }
    var dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
    var curPos = [0, 0];
    var info = publicAPI.getPixelInformation(inDisplayPosition, 0, outSelectedPosition);
    if (info && info.valid) {
      return info;
    }
    for (var dist = 1; dist < maxDist; ++dist) {
      for (var y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
        curPos[1] = y;
        if (dispPos[0] >= dist) {
          curPos[0] = dispPos[0] - dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[0] = dispPos[0] + dist;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      for (var x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
        curPos[0] = x;
        if (dispPos[1] >= dist) {
          curPos[1] = dispPos[1] - dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[1] = dispPos[1] + dist;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
    }
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    return null;
  };
  publicAPI.generateSelection = function(fx1, fy1, fx2, fy2) {
    var x1 = Math.floor(fx1);
    var y1 = Math.floor(fy1);
    var x2 = Math.floor(fx2);
    var y2 = Math.floor(fy2);
    var dataMap = /* @__PURE__ */ new Map();
    var outSelectedPosition = [0, 0];
    for (var yy = y1; yy <= y2; yy++) {
      for (var xx = x1; xx <= x2; xx++) {
        var pos = [xx, yy];
        var info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);
        if (info && info.valid) {
          var hash = getInfoHash(info);
          if (!dataMap.has(hash)) {
            dataMap.set(hash, {
              info,
              pixelCount: 1,
              attributeIDs: [info.attributeID]
            });
          } else {
            var dmv = dataMap.get(hash);
            dmv.pixelCount++;
            if (model.captureZValues) {
              if (info.zValue < dmv.info.zValue) {
                dmv.info = info;
              }
            }
            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
              dmv.attributeIDs.push(info.attributeID);
            }
          }
        }
      }
    }
    return convertSelection(model.fieldAssociation, dataMap, model.captureZValues, model._renderer, model._openGLRenderWindow);
  };
  publicAPI.getRawPixelBuffer = function(passNo) {
    return model.rawPixBuffer[passNo];
  };
  publicAPI.getPixelBuffer = function(passNo) {
    return model.pixBuffer[passNo];
  };
  publicAPI.attach = function(w, r) {
    model._openGLRenderWindow = w;
    model._renderer = r;
  };
  var superSetArea = publicAPI.setArea;
  publicAPI.setArea = function() {
    if (superSetArea.apply(void 0, arguments)) {
      model.area[0] = Math.floor(model.area[0]);
      model.area[1] = Math.floor(model.area[1]);
      model.area[2] = Math.floor(model.area[2]);
      model.area[3] = Math.floor(model.area[3]);
      return true;
    }
    return false;
  };
}
var DEFAULT_VALUES6 = {
  area: void 0,
  currentPass: -1,
  propColorValue: null,
  props: null,
  maximumPointId: 0,
  maximumCellId: 0,
  idOffset: 1
};
function extend6(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  vtkHardwareSelector$1.extend(publicAPI, model, initialValues);
  model.propColorValue = [0, 0, 0];
  model.props = [];
  if (!model.area) {
    model.area = [0, 0, 0, 0];
  }
  macro.setGetArray(publicAPI, model, ["area"], 4);
  macro.setGet(publicAPI, model, ["_renderer", "currentPass", "_openGLRenderWindow", "maximumPointId", "maximumCellId"]);
  macro.setGetArray(publicAPI, model, ["propColorValue"], 3);
  macro.moveToProtected(publicAPI, model, ["renderer", "openGLRenderWindow"]);
  macro.event(publicAPI, model, "event");
  vtkOpenGLHardwareSelector(publicAPI, model);
}
var newInstance7 = macro.newInstance(extend6, "vtkOpenGLHardwareSelector");
var vtkHardwareSelector2 = _objectSpread2({
  newInstance: newInstance7,
  extend: extend6
}, Constants);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderCache.js
var import_spark_md5 = __toESM(require_spark_md5());
var SET_GET_FIELDS = ["lastShaderBound", "context", "_openGLRenderWindow"];
function vtkShaderCache(publicAPI, model) {
  model.classHierarchy.push("vtkShaderCache");
  publicAPI.replaceShaderValues = function(VSSource, FSSource, GSSource) {
    var nFSSource = FSSource;
    if (GSSource.length > 0) {
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "VSOut", "GSOut").result;
    }
    var gl2 = model._openGLRenderWindow.getWebgl2();
    var fragDepthString = "\n";
    var version = "#version 100\n";
    if (gl2) {
      version = "#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n";
    } else {
      model.context.getExtension("OES_standard_derivatives");
      if (model.context.getExtension("EXT_frag_depth")) {
        fragDepthString = "#extension GL_EXT_frag_depth : enable\n";
      }
      if (model.context.getExtension("EXT_shader_texture_lod")) {
        fragDepthString += "#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT";
      }
    }
    nFSSource = vtkShaderProgram$1.substitute(nFSSource, "//VTK::System::Dec", ["".concat(version, "\n"), gl2 ? "" : "#extension GL_OES_standard_derivatives : enable\n", fragDepthString, "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "precision highp int;", "#else", "precision mediump float;", "precision mediump int;", "#endif"]).result;
    var nVSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::System::Dec", ["".concat(version, "\n"), "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "precision highp int;", "#else", "precision mediump float;", "precision mediump int;", "#endif"]).result;
    if (gl2) {
      nVSSource = vtkShaderProgram$1.substitute(nVSSource, "varying", "out").result;
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "varying", "in").result;
      var shaderOutputs = "";
      var outputCount = 0;
      while (nFSSource.includes("gl_FragData[".concat(outputCount, "]"))) {
        nFSSource = vtkShaderProgram$1.substitute(nFSSource, "gl_FragData\\[".concat(outputCount, "\\]"), "fragOutput".concat(outputCount)).result;
        shaderOutputs += "layout(location = ".concat(outputCount, ") out vec4 fragOutput").concat(outputCount, ";\n");
        outputCount++;
      }
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "//VTK::Output::Dec", shaderOutputs).result;
    }
    var nGSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::System::Dec", version).result;
    return {
      VSSource: nVSSource,
      FSSource: nFSSource,
      GSSource: nGSSource
    };
  };
  publicAPI.readyShaderProgramArray = function(vertexCode, fragmentCode, geometryCode) {
    var data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);
    var shader = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);
    return publicAPI.readyShaderProgram(shader);
  };
  publicAPI.readyShaderProgram = function(shader) {
    if (!shader) {
      return null;
    }
    if (!shader.getCompiled() && !shader.compileShader()) {
      return null;
    }
    if (!publicAPI.bindShader(shader)) {
      return null;
    }
    return shader;
  };
  publicAPI.getShaderProgram = function(vertexCode, fragmentCode, geometryCode) {
    var hashInput = "".concat(vertexCode).concat(fragmentCode).concat(geometryCode);
    var result = import_spark_md5.default.hash(hashInput);
    if (!(result in model.shaderPrograms)) {
      var sps = vtkShaderProgram$1.newInstance();
      sps.setContext(model.context);
      sps.getVertexShader().setSource(vertexCode);
      sps.getFragmentShader().setSource(fragmentCode);
      if (geometryCode) {
        sps.getGeometryShader().setSource(geometryCode);
      }
      sps.setMd5Hash(result);
      model.shaderPrograms[result] = sps;
      return sps;
    }
    return model.shaderPrograms[result];
  };
  publicAPI.releaseGraphicsResources = function(win) {
    publicAPI.releaseCurrentShader();
    Object.keys(model.shaderPrograms).map(function(key) {
      return model.shaderPrograms[key];
    }).forEach(function(sp) {
      return sp.releaseGraphicsResources(win);
    });
  };
  publicAPI.releaseGraphicsResources = function() {
    if (model.astShaderBound) {
      model.lastShaderBound.release();
      model.lastShaderBound = null;
    }
  };
  publicAPI.bindShader = function(shader) {
    if (model.lastShaderBound === shader) {
      return 1;
    }
    if (model.lastShaderBound) {
      model.lastShaderBound.release();
    }
    shader.bind();
    model.lastShaderBound = shader;
    return 1;
  };
}
var DEFAULT_VALUES7 = {
  lastShaderBound: null,
  shaderPrograms: null,
  context: null
};
function extend7(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES7, initialValues);
  model.shaderPrograms = {};
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, SET_GET_FIELDS);
  macro.moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkShaderCache(publicAPI, model);
}
var newInstance8 = macro.newInstance(extend7, "vtkShaderCache");
var vtkShaderCache$1 = {
  newInstance: newInstance8,
  extend: extend7
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/TextureUnitManager.js
var vtkErrorMacro4 = macro.vtkErrorMacro;
function vtkOpenGLTextureUnitManager(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLTextureUnitManager");
  publicAPI.deleteTable = function() {
    for (var i = 0; i < model.numberOfTextureUnits; ++i) {
      if (model.textureUnits[i] === true) {
        vtkErrorMacro4("some texture units  were not properly released");
      }
    }
    model.textureUnits = [];
    model.numberOfTextureUnits = 0;
  };
  publicAPI.setContext = function(ctx) {
    if (model.context !== ctx) {
      if (model.context !== 0) {
        publicAPI.deleteTable();
      }
      model.context = ctx;
      if (model.context) {
        model.numberOfTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
        for (var i = 0; i < model.numberOfTextureUnits; ++i) {
          model.textureUnits[i] = false;
        }
      }
      publicAPI.modified();
    }
  };
  publicAPI.allocate = function() {
    for (var i = 0; i < model.numberOfTextureUnits; i++) {
      if (!publicAPI.isAllocated(i)) {
        model.textureUnits[i] = true;
        return i;
      }
    }
    return -1;
  };
  publicAPI.allocateUnit = function(unit) {
    if (publicAPI.isAllocated(unit)) {
      return -1;
    }
    model.textureUnits[unit] = true;
    return unit;
  };
  publicAPI.isAllocated = function(textureUnitId) {
    return model.textureUnits[textureUnitId];
  };
  publicAPI.free = function(val) {
    model.textureUnits[val] = false;
  };
}
var DEFAULT_VALUES8 = {
  context: null,
  numberOfTextureUnits: 0,
  textureUnits: 0
};
function extend8(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES8, initialValues);
  macro.obj(publicAPI, model);
  model.textureUnits = [];
  macro.get(publicAPI, model, ["numberOfTextureUnits"]);
  macro.setGet(publicAPI, model, ["context"]);
  vtkOpenGLTextureUnitManager(publicAPI, model);
}
var newInstance9 = macro.newInstance(extend8, "vtkOpenGLTextureUnitManager");
var vtkTextureUnitManager = {
  newInstance: newInstance9,
  extend: extend8
};

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderWindowViewNode.js
function vtkRenderWindowViewNode(publicAPI, model) {
  model.classHierarchy.push("vtkRenderWindowViewNode");
  publicAPI.getViewNodeFactory = function() {
    return null;
  };
  publicAPI.getAspectRatio = function() {
    return model.size[0] / model.size[1];
  };
  publicAPI.getAspectRatioForRenderer = function(renderer) {
    var viewport = renderer.getViewportByReference();
    return model.size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * model.size[1]);
  };
  publicAPI.isInViewport = function(x, y, viewport) {
    var vCoords = viewport.getViewportByReference();
    var size = publicAPI.getFramebufferSize();
    if (vCoords[0] * size[0] <= x && vCoords[2] * size[0] >= x && vCoords[1] * size[1] <= y && vCoords[3] * size[1] >= y) {
      return true;
    }
    return false;
  };
  publicAPI.getViewportSize = function(viewport) {
    var vCoords = viewport.getViewportByReference();
    var size = publicAPI.getFramebufferSize();
    return [(vCoords[2] - vCoords[0]) * size[0], (vCoords[3] - vCoords[1]) * size[1]];
  };
  publicAPI.getViewportCenter = function(viewport) {
    var size = publicAPI.getViewportSize(viewport);
    return [size[0] * 0.5, size[1] * 0.5];
  };
  publicAPI.displayToNormalizedDisplay = function(x, y, z) {
    var size = publicAPI.getFramebufferSize();
    return [x / size[0], y / size[1], z];
  };
  publicAPI.normalizedDisplayToDisplay = function(x, y, z) {
    var size = publicAPI.getFramebufferSize();
    return [x * size[0], y * size[1], z];
  };
  publicAPI.worldToView = function(x, y, z, renderer) {
    return renderer.worldToView(x, y, z);
  };
  publicAPI.viewToWorld = function(x, y, z, renderer) {
    return renderer.viewToWorld(x, y, z);
  };
  publicAPI.worldToDisplay = function(x, y, z, renderer) {
    var val = renderer.worldToView(x, y, z);
    var dims = publicAPI.getViewportSize(renderer);
    var val2 = renderer.viewToProjection(val[0], val[1], val[2], dims[0] / dims[1]);
    var val3 = renderer.projectionToNormalizedDisplay(val2[0], val2[1], val2[2]);
    return publicAPI.normalizedDisplayToDisplay(val3[0], val3[1], val3[2]);
  };
  publicAPI.displayToWorld = function(x, y, z, renderer) {
    var val = publicAPI.displayToNormalizedDisplay(x, y, z);
    var val2 = renderer.normalizedDisplayToProjection(val[0], val[1], val[2]);
    var dims = publicAPI.getViewportSize(renderer);
    var val3 = renderer.projectionToView(val2[0], val2[1], val2[2], dims[0] / dims[1]);
    return renderer.viewToWorld(val3[0], val3[1], val3[2]);
  };
  publicAPI.normalizedDisplayToViewport = function(x, y, z, renderer) {
    var vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0);
    var coords = publicAPI.normalizedDisplayToDisplay(x, y, z);
    return [coords[0] - vCoords[0] - 0.5, coords[1] - vCoords[1] - 0.5, z];
  };
  publicAPI.viewportToNormalizedViewport = function(x, y, z, renderer) {
    var size = publicAPI.getViewportSize(renderer);
    if (size && size[0] !== 0 && size[1] !== 0) {
      return [x / (size[0] - 1), y / (size[1] - 1), z];
    }
    return [x, y, z];
  };
  publicAPI.normalizedViewportToViewport = function(x, y, z, renderer) {
    var size = publicAPI.getViewportSize(renderer);
    return [x * (size[0] - 1), y * (size[1] - 1), z];
  };
  publicAPI.displayToLocalDisplay = function(x, y, z) {
    var size = publicAPI.getFramebufferSize();
    return [x, size[1] - y - 1, z];
  };
  publicAPI.viewportToNormalizedDisplay = function(x, y, z, renderer) {
    var vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0);
    var x2 = x + vCoords[0] + 0.5;
    var y2 = y + vCoords[1] + 0.5;
    return publicAPI.displayToNormalizedDisplay(x2, y2, z);
  };
  publicAPI.getPixelData = function(x1, y1, x2, y2) {
    macro.vtkErrorMacro("not implemented");
    return void 0;
  };
  publicAPI.createSelector = function() {
    macro.vtkErrorMacro("not implemented");
    return void 0;
  };
}
var DEFAULT_VALUES9 = {
  size: void 0,
  selector: void 0
};
function extend9(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES9, initialValues);
  if (!model.size) {
    model.size = [300, 300];
  }
  macro.getArray(publicAPI, model, ["size"], 2);
  macro.get(publicAPI, model, ["selector"]);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkRenderWindowViewNode(publicAPI, model);
}
var newInstance10 = macro.newInstance(extend9, "vtkRenderWindowViewNode");
var vtkRenderWindowViewNode$1 = {
  newInstance: newInstance10,
  extend: extend9
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow/ContextProxy.js
function createContextProxyHandler() {
  var cache = /* @__PURE__ */ new Map();
  var getParameterHandler = {
    apply: function apply(target, gl, args) {
      if (cache.has(args[0])) {
        return cache.get(args[0]);
      }
      return target.apply(gl, args);
    }
  };
  function cachedSetterHandler(key) {
    return {
      apply: function apply(target, gl, args) {
        cache.set(key, args[0]);
        return target.apply(gl, args);
      }
    };
  }
  var propHandlers = /* @__PURE__ */ Object.create(null);
  propHandlers.getParameter = function(gl, prop, receiver, propValue) {
    return new Proxy(propValue.bind(gl), getParameterHandler);
  };
  propHandlers.depthMask = function(gl, prop, receiver, propValue) {
    return new Proxy(propValue.bind(gl), cachedSetterHandler(gl.DEPTH_WRITEMASK));
  };
  return {
    get: function get2(gl, prop, receiver) {
      var value = Reflect.get(gl, prop, receiver);
      if (value instanceof Function) {
        value = value.bind(gl);
      }
      var propHandler = propHandlers[prop];
      if (propHandler) {
        return propHandler(gl, prop, receiver, value);
      }
      return value;
    }
  };
}

// node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow.js
var vtkDebugMacro = macro.vtkDebugMacro;
var vtkErrorMacro5 = macro.vtkErrorMacro;
var SCREENSHOT_PLACEHOLDER = {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%"
};
var DEFAULT_RESET_FACTORS = {
  vr: {
    rescaleFactor: 1,
    translateZ: -0.7
  },
  ar: {
    rescaleFactor: 0.25,
    translateZ: -0.5
  }
};
function checkRenderTargetSupport(gl, format, type) {
  var framebuffer = gl.createFramebuffer();
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, 2, 2, 0, format, type, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return status === gl.FRAMEBUFFER_COMPLETE;
}
var GL_CONTEXT_COUNT = 0;
var GL_CONTEXT_LISTENERS = [];
function createGLContext() {
  GL_CONTEXT_COUNT++;
  GL_CONTEXT_LISTENERS.forEach(function(cb) {
    return cb(GL_CONTEXT_COUNT);
  });
}
function deleteGLContext() {
  GL_CONTEXT_COUNT--;
  GL_CONTEXT_LISTENERS.forEach(function(cb) {
    return cb(GL_CONTEXT_COUNT);
  });
}
function vtkOpenGLRenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLRenderWindow");
  var cachingContextHandler = createContextProxyHandler();
  publicAPI.getViewNodeFactory = function() {
    return model.myFactory;
  };
  model.canvas.addEventListener("webglcontextlost", function(event) {
    event.preventDefault();
  }, false);
  model.canvas.addEventListener("webglcontextrestored", publicAPI.restoreContext, false);
  var isImmersiveVrSupported = navigator.xr !== void 0 && navigator.xr.isSessionSupported("immersive-vr");
  var previousSize = [0, 0];
  function updateWindow() {
    if (model.renderable) {
      if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
        previousSize[0] = model.size[0];
        previousSize[1] = model.size[1];
        model.canvas.setAttribute("width", model.size[0]);
        model.canvas.setAttribute("height", model.size[1]);
      }
    }
    if (model.viewStream) {
      model.viewStream.setSize(model.size[0], model.size[1]);
    }
    model.canvas.style.display = model.useOffScreen ? "none" : "block";
    if (model.el) {
      model.el.style.cursor = model.cursorVisibility ? model.cursor : "none";
    }
    model.containerSize = null;
  }
  publicAPI.onModified(updateWindow);
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
      publicAPI.removeUnusedNodes();
      publicAPI.initialize();
      model.children.forEach(function(child) {
        child.setOpenGLRenderWindow(publicAPI);
      });
    }
  };
  publicAPI.initialize = function() {
    if (!model.initialized) {
      model.context = publicAPI.get3DContext();
      model.textureUnitManager = vtkTextureUnitManager.newInstance();
      model.textureUnitManager.setContext(model.context);
      model.shaderCache.setContext(model.context);
      var gl = model.context;
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      gl.depthFunc(gl.LEQUAL);
      gl.enable(gl.BLEND);
      model.initialized = true;
    }
  };
  publicAPI.makeCurrent = function() {
    model.context.makeCurrent();
  };
  publicAPI.setContainer = function(el) {
    if (model.el && model.el !== el) {
      if (model.canvas.parentNode !== model.el) {
        vtkErrorMacro5("Error: canvas parent node does not match container");
      }
      model.el.removeChild(model.canvas);
      if (model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    }
    if (model.el !== el) {
      model.el = el;
      if (model.el) {
        model.el.appendChild(model.canvas);
        if (model.useBackgroundImage) {
          model.el.appendChild(model.bgImage);
        }
      }
      publicAPI.modified();
    }
  };
  publicAPI.getContainer = function() {
    return model.el;
  };
  publicAPI.getContainerSize = function() {
    if (!model.containerSize && model.el) {
      var _model$el$getBounding = model.el.getBoundingClientRect(), width = _model$el$getBounding.width, height = _model$el$getBounding.height;
      model.containerSize = [width, height];
    }
    return model.containerSize || model.size;
  };
  publicAPI.getFramebufferSize = function() {
    if (model.activeFramebuffer) {
      return model.activeFramebuffer.getSize();
    }
    return model.size;
  };
  publicAPI.getPixelData = function(x1, y1, x2, y2) {
    var pixels = new Uint8Array((x2 - x1 + 1) * (y2 - y1 + 1) * 4);
    model.context.readPixels(x1, y1, x2 - x1 + 1, y2 - y1 + 1, model.context.RGBA, model.context.UNSIGNED_BYTE, pixels);
    return pixels;
  };
  publicAPI.get3DContext = function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      preserveDrawingBuffer: false,
      depth: true,
      alpha: true,
      powerPreference: "high-performance"
    };
    var result = null;
    if (isImmersiveVrSupported) {
      publicAPI.invokeHaveVRDisplay();
    }
    var webgl2Supported = typeof WebGL2RenderingContext !== "undefined";
    model.webgl2 = false;
    if (model.defaultToWebgl2 && webgl2Supported) {
      result = model.canvas.getContext("webgl2", options);
      if (result) {
        model.webgl2 = true;
        vtkDebugMacro("using webgl2");
      }
    }
    if (!result) {
      vtkDebugMacro("using webgl1");
      result = model.canvas.getContext("webgl", options) || model.canvas.getContext("experimental-webgl", options);
    }
    return new Proxy(result, cachingContextHandler);
  };
  publicAPI.startXR = function(isAR) {
    if (navigator.xr === void 0) {
      throw new Error("WebXR is not available");
    }
    model.xrSessionIsAR = isAR;
    var sessionType = isAR ? "immersive-ar" : "immersive-vr";
    if (!navigator.xr.isSessionSupported(sessionType)) {
      if (isAR) {
        throw new Error("Device does not support AR session");
      } else {
        throw new Error("VR display is not available");
      }
    }
    if (model.xrSession === null) {
      navigator.xr.requestSession(sessionType).then(publicAPI.enterXR, function() {
        throw new Error("Failed to create XR session!");
      });
    } else {
      throw new Error("XR Session already exists!");
    }
  };
  publicAPI.enterXR = function() {
    var _ref = _asyncToGenerator(import_regenerator3.default.mark(function _callee(xrSession) {
      var gl, glLayer;
      return import_regenerator3.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              model.xrSession = xrSession;
              model.oldCanvasSize = model.size.slice();
              if (!(model.xrSession !== null)) {
                _context.next = 15;
                break;
              }
              gl = publicAPI.get3DContext();
              _context.next = 6;
              return gl.makeXRCompatible();
            case 6:
              glLayer = new global.XRWebGLLayer(model.xrSession, gl);
              publicAPI.setSize(glLayer.framebufferWidth, glLayer.framebufferHeight);
              model.xrSession.updateRenderState({
                baseLayer: glLayer
              });
              model.xrSession.requestReferenceSpace("local").then(function(refSpace) {
                model.xrReferenceSpace = refSpace;
              });
              publicAPI.resetXRScene();
              model.renderable.getInteractor().switchToXRAnimation();
              model.xrSceneFrame = model.xrSession.requestAnimationFrame(publicAPI.xrRender);
              _context.next = 16;
              break;
            case 15:
              throw new Error("Failed to enter VR with a null xrSession.");
            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  publicAPI.resetXRScene = function() {
    var inputRescaleFactor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_RESET_FACTORS.vr.rescaleFactor;
    var inputTranslateZ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_RESET_FACTORS.vr.translateZ;
    var rescaleFactor = inputRescaleFactor;
    var translateZ = inputTranslateZ;
    if (model.xrSessionIsAR && rescaleFactor === DEFAULT_RESET_FACTORS.vr.rescaleFactor) {
      rescaleFactor = DEFAULT_RESET_FACTORS.ar.rescaleFactor;
    }
    if (model.xrSessionIsAR && translateZ === DEFAULT_RESET_FACTORS.vr.translateZ) {
      translateZ = DEFAULT_RESET_FACTORS.ar.translateZ;
    }
    var ren = model.renderable.getRenderers()[0];
    ren.resetCamera();
    var camera = ren.getActiveCamera();
    var physicalScale = camera.getPhysicalScale();
    var physicalTranslation = camera.getPhysicalTranslation();
    physicalScale /= rescaleFactor;
    translateZ *= physicalScale;
    physicalTranslation[2] += translateZ;
    camera.setPhysicalScale(physicalScale);
    camera.setPhysicalTranslation(physicalTranslation);
    camera.setClippingRange(0.1 * physicalScale, 100 * physicalScale);
  };
  publicAPI.stopXR = _asyncToGenerator(import_regenerator3.default.mark(function _callee2() {
    var gl, ren;
    return import_regenerator3.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(navigator.xr === void 0)) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return");
          case 2:
            if (!(model.xrSession !== null)) {
              _context2.next = 10;
              break;
            }
            model.xrSession.cancelAnimationFrame(model.xrSceneFrame);
            model.renderable.getInteractor().returnFromXRAnimation();
            gl = publicAPI.get3DContext();
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            _context2.next = 9;
            return model.xrSession.end().catch(function(error) {
              if (!(error instanceof DOMException)) {
                throw error;
              }
            });
          case 9:
            model.xrSession = null;
          case 10:
            if (model.oldCanvasSize !== void 0) {
              publicAPI.setSize.apply(publicAPI, _toConsumableArray(model.oldCanvasSize));
            }
            ren = model.renderable.getRenderers()[0];
            ren.getActiveCamera().setProjectionMatrix(null);
            ren.resetCamera();
            ren.setViewport(0, 0, 1, 1);
            publicAPI.traverseAllPasses();
          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  publicAPI.xrRender = function() {
    var _ref3 = _asyncToGenerator(import_regenerator3.default.mark(function _callee3(t, frame) {
      var xrSession, xrPose, gl, glLayer, ren;
      return import_regenerator3.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              xrSession = frame.session;
              model.renderable.getInteractor().updateXRGamepads(xrSession, frame, model.xrReferenceSpace);
              model.xrSceneFrame = model.xrSession.requestAnimationFrame(publicAPI.xrRender);
              xrPose = frame.getViewerPose(model.xrReferenceSpace);
              if (xrPose) {
                gl = publicAPI.get3DContext();
                if (model.xrSessionIsAR && model.oldCanvasSize !== void 0) {
                  gl.canvas.width = model.oldCanvasSize[0];
                  gl.canvas.height = model.oldCanvasSize[1];
                }
                glLayer = xrSession.renderState.baseLayer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.clear(gl.DEPTH_BUFFER_BIT);
                ren = model.renderable.getRenderers()[0];
                xrPose.views.forEach(function(view) {
                  var viewport = glLayer.getViewport(view);
                  gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                  if (!model.xrSessionIsAR) {
                    if (view.eye === "left") {
                      ren.setViewport(0, 0, 0.5, 1);
                    } else if (view.eye === "right") {
                      ren.setViewport(0.5, 0, 1, 1);
                    } else {
                      return;
                    }
                  }
                  ren.getActiveCamera().computeViewParametersFromPhysicalMatrix(view.transform.inverse.matrix);
                  ren.getActiveCamera().setProjectionMatrix(view.projectionMatrix);
                  publicAPI.traverseAllPasses();
                });
              }
            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return function(_x2, _x3) {
      return _ref3.apply(this, arguments);
    };
  }();
  publicAPI.restoreContext = function() {
    var rp = vtkRenderPass$1.newInstance();
    rp.setCurrentOperation("Release");
    rp.traverse(publicAPI, null);
  };
  publicAPI.activateTexture = function(texture) {
    var result = model._textureResourceIds.get(texture);
    if (result !== void 0) {
      model.context.activeTexture(model.context.TEXTURE0 + result);
      return;
    }
    var activeUnit = publicAPI.getTextureUnitManager().allocate();
    if (activeUnit < 0) {
      vtkErrorMacro5("Hardware does not support the number of textures defined.");
      return;
    }
    model._textureResourceIds.set(texture, activeUnit);
    model.context.activeTexture(model.context.TEXTURE0 + activeUnit);
  };
  publicAPI.deactivateTexture = function(texture) {
    var result = model._textureResourceIds.get(texture);
    if (result !== void 0) {
      publicAPI.getTextureUnitManager().free(result);
      delete model._textureResourceIds.delete(texture);
    }
  };
  publicAPI.getTextureUnitForTexture = function(texture) {
    var result = model._textureResourceIds.get(texture);
    if (result !== void 0) {
      return result;
    }
    return -1;
  };
  publicAPI.getDefaultTextureInternalFormat = function(vtktype, numComps, useFloat) {
    if (model.webgl2) {
      switch (vtktype) {
        case VtkDataTypes.UNSIGNED_CHAR:
          switch (numComps) {
            case 1:
              return model.context.R8;
            case 2:
              return model.context.RG8;
            case 3:
              return model.context.RGB8;
            case 4:
            default:
              return model.context.RGBA8;
          }
        case VtkDataTypes.FLOAT:
        default:
          switch (numComps) {
            case 1:
              return model.context.R16F;
            case 2:
              return model.context.RG16F;
            case 3:
              return model.context.RGB16F;
            case 4:
            default:
              return model.context.RGBA16F;
          }
      }
    }
    switch (numComps) {
      case 1:
        return model.context.LUMINANCE;
      case 2:
        return model.context.LUMINANCE_ALPHA;
      case 3:
        return model.context.RGB;
      case 4:
      default:
        return model.context.RGBA;
    }
  };
  publicAPI.setBackgroundImage = function(img) {
    model.bgImage.src = img.src;
  };
  publicAPI.setUseBackgroundImage = function(value) {
    model.useBackgroundImage = value;
    if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
      model.el.appendChild(model.bgImage);
    } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
      model.el.removeChild(model.bgImage);
    }
  };
  function getCanvasDataURL() {
    var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.imageFormat;
    var temporaryCanvas = document.createElement("canvas");
    var temporaryContext = temporaryCanvas.getContext("2d");
    temporaryCanvas.width = model.canvas.width;
    temporaryCanvas.height = model.canvas.height;
    temporaryContext.drawImage(model.canvas, 0, 0);
    var mainBoundingClientRect = model.canvas.getBoundingClientRect();
    var renderWindow = model.renderable;
    var renderers = renderWindow.getRenderers();
    renderers.forEach(function(renderer) {
      var viewProps = renderer.getViewProps();
      viewProps.forEach(function(viewProp) {
        if (viewProp.getContainer) {
          var container = viewProp.getContainer();
          var canvasList = container.getElementsByTagName("canvas");
          for (var i = 0; i < canvasList.length; i++) {
            var currentCanvas = canvasList[i];
            var boundingClientRect = currentCanvas.getBoundingClientRect();
            var newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
            var newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
            temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
          }
        }
      });
    });
    var screenshot = temporaryCanvas.toDataURL(format);
    temporaryCanvas.remove();
    publicAPI.invokeImageReady(screenshot);
  }
  publicAPI.captureNextImage = function() {
    var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png";
    var _ref4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref4$resetCamera = _ref4.resetCamera, resetCamera = _ref4$resetCamera === void 0 ? false : _ref4$resetCamera, _ref4$size = _ref4.size, size = _ref4$size === void 0 ? null : _ref4$size, _ref4$scale = _ref4.scale, scale = _ref4$scale === void 0 ? 1 : _ref4$scale;
    if (model.deleted) {
      return null;
    }
    model.imageFormat = format;
    var previous = model.notifyStartCaptureImage;
    model.notifyStartCaptureImage = true;
    model._screenshot = {
      size: !!size || scale !== 1 ? size || model.size.map(function(val) {
        return val * scale;
      }) : null
    };
    return new Promise(function(resolve, reject) {
      var subscription = publicAPI.onImageReady(function(imageURL) {
        if (model._screenshot.size === null) {
          model.notifyStartCaptureImage = previous;
          subscription.unsubscribe();
          if (model._screenshot.placeHolder) {
            model.size = model._screenshot.originalSize;
            publicAPI.modified();
            if (model._screenshot.cameras) {
              model._screenshot.cameras.forEach(function(_ref5) {
                var restoreParamsFn = _ref5.restoreParamsFn, arg = _ref5.arg;
                return restoreParamsFn(arg);
              });
            }
            publicAPI.traverseAllPasses();
            model.el.removeChild(model._screenshot.placeHolder);
            model._screenshot.placeHolder.remove();
            model._screenshot = null;
          }
          resolve(imageURL);
        } else {
          var tmpImg = document.createElement("img");
          tmpImg.style = SCREENSHOT_PLACEHOLDER;
          tmpImg.src = imageURL;
          model._screenshot.placeHolder = model.el.appendChild(tmpImg);
          model.canvas.style.display = "none";
          model._screenshot.originalSize = model.size;
          model.size = model._screenshot.size;
          model._screenshot.size = null;
          publicAPI.modified();
          if (resetCamera) {
            var isUserResetCamera = resetCamera !== true;
            model._screenshot.cameras = model.renderable.getRenderers().map(function(renderer) {
              var camera = renderer.getActiveCamera();
              var params = camera.get("focalPoint", "position", "parallelScale");
              return {
                resetCameraArgs: isUserResetCamera ? {
                  renderer
                } : void 0,
                resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,
                restoreParamsFn: camera.set,
                arg: JSON.parse(JSON.stringify(params))
              };
            });
            model._screenshot.cameras.forEach(function(_ref6) {
              var resetCameraFn = _ref6.resetCameraFn, resetCameraArgs = _ref6.resetCameraArgs;
              return resetCameraFn(resetCameraArgs);
            });
          }
          publicAPI.traverseAllPasses();
        }
      });
    });
  };
  var hardwareMaximumLineWidth;
  publicAPI.getHardwareMaximumLineWidth = function() {
    if (hardwareMaximumLineWidth != null) {
      return hardwareMaximumLineWidth;
    }
    var gl = publicAPI.get3DContext();
    var lineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
    hardwareMaximumLineWidth = lineWidthRange[1];
    return lineWidthRange[1];
  };
  publicAPI.getGLInformations = function() {
    var gl = publicAPI.get3DContext();
    var glTextureFloat = gl.getExtension("OES_texture_float");
    var glTextureHalfFloat = gl.getExtension("OES_texture_half_float");
    var glDebugRendererInfo = gl.getExtension("WEBGL_debug_renderer_info");
    var glDrawBuffers = gl.getExtension("WEBGL_draw_buffers");
    var glAnisotropic = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
    var params = [["Max Vertex Attributes", "MAX_VERTEX_ATTRIBS", gl.getParameter(gl.MAX_VERTEX_ATTRIBS)], ["Max Varying Vectors", "MAX_VARYING_VECTORS", gl.getParameter(gl.MAX_VARYING_VECTORS)], ["Max Vertex Uniform Vectors", "MAX_VERTEX_UNIFORM_VECTORS", gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS)], ["Max Fragment Uniform Vectors", "MAX_FRAGMENT_UNIFORM_VECTORS", gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)], ["Max Fragment Texture Image Units", "MAX_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)], ["Max Vertex Texture Image Units", "MAX_VERTEX_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)], ["Max Combined Texture Image Units", "MAX_COMBINED_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)], ["Max 2D Texture Size", "MAX_TEXTURE_SIZE", gl.getParameter(gl.MAX_TEXTURE_SIZE)], ["Max Cube Texture Size", "MAX_CUBE_MAP_TEXTURE_SIZE", gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE)], ["Max Texture Anisotropy", "MAX_TEXTURE_MAX_ANISOTROPY_EXT", glAnisotropic && gl.getParameter(glAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)], ["Point Size Range", "ALIASED_POINT_SIZE_RANGE", gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE).join(" - ")], ["Line Width Range", "ALIASED_LINE_WIDTH_RANGE", gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE).join(" - ")], ["Max Viewport Dimensions", "MAX_VIEWPORT_DIMS", gl.getParameter(gl.MAX_VIEWPORT_DIMS).join(" - ")], ["Max Renderbuffer Size", "MAX_RENDERBUFFER_SIZE", gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)], ["Framebuffer Red Bits", "RED_BITS", gl.getParameter(gl.RED_BITS)], ["Framebuffer Green Bits", "GREEN_BITS", gl.getParameter(gl.GREEN_BITS)], ["Framebuffer Blue Bits", "BLUE_BITS", gl.getParameter(gl.BLUE_BITS)], ["Framebuffer Alpha Bits", "ALPHA_BITS", gl.getParameter(gl.ALPHA_BITS)], ["Framebuffer Depth Bits", "DEPTH_BITS", gl.getParameter(gl.DEPTH_BITS)], ["Framebuffer Stencil Bits", "STENCIL_BITS", gl.getParameter(gl.STENCIL_BITS)], ["Framebuffer Subpixel Bits", "SUBPIXEL_BITS", gl.getParameter(gl.SUBPIXEL_BITS)], ["MSAA Samples", "SAMPLES", gl.getParameter(gl.SAMPLES)], ["MSAA Sample Buffers", "SAMPLE_BUFFERS", gl.getParameter(gl.SAMPLE_BUFFERS)], ["Supported Formats for UByte Render Targets     ", "UNSIGNED_BYTE RENDER TARGET FORMATS", [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.UNSIGNED_BYTE) ? "RGBA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.UNSIGNED_BYTE) ? "RGB" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.UNSIGNED_BYTE) ? "LUMINANCE" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.UNSIGNED_BYTE) ? "ALPHA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Supported Formats for Half Float Render Targets", "HALF FLOAT RENDER TARGET FORMATS", [glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGBA, glTextureHalfFloat.HALF_FLOAT_OES) ? "RGBA" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGB, glTextureHalfFloat.HALF_FLOAT_OES) ? "RGB" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, glTextureHalfFloat.HALF_FLOAT_OES) ? "LUMINANCE" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? "ALPHA" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Supported Formats for Full Float Render Targets", "FLOAT RENDER TARGET FORMATS", [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.FLOAT) ? "RGBA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.FLOAT) ? "RGB" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.FLOAT) ? "LUMINANCE" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.FLOAT) ? "ALPHA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.FLOAT) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Max Multiple Render Targets Buffers", "MAX_DRAW_BUFFERS_WEBGL", glDrawBuffers ? gl.getParameter(glDrawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 0], ["High Float Precision in Vertex Shader", "HIGH_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMax, "</sup>)"].join("")], ["Medium Float Precision in Vertex Shader", "MEDIUM_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMax, "</sup>)"].join("")], ["Low Float Precision in Vertex Shader", "LOW_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMax, "</sup>)"].join("")], ["High Float Precision in Fragment Shader", "HIGH_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMax, "</sup>)"].join("")], ["Medium Float Precision in Fragment Shader", "MEDIUM_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMax, "</sup>)"].join("")], ["Low Float Precision in Fragment Shader", "LOW_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMax, "</sup>)"].join("")], ["High Int Precision in Vertex Shader", "HIGH_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMax, "</sup>)"].join("")], ["Medium Int Precision in Vertex Shader", "MEDIUM_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMax, "</sup>)"].join("")], ["Low Int Precision in Vertex Shader", "LOW_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMax, "</sup>)"].join("")], ["High Int Precision in Fragment Shader", "HIGH_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMax, "</sup>)"].join("")], ["Medium Int Precision in Fragment Shader", "MEDIUM_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMax, "</sup>)"].join("")], ["Low Int Precision in Fragment Shader", "LOW_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMax, "</sup>)"].join("")], ["Supported Extensions", "EXTENSIONS", gl.getSupportedExtensions().join("<br/>					    ")], ["WebGL Renderer", "RENDERER", gl.getParameter(gl.RENDERER)], ["WebGL Vendor", "VENDOR", gl.getParameter(gl.VENDOR)], ["WebGL Version", "VERSION", gl.getParameter(gl.VERSION)], ["Shading Language Version", "SHADING_LANGUAGE_VERSION", gl.getParameter(gl.SHADING_LANGUAGE_VERSION)], ["Unmasked Renderer", "UNMASKED_RENDERER", glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_RENDERER_WEBGL)], ["Unmasked Vendor", "UNMASKED_VENDOR", glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_VENDOR_WEBGL)], ["WebGL Version", "WEBGL_VERSION", model.webgl2 ? 2 : 1]];
    var result = {};
    while (params.length) {
      var _params$pop = params.pop(), _params$pop2 = _slicedToArray(_params$pop, 3), label = _params$pop2[0], key = _params$pop2[1], value = _params$pop2[2];
      if (key) {
        result[key] = {
          label,
          value
        };
      }
    }
    return result;
  };
  publicAPI.traverseAllPasses = function() {
    if (model.renderPasses) {
      for (var index = 0; index < model.renderPasses.length; ++index) {
        model.renderPasses[index].traverse(publicAPI, null);
      }
    }
    if (model.notifyStartCaptureImage) {
      getCanvasDataURL();
    }
  };
  publicAPI.disableCullFace = function() {
    if (model.cullFaceEnabled) {
      model.context.disable(model.context.CULL_FACE);
      model.cullFaceEnabled = false;
    }
  };
  publicAPI.enableCullFace = function() {
    if (!model.cullFaceEnabled) {
      model.context.enable(model.context.CULL_FACE);
      model.cullFaceEnabled = true;
    }
  };
  publicAPI.setViewStream = function(stream) {
    if (model.viewStream === stream) {
      return false;
    }
    if (model.subscription) {
      model.subscription.unsubscribe();
      model.subscription = null;
    }
    model.viewStream = stream;
    if (model.viewStream) {
      var mainRenderer = model.renderable.getRenderers()[0];
      mainRenderer.getBackgroundByReference()[3] = 0;
      publicAPI.setUseBackgroundImage(true);
      model.subscription = model.viewStream.onImageReady(function(e) {
        return publicAPI.setBackgroundImage(e.image);
      });
      model.viewStream.setSize(model.size[0], model.size[1]);
      model.viewStream.invalidateCache();
      model.viewStream.render();
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.createSelector = function() {
    var ret = vtkHardwareSelector2.newInstance();
    ret.setOpenGLRenderWindow(publicAPI);
    return ret;
  };
  publicAPI.delete = macro.chain(publicAPI.delete, publicAPI.setViewStream, deleteGLContext);
}
var DEFAULT_VALUES10 = {
  cullFaceEnabled: false,
  shaderCache: null,
  initialized: false,
  context: null,
  canvas: null,
  cursorVisibility: true,
  cursor: "pointer",
  textureUnitManager: null,
  textureResourceIds: null,
  containerSize: null,
  renderPasses: [],
  notifyStartCaptureImage: false,
  webgl2: false,
  defaultToWebgl2: true,
  activeFramebuffer: null,
  xrSession: null,
  xrSessionIsAR: false,
  xrReferenceSpace: null,
  xrSupported: true,
  imageFormat: "image/png",
  useOffScreen: false,
  useBackgroundImage: false
};
function extend10(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES10, initialValues);
  vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);
  model.canvas = document.createElement("canvas");
  model.canvas.style.width = "100%";
  createGLContext();
  if (!model.selector) {
    model.selector = vtkHardwareSelector2.newInstance();
    model.selector.setOpenGLRenderWindow(publicAPI);
  }
  model.bgImage = new Image();
  model.bgImage.style.position = "absolute";
  model.bgImage.style.left = "0";
  model.bgImage.style.top = "0";
  model.bgImage.style.width = "100%";
  model.bgImage.style.height = "100%";
  model.bgImage.style.zIndex = "-1";
  model._textureResourceIds = /* @__PURE__ */ new Map();
  model.myFactory = vtkViewNodeFactory.newInstance();
  model.myFactory.registerOverride("vtkRenderWindow", newInstance11);
  model.shaderCache = vtkShaderCache$1.newInstance();
  model.shaderCache.setOpenGLRenderWindow(publicAPI);
  model.renderPasses[0] = vtkForwardPass$1.newInstance();
  macro.event(publicAPI, model, "imageReady");
  macro.event(publicAPI, model, "haveVRDisplay");
  macro.get(publicAPI, model, ["shaderCache", "textureUnitManager", "webgl2", "vrDisplay", "useBackgroundImage", "xrSupported"]);
  macro.setGet(publicAPI, model, [
    "initialized",
    "context",
    "canvas",
    "renderPasses",
    "notifyStartCaptureImage",
    "defaultToWebgl2",
    "cursor",
    "useOffScreen",
    "activeFramebuffer"
  ]);
  macro.setGetArray(publicAPI, model, ["size"], 2);
  vtkOpenGLRenderWindow(publicAPI, model);
}
var newInstance11 = macro.newInstance(extend10, "vtkOpenGLRenderWindow");
registerViewConstructor("WebGL", newInstance11);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/RenderWindow.js
var import_regenerator5 = __toESM(require_regenerator());

// node_modules/@kitware/vtk.js/Rendering/WebGPU/RenderEncoder.js
var forwarded = ["setBindGroup", "setIndexBuffer", "setVertexBuffer", "draw", "drawIndexed"];
function vtkWebGPURenderEncoder(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPURenderEncoder");
  publicAPI.begin = function(encoder) {
    model.drawCallbacks = [];
    model.handle = encoder.beginRenderPass(model.description);
    if (model.label) {
      model.handle.pushDebugGroup(model.label);
    }
  };
  publicAPI.end = function() {
    for (var i2 = 0; i2 < model.drawCallbacks.length; i2++) {
      var pStruct = model.drawCallbacks[i2];
      var pl = pStruct.pipeline;
      publicAPI.setPipeline(pl);
      for (var cb = 0; cb < pStruct.callbacks.length; cb++) {
        pStruct.callbacks[cb](publicAPI);
      }
    }
    if (model.label) {
      model.handle.popDebugGroup();
    }
    model.handle.end();
    model.boundPipeline = null;
  };
  publicAPI.setPipeline = function(pl) {
    if (model.boundPipeline === pl) {
      return;
    }
    model.handle.setPipeline(pl.getHandle());
    var pd = pl.getPipelineDescription();
    if (model.colorTextureViews.length !== pd.fragment.targets.length) {
      console.log("mismatched attachment counts on pipeline ".concat(pd.fragment.targets.length, " while encoder has ").concat(model.colorTextureViews.length));
      console.trace();
    } else {
      for (var i2 = 0; i2 < model.colorTextureViews.length; i2++) {
        var _model$colorTextureVi;
        var fmt = (_model$colorTextureVi = model.colorTextureViews[i2].getTexture()) === null || _model$colorTextureVi === void 0 ? void 0 : _model$colorTextureVi.getFormat();
        if (fmt && fmt !== pd.fragment.targets[i2].format) {
          console.log("mismatched attachments for attachment ".concat(i2, " on pipeline ").concat(pd.fragment.targets[i2].format, " while encoder has ").concat(fmt));
          console.trace();
        }
      }
    }
    if (!model.depthTextureView !== !("depthStencil" in pd)) {
      console.log("mismatched depth attachments");
      console.trace();
    } else if (model.depthTextureView) {
      var _model$depthTextureVi;
      var dfmt = (_model$depthTextureVi = model.depthTextureView.getTexture()) === null || _model$depthTextureVi === void 0 ? void 0 : _model$depthTextureVi.getFormat();
      if (dfmt && dfmt !== pd.depthStencil.format) {
        console.log("mismatched depth attachments on pipeline ".concat(pd.depthStencil.format, " while encoder has ").concat(dfmt));
        console.trace();
      }
    }
    model.boundPipeline = pl;
  };
  publicAPI.replaceShaderCode = function(pipeline) {
    model.replaceShaderCodeFunction(pipeline);
  };
  publicAPI.setColorTextureView = function(idx, view) {
    if (model.colorTextureViews[idx] === view) {
      return;
    }
    model.colorTextureViews[idx] = view;
  };
  publicAPI.activateBindGroup = function(bg) {
    var device = model.boundPipeline.getDevice();
    var midx = model.boundPipeline.getBindGroupLayoutCount(bg.getLabel());
    model.handle.setBindGroup(midx, bg.getBindGroup(device));
    var bgl1 = device.getBindGroupLayoutDescription(bg.getBindGroupLayout(device));
    var bgl2 = device.getBindGroupLayoutDescription(model.boundPipeline.getBindGroupLayout(midx));
    if (bgl1 !== bgl2) {
      console.log("renderEncoder ".concat(model.pipelineHash, " mismatched bind group layouts bind group has\n").concat(bgl1, "\n versus pipeline\n").concat(bgl2, "\n"));
      console.trace();
    }
  };
  publicAPI.attachTextureViews = function() {
    for (var i2 = 0; i2 < model.colorTextureViews.length; i2++) {
      if (!model.description.colorAttachments[i2]) {
        model.description.colorAttachments[i2] = {
          view: model.colorTextureViews[i2].getHandle()
        };
      } else {
        model.description.colorAttachments[i2].view = model.colorTextureViews[i2].getHandle();
      }
    }
    if (model.depthTextureView) {
      model.description.depthStencilAttachment.view = model.depthTextureView.getHandle();
    }
  };
  publicAPI.registerDrawCallback = function(pipeline, cb) {
    for (var i2 = 0; i2 < model.drawCallbacks.length; i2++) {
      if (model.drawCallbacks[i2].pipeline === pipeline) {
        model.drawCallbacks[i2].callbacks.push(cb);
        return;
      }
    }
    model.drawCallbacks.push({
      pipeline,
      callbacks: [cb]
    });
  };
  var _loop = function _loop2(i2) {
    publicAPI[forwarded[i2]] = function() {
      var _model$handle;
      return (_model$handle = model.handle)[forwarded[i2]].apply(_model$handle, arguments);
    };
  };
  for (var i = 0; i < forwarded.length; i++) {
    _loop(i);
  }
}
var DEFAULT_VALUES11 = {
  description: null,
  handle: null,
  boundPipeline: null,
  pipelineHash: null,
  pipelineSettings: null,
  replaceShaderCodeFunction: null,
  depthTextureView: null,
  label: null
};
function extend11(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES11, initialValues);
  obj(publicAPI, model);
  model.description = {
    colorAttachments: [{
      view: void 0,
      loadOp: "load",
      storeOp: "store"
    }],
    depthStencilAttachment: {
      view: void 0,
      depthLoadOp: "clear",
      depthClearValue: 0,
      depthStoreOp: "store"
    }
  };
  model.replaceShaderCodeFunction = function(pipeline) {
    var fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addOutput("vec4<f32>", "outColor");
    var code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = computedColor;"]).result;
    fDesc.setCode(code);
  };
  model.pipelineSettings = {
    primitive: {
      cullMode: "none"
    },
    depthStencil: {
      depthWriteEnabled: true,
      depthCompare: "greater-equal",
      format: "depth32float"
    },
    fragment: {
      targets: [{
        format: "rgba16float",
        blend: {
          color: {
            srcFactor: "src-alpha",
            dstFactor: "one-minus-src-alpha"
          },
          alpha: {
            srcfactor: "one",
            dstFactor: "one-minus-src-alpha"
          }
        }
      }]
    }
  };
  model.colorTextureViews = [];
  get(publicAPI, model, ["boundPipeline", "colorTextureViews"]);
  setGet(publicAPI, model, ["depthTextureView", "description", "handle", "label", "pipelineHash", "pipelineSettings", "replaceShaderCodeFunction"]);
  vtkWebGPURenderEncoder(publicAPI, model);
}
var newInstance12 = newInstance(extend11, "vtkWebGPURenderEncoder");
var vtkWebGPURenderEncoder$1 = {
  newInstance: newInstance12,
  extend: extend11
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/OpaquePass.js
function vtkWebGPUOpaquePass(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUOpaquePass");
  publicAPI.traverse = function(renNode, viewNode) {
    if (model.deleted) {
      return;
    }
    model.currentParent = viewNode;
    var device = viewNode.getDevice();
    if (!model.renderEncoder) {
      publicAPI.createRenderEncoder();
      model.colorTexture = vtkWebGPUTexture$1.newInstance({
        label: "opaquePassColor"
      });
      model.colorTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "rgba16float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
      });
      var ctView = model.colorTexture.createView("opaquePassColorTexture");
      model.renderEncoder.setColorTextureView(0, ctView);
      model.depthFormat = "depth32float";
      model.depthTexture = vtkWebGPUTexture$1.newInstance({
        label: "opaquePassDepth"
      });
      model.depthTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: model.depthFormat,
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
      });
      var dView = model.depthTexture.createView("opaquePassDepthTexture");
      model.renderEncoder.setDepthTextureView(dView);
    } else {
      model.colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
      model.depthTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
    }
    model.renderEncoder.attachTextureViews();
    publicAPI.setCurrentOperation("opaquePass");
    renNode.setRenderEncoder(model.renderEncoder);
    renNode.traverse(publicAPI);
  };
  publicAPI.getColorTextureView = function() {
    return model.renderEncoder.getColorTextureViews()[0];
  };
  publicAPI.getDepthTextureView = function() {
    return model.renderEncoder.getDepthTextureView();
  };
  publicAPI.createRenderEncoder = function() {
    model.renderEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "OpaquePass"
    });
    model.renderEncoder.setPipelineHash("op");
  };
}
var DEFAULT_VALUES12 = {
  renderEncoder: null,
  colorTexture: null,
  depthTexture: null
};
function extend12(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES12, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["colorTexture", "depthTexture"]);
  vtkWebGPUOpaquePass(publicAPI, model);
}
var newInstance13 = macro.newInstance(extend12, "vtkWebGPUOpaquePass");
var vtkWebGPUOpaquePass$1 = {
  newInstance: newInstance13,
  extend: extend12
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/OrderIndependentTranslucentPass.js
var oitpFragTemplate2 = "\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";
function vtkWebGPUOrderIndependentTranslucentPass(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass");
  publicAPI.traverse = function(renNode, viewNode) {
    if (model.deleted) {
      return;
    }
    model.currentParent = viewNode;
    var device = viewNode.getDevice();
    if (!model.translucentRenderEncoder) {
      publicAPI.createRenderEncoder();
      publicAPI.createFinalEncoder();
      model.translucentColorTexture = vtkWebGPUTexture$1.newInstance({
        label: "translucentPassColor"
      });
      model.translucentColorTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "rgba16float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      var v1 = model.translucentColorTexture.createView("oitpColorTexture");
      model.translucentRenderEncoder.setColorTextureView(0, v1);
      model.translucentAccumulateTexture = vtkWebGPUTexture$1.newInstance({
        label: "translucentPassAccumulate"
      });
      model.translucentAccumulateTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "r16float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      var v2 = model.translucentAccumulateTexture.createView("oitpAccumTexture");
      model.translucentRenderEncoder.setColorTextureView(1, v2);
      model.fullScreenQuad = vtkWebGPUFullScreenQuad$1.newInstance();
      model.fullScreenQuad.setDevice(viewNode.getDevice());
      model.fullScreenQuad.setPipelineHash("oitpfsq");
      model.fullScreenQuad.setTextureViews(model.translucentRenderEncoder.getColorTextureViews());
      model.fullScreenQuad.setFragmentShaderTemplate(oitpFragTemplate2);
    } else {
      model.translucentColorTexture.resizeToMatch(model.colorTextureView.getTexture());
      model.translucentAccumulateTexture.resizeToMatch(model.colorTextureView.getTexture());
    }
    model.translucentRenderEncoder.setDepthTextureView(model.depthTextureView);
    model.translucentRenderEncoder.attachTextureViews();
    publicAPI.setCurrentOperation("translucentPass");
    renNode.setRenderEncoder(model.translucentRenderEncoder);
    renNode.traverse(publicAPI);
    publicAPI.finalPass(viewNode, renNode);
  };
  publicAPI.finalPass = function(viewNode, renNode) {
    model.translucentFinalEncoder.setColorTextureView(0, model.colorTextureView);
    model.translucentFinalEncoder.attachTextureViews();
    model.translucentFinalEncoder.begin(viewNode.getCommandEncoder());
    renNode.scissorAndViewport(model.translucentFinalEncoder);
    model.fullScreenQuad.prepareAndDraw(model.translucentFinalEncoder);
    model.translucentFinalEncoder.end();
  };
  publicAPI.getTextures = function() {
    return [model.translucentColorTexture, model.translucentAccumulateTexture];
  };
  publicAPI.createRenderEncoder = function() {
    model.translucentRenderEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "translucentRender"
    });
    var rDesc = model.translucentRenderEncoder.getDescription();
    rDesc.colorAttachments = [{
      view: void 0,
      clearValue: [0, 0, 0, 0],
      loadOp: "clear",
      storeOp: "store"
    }, {
      view: void 0,
      clearValue: [1, 0, 0, 0],
      loadOp: "clear",
      storeOp: "store"
    }];
    rDesc.depthStencilAttachment = {
      view: void 0,
      depthLoadOp: "load",
      depthStoreOp: "store"
    };
    model.translucentRenderEncoder.setReplaceShaderCodeFunction(function(pipeline) {
      var fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<f32>", "outColor");
      fDesc.addOutput("f32", "outAccum");
      fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
      var code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", [
        "var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);",
        "output.outColor = vec4<f32>(computedColor.rgb*w, w);",
        "output.outAccum = computedColor.a;"
      ]).result;
      fDesc.setCode(code);
    });
    model.translucentRenderEncoder.setPipelineHash("oitpr");
    model.translucentRenderEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: "greater",
        format: "depth32float"
      },
      fragment: {
        targets: [{
          format: "rgba16float",
          blend: {
            color: {
              srcFactor: "one",
              dstFactor: "one"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one"
            }
          }
        }, {
          format: "r16float",
          blend: {
            color: {
              srcFactor: "zero",
              dstFactor: "one-minus-src"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
  publicAPI.createFinalEncoder = function() {
    model.translucentFinalEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "translucentFinal"
    });
    model.translucentFinalEncoder.setDescription({
      colorAttachments: [{
        view: null,
        loadOp: "load",
        storeOp: "store"
      }]
    });
    model.translucentFinalEncoder.setReplaceShaderCodeFunction(function(pipeline) {
      var fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<f32>", "outColor");
      fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
      var code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result;
      fDesc.setCode(code);
    });
    model.translucentFinalEncoder.setPipelineHash("oitpf");
    model.translucentFinalEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "rgba16float",
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
}
var DEFAULT_VALUES13 = {
  colorTextureView: null,
  depthTextureView: null
};
function extend13(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES13, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["colorTextureView", "depthTextureView"]);
  vtkWebGPUOrderIndependentTranslucentPass(publicAPI, model);
}
var newInstance14 = macro.newInstance(extend13, "vtkWebGPUOrderIndependentTranslucentPass");
var vtkWebGPUOrderIndepenentTranslucentPass = {
  newInstance: newInstance14,
  extend: extend13
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/VolumePassFSQ.js
var volFragTemplate = "\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n";
var tmpMat4 = new Float64Array(16);
var tmp2Mat4 = new Float64Array(16);
function vtkWebGPUVolumePassFSQ(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVolumePassFSQ");
  publicAPI.replaceShaderPosition = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);", "output.Position = vec4<f32>(vertexBC, 1.0);"]).result;
    vDesc.setCode(code);
    var fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderVolume = function(hash, pipeline, vertexInput) {
    var fDesc = pipeline.getShaderDescription("fragment");
    var code = fDesc.getCode();
    var compositeCalls = [];
    var traverseCalls = [];
    for (var i = 0; i < model.volumes.length; i++) {
      var blendMode = model.volumes[i].getRenderable().getMapper().getBlendMode();
      if (blendMode === BlendMode.COMPOSITE_BLEND) {
        compositeCalls.push("    sampleColor = processVolume(volTexture".concat(i, ", ").concat(i, ", ").concat(model.rowStarts[i], ", rayPosSC, tfunRows);"));
        compositeCalls.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);");
      } else {
        traverseCalls.push("  sampleColor = traverseVals[".concat(i, "];"));
        traverseCalls.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);");
      }
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::CompositeCalls", compositeCalls).result;
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::TraverseCalls", traverseCalls).result;
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::TraverseDec", ["var<private> traverseVals: array<vec4<f32>,".concat(model.volumes.length, ">;")]).result;
    var compositeWhileTraversing = false;
    for (var vidx = 0; vidx < model.volumes.length; vidx++) {
      var _blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();
      if (_blendMode === BlendMode.COMPOSITE_BLEND) {
        compositeWhileTraversing = true;
      } else if (_blendMode === BlendMode.MAXIMUM_INTENSITY_BLEND) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", ["    traverseMax(volTexture".concat(vidx, ", ").concat(vidx, ", ").concat(vidx, ", rayLengthSC, minPosSC, rayStepSC);"), "    computedColor = traverseVals[".concat(vidx, "];"), "//VTK::Volume::Loop"]).result;
      } else if (_blendMode === BlendMode.MINIMUM_INTENSITY_BLEND) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", ["    traverseMin(volTexture".concat(vidx, ", ").concat(vidx, ", ").concat(vidx, ", rayLengthSC, minPosSC, rayStepSC);"), "    computedColor = traverseVals[".concat(vidx, "];"), "//VTK::Volume::Loop"]).result;
      } else if (_blendMode === BlendMode.AVERAGE_INTENSITY_BLEND) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", ["    traverseAverage(volTexture".concat(vidx, ", ").concat(vidx, ", ").concat(vidx, ", rayLengthSC, minPosSC, rayStepSC);"), "    computedColor = traverseVals[".concat(vidx, "];"), "//VTK::Volume::Loop"]).result;
      } else if (_blendMode === BlendMode.ADDITIVE_INTENSITY_BLEND) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", ["    traverseAdditive(volTexture".concat(vidx, ", ").concat(vidx, ", ").concat(vidx, ", rayLengthSC, minPosSC, rayStepSC);"), "    computedColor = traverseVals[".concat(vidx, "];"), "//VTK::Volume::Loop"]).result;
      }
    }
    if (compositeWhileTraversing) {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Volume::Loop", ["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result;
    }
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderVolume", publicAPI.replaceShaderVolume);
  publicAPI.updateLUTImage = function(device) {
    var mtime = publicAPI.getMTime();
    for (var i = 0; i < model.volumes.length; i++) {
      var vol = model.volumes[i].getRenderable();
      var image = vol.getMapper().getInputData();
      mtime = Math.max(mtime, vol.getMTime(), image.getMTime());
    }
    if (mtime < model.lutBuildTime.getMTime()) {
      return;
    }
    model.numRows = 0;
    model.rowStarts = [];
    for (var vidx = 0; vidx < model.volumes.length; vidx++) {
      model.rowStarts.push(model.numRows);
      var webgpuvol = model.volumes[vidx];
      var actor = webgpuvol.getRenderable();
      var volMapr = actor.getMapper();
      var vprop = actor.getProperty();
      var _image = volMapr.getInputData();
      var scalars = _image.getPointData() && _image.getPointData().getScalars();
      var numComp = scalars.getNumberOfComponents();
      var iComps = vprop.getIndependentComponents();
      var numIComps = iComps ? numComp : 1;
      model.numRows += numIComps;
    }
    var colorArray = new Uint8Array(model.numRows * 2 * model.rowLength * 4);
    var opacityArray = new Float32Array(model.numRows * 2 * model.rowLength);
    var imgRow = 0;
    var tmpTable = new Float32Array(model.rowLength * 3);
    var rowLength = model.rowLength;
    for (var _vidx = 0; _vidx < model.volumes.length; _vidx++) {
      var _webgpuvol = model.volumes[_vidx];
      var _actor = _webgpuvol.getRenderable();
      var _volMapr = _actor.getMapper();
      var _vprop = _actor.getProperty();
      var _image2 = _volMapr.getInputData();
      var _scalars = _image2.getPointData() && _image2.getPointData().getScalars();
      var _numComp = _scalars.getNumberOfComponents();
      var _iComps = _vprop.getIndependentComponents();
      var _numIComps = _iComps ? _numComp : 1;
      for (var c = 0; c < _numIComps; ++c) {
        var cfun = _vprop.getRGBTransferFunction(c);
        var cRange = cfun.getRange();
        cfun.getTable(cRange[0], cRange[1], rowLength, tmpTable, 1);
        var ioffset = imgRow * rowLength * 4;
        for (var _i = 0; _i < rowLength; ++_i) {
          colorArray[ioffset + _i * 4] = 255 * tmpTable[_i * 3];
          colorArray[ioffset + _i * 4 + 1] = 255 * tmpTable[_i * 3 + 1];
          colorArray[ioffset + _i * 4 + 2] = 255 * tmpTable[_i * 3 + 2];
          colorArray[ioffset + _i * 4 + 3] = 255;
          for (var co = 0; co < 4; co++) {
            colorArray[ioffset + (rowLength + _i) * 4 + co] = colorArray[ioffset + _i * 4 + co];
          }
        }
        var ofun = _vprop.getScalarOpacity(c);
        var opacityFactor = model.sampleDist / _vprop.getScalarOpacityUnitDistance(c);
        var oRange = ofun.getRange();
        ofun.getTable(oRange[0], oRange[1], rowLength, tmpTable, 1);
        ioffset = imgRow * rowLength;
        for (var _i2 = 0; _i2 < rowLength; ++_i2) {
          opacityArray[ioffset + _i2] = 1 - Math.pow(1 - tmpTable[_i2], opacityFactor);
          opacityArray[ioffset + _i2 + rowLength] = opacityArray[ioffset + _i2];
        }
        imgRow += 2;
      }
    }
    {
      var treq = {
        nativeArray: colorArray,
        width: model.rowLength,
        height: model.numRows * 2,
        depth: 1,
        format: "rgba8unorm"
      };
      var newTex = device.getTextureManager().getTexture(treq);
      var tview = newTex.createView("tfunTexture");
      model.textureViews[2] = tview;
    }
    {
      var _treq = {
        nativeArray: opacityArray,
        width: model.rowLength,
        height: model.numRows * 2,
        depth: 1,
        format: "r16float"
      };
      var _newTex = device.getTextureManager().getTexture(_treq);
      var _tview = _newTex.createView("ofunTexture");
      model.textureViews[3] = _tview;
    }
    model.lutBuildTime.modified();
  };
  publicAPI.updateSSBO = function(device) {
    var mtime = Math.max(publicAPI.getMTime(), model.WebGPURenderer.getStabilizedTime());
    for (var i = 0; i < model.volumes.length; i++) {
      var vol = model.volumes[i].getRenderable();
      var volMapr = vol.getMapper();
      var image = volMapr.getInputData();
      mtime = Math.max(mtime, vol.getMTime(), image.getMTime(), volMapr.getMTime());
    }
    if (mtime < model.SSBO.getSendTime()) {
      return;
    }
    var center = model.WebGPURenderer.getStabilizedCenterByReference();
    model.SSBO.clearData();
    model.SSBO.setNumberOfInstances(model.volumes.length);
    var marray = new Float64Array(model.volumes.length * 16);
    var vPlaneArray = new Float64Array(model.volumes.length * 16);
    var tstepArray = new Float64Array(model.volumes.length * 4);
    var shadeArray = new Float64Array(model.volumes.length * 4);
    var spacingArray = new Float64Array(model.volumes.length * 4);
    var ipScalarRangeArray = new Float64Array(model.volumes.length * 4);
    for (var vidx = 0; vidx < model.volumes.length; vidx++) {
      var webgpuvol = model.volumes[vidx];
      var actor = webgpuvol.getRenderable();
      var _volMapr2 = actor.getMapper();
      var _image3 = _volMapr2.getInputData();
      mat4_exports.identity(tmpMat4);
      mat4_exports.translate(tmpMat4, tmpMat4, center);
      var mcwcmat = actor.getMatrix();
      mat4_exports.transpose(tmp2Mat4, mcwcmat);
      mat4_exports.invert(tmp2Mat4, tmp2Mat4);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      var modelToIndex = _image3.getWorldToIndex();
      mat4_exports.multiply(tmpMat4, modelToIndex, tmpMat4);
      var dims = _image3.getDimensions();
      mat4_exports.identity(tmp2Mat4);
      mat4_exports.scale(tmp2Mat4, tmp2Mat4, [1 / dims[0], 1 / dims[1], 1 / dims[2]]);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      for (var j = 0; j < 16; j++) {
        marray[vidx * 16 + j] = tmpMat4[j];
      }
      mat4_exports.invert(tmpMat4, tmpMat4);
      for (var _j = 0; _j < 4; _j++) {
        vPlaneArray[vidx * 16 + _j * 4] = tmpMat4[_j * 4];
        vPlaneArray[vidx * 16 + _j * 4 + 1] = tmpMat4[_j * 4 + 1];
        vPlaneArray[vidx * 16 + _j * 4 + 2] = tmpMat4[_j * 4 + 2];
        vPlaneArray[vidx * 16 + _j * 4 + 3] = 0;
      }
      tstepArray[vidx * 4] = 1 / dims[0];
      tstepArray[vidx * 4 + 1] = 1 / dims[1];
      tstepArray[vidx * 4 + 2] = 1 / dims[2];
      tstepArray[vidx * 4 + 3] = 1;
      shadeArray[vidx * 4] = actor.getProperty().getShade() ? 1 : 0;
      var spacing = _image3.getSpacing();
      spacingArray[vidx * 4] = spacing[0];
      spacingArray[vidx * 4 + 1] = spacing[1];
      spacingArray[vidx * 4 + 2] = spacing[2];
      spacingArray[vidx * 4 + 3] = 1;
      var tScale = model.textureViews[vidx + 4].getTexture().getScale();
      var ipScalarRange = _volMapr2.getIpScalarRange();
      ipScalarRangeArray[vidx * 4] = ipScalarRange[0] / tScale;
      ipScalarRangeArray[vidx * 4 + 1] = ipScalarRange[1] / tScale;
      ipScalarRangeArray[vidx * 4 + 2] = _volMapr2.getFilterMode();
    }
    model.SSBO.addEntry("SCTCMatrix", "mat4x4<f32>");
    model.SSBO.addEntry("planeNormals", "mat4x4<f32>");
    model.SSBO.addEntry("shade", "vec4<f32>");
    model.SSBO.addEntry("tstep", "vec4<f32>");
    model.SSBO.addEntry("spacing", "vec4<f32>");
    model.SSBO.addEntry("ipScalarRange", "vec4<f32>");
    model.SSBO.setAllInstancesFromArray("SCTCMatrix", marray);
    model.SSBO.setAllInstancesFromArray("planeNormals", vPlaneArray);
    model.SSBO.setAllInstancesFromArray("shade", shadeArray);
    model.SSBO.setAllInstancesFromArray("tstep", tstepArray);
    model.SSBO.setAllInstancesFromArray("spacing", spacingArray);
    model.SSBO.setAllInstancesFromArray("ipScalarRange", ipScalarRangeArray);
    model.SSBO.send(device);
    model.componentSSBO.clearData();
    model.componentSSBO.setNumberOfInstances(model.numRows);
    var cScaleArray = new Float64Array(model.numRows);
    var cShiftArray = new Float64Array(model.numRows);
    var oScaleArray = new Float64Array(model.numRows);
    var oShiftArray = new Float64Array(model.numRows);
    var gominArray = new Float64Array(model.numRows);
    var gomaxArray = new Float64Array(model.numRows);
    var goshiftArray = new Float64Array(model.numRows);
    var goscaleArray = new Float64Array(model.numRows);
    var rowIdx = 0;
    for (var _vidx2 = 0; _vidx2 < model.volumes.length; _vidx2++) {
      var _webgpuvol2 = model.volumes[_vidx2];
      var _actor2 = _webgpuvol2.getRenderable();
      var _volMapr3 = _actor2.getMapper();
      var vprop = _actor2.getProperty();
      var _image4 = _volMapr3.getInputData();
      var scalars = _image4.getPointData() && _image4.getPointData().getScalars();
      var numComp = scalars.getNumberOfComponents();
      var iComps = vprop.getIndependentComponents();
      var tformat = model.textureViews[_vidx2 + 4].getTexture().getFormat();
      var tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(tformat);
      var halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
      var volInfo = {
        scale: [255],
        offset: [0]
      };
      if (halfFloat) {
        volInfo.scale[0] = 1;
      }
      for (var compIdx = 0; compIdx < numComp; compIdx++) {
        var target = iComps ? compIdx : 0;
        var sscale = volInfo.scale[compIdx];
        var ofun = vprop.getScalarOpacity(target);
        var oRange = ofun.getRange();
        var oscale = sscale / (oRange[1] - oRange[0]);
        var oshift = (volInfo.offset[compIdx] - oRange[0]) / (oRange[1] - oRange[0]);
        oShiftArray[rowIdx] = oshift;
        oScaleArray[rowIdx] = oscale;
        var cfun = vprop.getRGBTransferFunction(target);
        var cRange = cfun.getRange();
        cShiftArray[rowIdx] = (volInfo.offset[compIdx] - cRange[0]) / (cRange[1] - cRange[0]);
        cScaleArray[rowIdx] = sscale / (cRange[1] - cRange[0]);
        var useGO = vprop.getUseGradientOpacity(target);
        if (useGO) {
          var gomin = vprop.getGradientOpacityMinimumOpacity(target);
          var gomax = vprop.getGradientOpacityMaximumOpacity(target);
          gominArray[rowIdx] = gomin;
          gomaxArray[rowIdx] = gomax;
          var goRange = [vprop.getGradientOpacityMinimumValue(target), vprop.getGradientOpacityMaximumValue(target)];
          goscaleArray[rowIdx] = sscale * (gomax - gomin) / (goRange[1] - goRange[0]);
          goshiftArray[rowIdx] = -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin;
        } else {
          gominArray[rowIdx] = 1;
          gomaxArray[rowIdx] = 1;
          goscaleArray[rowIdx] = 0;
          goshiftArray[rowIdx] = 1;
        }
        rowIdx++;
      }
    }
    model.componentSSBO.addEntry("cScale", "f32");
    model.componentSSBO.addEntry("cShift", "f32");
    model.componentSSBO.addEntry("oScale", "f32");
    model.componentSSBO.addEntry("oShift", "f32");
    model.componentSSBO.addEntry("goShift", "f32");
    model.componentSSBO.addEntry("goScale", "f32");
    model.componentSSBO.addEntry("gomin", "f32");
    model.componentSSBO.addEntry("gomax", "f32");
    model.componentSSBO.setAllInstancesFromArray("cScale", cScaleArray);
    model.componentSSBO.setAllInstancesFromArray("cShift", cShiftArray);
    model.componentSSBO.setAllInstancesFromArray("oScale", oScaleArray);
    model.componentSSBO.setAllInstancesFromArray("oShift", oShiftArray);
    model.componentSSBO.setAllInstancesFromArray("goScale", goscaleArray);
    model.componentSSBO.setAllInstancesFromArray("goShift", goshiftArray);
    model.componentSSBO.setAllInstancesFromArray("gomin", gominArray);
    model.componentSSBO.setAllInstancesFromArray("gomax", gomaxArray);
    model.componentSSBO.send(device);
  };
  var superClassUpdateBuffers = publicAPI.updateBuffers;
  publicAPI.updateBuffers = function() {
    superClassUpdateBuffers();
    var sampleDist = model.volumes[0].getRenderable().getMapper().getSampleDistance();
    for (var i = 0; i < model.volumes.length; i++) {
      var vol = model.volumes[i];
      var volMapr = vol.getRenderable().getMapper();
      var sd = volMapr.getSampleDistance();
      if (sd < sampleDist) {
        sampleDist = sd;
      }
    }
    if (model.sampleDist !== sampleDist) {
      model.sampleDist = sampleDist;
      model.UBO.setValue("SampleDistance", sampleDist);
      model.UBO.sendIfNeeded(model.device);
    }
    for (var vidx = 0; vidx < model.volumes.length; vidx++) {
      var webgpuvol = model.volumes[vidx];
      var actor = webgpuvol.getRenderable();
      var _volMapr4 = actor.getMapper();
      var image = _volMapr4.getInputData();
      var newTex = model.device.getTextureManager().getTextureForImageData(image);
      if (!model.textureViews[vidx + 4] || model.textureViews[vidx + 4].getTexture() !== newTex) {
        var tview = newTex.createView("volTexture".concat(vidx));
        model.textureViews[vidx + 4] = tview;
      }
    }
    if (model.volumes.length < model.lastVolumeLength) {
      for (var _i3 = model.volumes.length; _i3 < model.lastVolumeLength; _i3++) {
        model.textureViews.pop();
      }
    }
    model.lastVolumeLength = model.volumes.length;
    publicAPI.updateLUTImage(model.device);
    publicAPI.updateSSBO(model.device);
    if (!model.clampSampler) {
      model.clampSampler = vtkWebGPUSampler$1.newInstance({
        label: "clampSampler"
      });
      model.clampSampler.create(model.device, {
        minFilter: "linear",
        magFilter: "linear"
      });
    }
  };
  publicAPI.computePipelineHash = function() {
    model.pipelineHash = "volfsq";
    for (var vidx = 0; vidx < model.volumes.length; vidx++) {
      var blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();
      model.pipelineHash += "".concat(blendMode);
    }
  };
  publicAPI.setVolumes = function(val) {
    if (!model.volumes || model.volumes.length !== val.length) {
      model.volumes = _toConsumableArray(val);
      publicAPI.modified();
      return;
    }
    for (var i = 0; i < val.length; i++) {
      if (val[i] !== model.volumes[i]) {
        model.volumes = _toConsumableArray(val);
        publicAPI.modified();
        return;
      }
    }
  };
  var superclassGetBindables = publicAPI.getBindables;
  publicAPI.getBindables = function() {
    var bindables = superclassGetBindables();
    bindables.push(model.componentSSBO);
    bindables.push(model.clampSampler);
    return bindables;
  };
}
var DEFAULT_VALUES14 = {
  volumes: null,
  rowLength: 1024,
  lastVolumeLength: 0
};
function extend14(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES14, initialValues);
  vtkWebGPUFullScreenQuad$1.extend(publicAPI, model, initialValues);
  model.fragmentShaderTemplate = volFragTemplate;
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "mapperUBO"
  });
  model.UBO.addEntry("SampleDistance", "f32");
  model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "volumeSSBO"
  });
  model.componentSSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "componentSSBO"
  });
  model.lutBuildTime = {};
  macro.obj(model.lutBuildTime, {
    mtime: 0
  });
  vtkWebGPUVolumePassFSQ(publicAPI, model);
}
var newInstance15 = macro.newInstance(extend14, "vtkWebGPUVolumePassFSQ");
var vtkWebGPUVolumePassFSQ$1 = {
  newInstance: newInstance15,
  extend: extend14
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/VolumePass.js
var Representation2 = vtkProperty$1.Representation;
var BufferUsage = vtkWebGPUBufferManager$1.BufferUsage;
var PrimitiveTypes = vtkWebGPUBufferManager$1.PrimitiveTypes;
var cubeFaceTriangles = [[0, 4, 6], [0, 6, 2], [1, 3, 7], [1, 7, 5], [0, 5, 4], [0, 1, 5], [2, 6, 7], [2, 7, 3], [0, 3, 1], [0, 2, 3], [4, 5, 7], [4, 7, 6]];
var DepthBoundsFS = "\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";
var volumeCopyFragTemplate = "\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";
function vtkWebGPUVolumePass(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVolumePass");
  publicAPI.initialize = function(viewNode) {
    if (!model._clearEncoder) {
      publicAPI.createClearEncoder(viewNode);
    }
    if (!model._mergeEncoder) {
      publicAPI.createMergeEncoder(viewNode);
    }
    if (!model._copyEncoder) {
      publicAPI.createCopyEncoder(viewNode);
    }
    if (!model._depthRangeEncoder) {
      publicAPI.createDepthRangeEncoder(viewNode);
    }
    if (!model.fullScreenQuad) {
      model.fullScreenQuad = vtkWebGPUVolumePassFSQ$1.newInstance();
      model.fullScreenQuad.setDevice(viewNode.getDevice());
      model.fullScreenQuad.setTextureViews(_toConsumableArray(model._depthRangeEncoder.getColorTextureViews()));
    }
    if (!model._volumeCopyQuad) {
      model._volumeCopyQuad = vtkWebGPUFullScreenQuad$1.newInstance();
      model._volumeCopyQuad.setPipelineHash("volpassfsq");
      model._volumeCopyQuad.setDevice(viewNode.getDevice());
      model._volumeCopyQuad.setFragmentShaderTemplate(volumeCopyFragTemplate);
      model._copyUBO = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      model._copyUBO.addEntry("tscale", "vec2<f32>");
      model._volumeCopyQuad.setUBO(model._copyUBO);
      model._volumeCopyQuad.setTextureViews([model._colorTextureView]);
    }
  };
  publicAPI.traverse = function(renNode, viewNode) {
    if (model.deleted) {
      return;
    }
    model.currentParent = viewNode;
    publicAPI.initialize(viewNode);
    publicAPI.computeTiming(viewNode);
    publicAPI.renderDepthBounds(renNode, viewNode);
    model._firstGroup = true;
    var device = viewNode.getDevice();
    var maxVolumes = device.getHandle().limits.maxSampledTexturesPerShaderStage - 4;
    if (model.volumes.length > maxVolumes) {
      var cameraPos = renNode.getRenderable().getActiveCamera().getPosition();
      var distances = [];
      for (var v = 0; v < model.volumes.length; v++) {
        var bounds = model.volumes[v].getRenderable().getBounds();
        var centroid = [0.5 * (bounds[1] + bounds[0]), 0.5 * (bounds[3] + bounds[2]), 0.5 * (bounds[5] + bounds[4])];
        distances[v] = distance2BetweenPoints(centroid, cameraPos);
      }
      var volumeOrder = _toConsumableArray(Array(model.volumes.length).keys());
      volumeOrder.sort(function(a, b) {
        return distances[b] - distances[a];
      });
      var volumesToRender = [];
      var chunkSize = volumeOrder.length % maxVolumes;
      for (var _v = 0; _v < volumeOrder.length; _v++) {
        volumesToRender.push(model.volumes[volumeOrder[_v]]);
        if (volumesToRender.length >= chunkSize) {
          publicAPI.rayCastPass(viewNode, renNode, volumesToRender);
          volumesToRender = [];
          chunkSize = maxVolumes;
          model._firstGroup = false;
        }
      }
    } else {
      publicAPI.rayCastPass(viewNode, renNode, model.volumes);
    }
    model._volumeCopyQuad.setWebGPURenderer(renNode);
    if (model._useSmallViewport) {
      var width = model._colorTextureView.getTexture().getWidth();
      var height = model._colorTextureView.getTexture().getHeight();
      model._copyUBO.setArray("tscale", [model._smallViewportWidth / width, model._smallViewportHeight / height]);
    } else {
      model._copyUBO.setArray("tscale", [1, 1]);
    }
    model._copyUBO.sendIfNeeded(device);
    model._copyEncoder.setColorTextureView(0, model.colorTextureView);
    model._copyEncoder.attachTextureViews();
    model._copyEncoder.begin(viewNode.getCommandEncoder());
    renNode.scissorAndViewport(model._copyEncoder);
    model._volumeCopyQuad.prepareAndDraw(model._copyEncoder);
    model._copyEncoder.end();
  };
  publicAPI.delete = macro.chain(function() {
    if (model._animationRateSubscription) {
      model._animationRateSubscription.unsubscribe();
      model._animationRateSubscription = null;
    }
  }, publicAPI.delete);
  publicAPI.computeTiming = function(viewNode) {
    model._useSmallViewport = false;
    var rwi = viewNode.getRenderable().getInteractor();
    if (rwi.isAnimating() && model._lastScale > 1.5) {
      if (!model._smallViewportHeight) {
        model._smallViewportWidth = Math.ceil(viewNode.getCanvas().width / Math.sqrt(model._lastScale));
        model._smallViewportHeight = Math.ceil(viewNode.getCanvas().height / Math.sqrt(model._lastScale));
      }
      model._useSmallViewport = true;
    }
    model._colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
    if (!model._animationRateSubscription) {
      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(function() {
        var firstMapper = model.volumes[0].getRenderable().getMapper();
        if (firstMapper.getAutoAdjustSampleDistances()) {
          var frate = rwi.getRecentAnimationFrameRate();
          var targetScale = model._lastScale * rwi.getDesiredUpdateRate() / frate;
          model._lastScale = targetScale;
          if (model._lastScale > 400) {
            model._lastScale = 400;
          }
        } else {
          model._lastScale = firstMapper.getImageSampleDistance() * firstMapper.getImageSampleDistance();
        }
        if (model._lastScale < 1.5) {
          model._lastScale = 1.5;
        } else {
          model._smallViewportWidth = Math.ceil(viewNode.getCanvas().width / Math.sqrt(model._lastScale));
          model._smallViewportHeight = Math.ceil(viewNode.getCanvas().height / Math.sqrt(model._lastScale));
        }
      });
    }
  };
  publicAPI.rayCastPass = function(viewNode, renNode, volumes) {
    var encoder = model._firstGroup ? model._clearEncoder : model._mergeEncoder;
    encoder.attachTextureViews();
    encoder.begin(viewNode.getCommandEncoder());
    var width = model._colorTextureView.getTexture().getWidth();
    var height = model._colorTextureView.getTexture().getHeight();
    if (model._useSmallViewport) {
      width = model._smallViewportWidth;
      height = model._smallViewportHeight;
    }
    encoder.getHandle().setViewport(0, 0, width, height, 0, 1);
    encoder.getHandle().setScissorRect(0, 0, width, height);
    model.fullScreenQuad.setWebGPURenderer(renNode);
    model.fullScreenQuad.setVolumes(volumes);
    model.fullScreenQuad.prepareAndDraw(encoder);
    encoder.end();
  };
  publicAPI.renderDepthBounds = function(renNode, viewNode) {
    publicAPI.updateDepthPolyData(renNode);
    var pd = model._boundsPoly;
    var points = pd.getPoints();
    var cells = pd.getPolys();
    var buffRequest = {
      hash: "vp".concat(cells.getMTime()),
      usage: BufferUsage.Index,
      cells,
      numberOfPoints: points.getNumberOfPoints(),
      primitiveType: PrimitiveTypes.Triangles,
      representation: Representation2.SURFACE
    };
    var indexBuffer = viewNode.getDevice().getBufferManager().getBuffer(buffRequest);
    model._mapper.getVertexInput().setIndexBuffer(indexBuffer);
    buffRequest = {
      usage: BufferUsage.PointArray,
      format: "float32x4",
      hash: "vp".concat(points.getMTime()).concat(cells.getMTime()),
      dataArray: points,
      indexBuffer,
      packExtra: true
    };
    var buff = viewNode.getDevice().getBufferManager().getBuffer(buffRequest);
    model._mapper.getVertexInput().addBuffer(buff, ["vertexBC"]);
    model._mapper.setNumberOfVertices(buff.getSizeInBytes() / buff.getStrideInBytes());
    publicAPI.drawDepthRange(renNode, viewNode);
  };
  publicAPI.updateDepthPolyData = function(renNode) {
    var update = false;
    for (var i = 0; i < model.volumes.length; i++) {
      var mtime = model.volumes[i].getMTime();
      if (!model._lastMTimes[i] || mtime !== model._lastMTimes[i]) {
        update = true;
        model._lastMTimes[i] = mtime;
      }
    }
    var stime = renNode.getStabilizedTime();
    if (model._lastMTimes.length <= model.volumes.length || stime !== model._lastMTimes[model.volumes.length]) {
      update = true;
      model._lastMTimes[model.volumes.length] = stime;
    }
    if (!update) {
      return;
    }
    var center = renNode.getStabilizedCenterByReference();
    var numPts = model.volumes.length * 8;
    var points = new Float64Array(numPts * 3);
    var numTris = model.volumes.length * 12;
    var polys = new Uint16Array(numTris * 4);
    for (var _i = 0; _i < model.volumes.length; _i++) {
      model.volumes[_i].getBoundingCubePoints(points, _i * 24);
      var cellIdx = _i * 12 * 4;
      var offset = _i * 8;
      for (var t = 0; t < 12; t++) {
        polys[cellIdx++] = 3;
        polys[cellIdx++] = offset + cubeFaceTriangles[t][0];
        polys[cellIdx++] = offset + cubeFaceTriangles[t][1];
        polys[cellIdx++] = offset + cubeFaceTriangles[t][2];
      }
    }
    for (var p = 0; p < points.length; p += 3) {
      points[p] -= center[0];
      points[p + 1] -= center[1];
      points[p + 2] -= center[2];
    }
    model._boundsPoly.getPoints().setData(points, 3);
    model._boundsPoly.getPoints().modified();
    model._boundsPoly.getPolys().setData(polys, 1);
    model._boundsPoly.getPolys().modified();
    model._boundsPoly.modified();
  };
  publicAPI.drawDepthRange = function(renNode, viewNode) {
    model._depthRangeTexture.resizeToMatch(model.colorTextureView.getTexture());
    model._depthRangeTexture2.resizeToMatch(model.colorTextureView.getTexture());
    model._depthRangeEncoder.attachTextureViews();
    publicAPI.setCurrentOperation("volumeDepthRangePass");
    renNode.setRenderEncoder(model._depthRangeEncoder);
    renNode.volumeDepthRangePass(true);
    model._mapper.setWebGPURenderer(renNode);
    model._mapper.prepareToDraw(model._depthRangeEncoder);
    model._mapper.registerDrawCallback(model._depthRangeEncoder);
    renNode.volumeDepthRangePass(false);
  };
  publicAPI.createDepthRangeEncoder = function(viewNode) {
    var device = viewNode.getDevice();
    model._depthRangeEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "VolumePass DepthRange"
    });
    model._depthRangeEncoder.setPipelineHash("volr");
    model._depthRangeEncoder.setReplaceShaderCodeFunction(function(pipeline) {
      var fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<f32>", "outColor1");
      fDesc.addOutput("vec4<f32>", "outColor2");
      var code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);", "output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result;
      fDesc.setCode(code);
    });
    model._depthRangeEncoder.setDescription({
      colorAttachments: [{
        view: null,
        clearValue: [0, 0, 0, 0],
        loadOp: "clear",
        storeOp: "store"
      }, {
        view: null,
        clearValue: [1, 1, 1, 1],
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    model._depthRangeEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "r16float",
          blend: {
            color: {
              srcFactor: "one",
              dstFactor: "one",
              operation: "max"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one",
              operation: "max"
            }
          }
        }, {
          format: "r16float",
          blend: {
            color: {
              srcFactor: "one",
              dstFactor: "one",
              operation: "min"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one",
              operation: "min"
            }
          }
        }]
      }
    });
    model._depthRangeTexture = vtkWebGPUTexture$1.newInstance({
      label: "volumePassMaxDepth"
    });
    model._depthRangeTexture.create(device, {
      width: viewNode.getCanvas().width,
      height: viewNode.getCanvas().height,
      format: "r16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    var maxView = model._depthRangeTexture.createView("maxTexture");
    model._depthRangeEncoder.setColorTextureView(0, maxView);
    model._depthRangeTexture2 = vtkWebGPUTexture$1.newInstance({
      label: "volumePassDepthMin"
    });
    model._depthRangeTexture2.create(device, {
      width: viewNode.getCanvas().width,
      height: viewNode.getCanvas().height,
      format: "r16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    var minView = model._depthRangeTexture2.createView("minTexture");
    model._depthRangeEncoder.setColorTextureView(1, minView);
    model._mapper.setDevice(viewNode.getDevice());
    model._mapper.setTextureViews([model.depthTextureView]);
  };
  publicAPI.createClearEncoder = function(viewNode) {
    model._colorTexture = vtkWebGPUTexture$1.newInstance({
      label: "volumePassColor"
    });
    model._colorTexture.create(viewNode.getDevice(), {
      width: viewNode.getCanvas().width,
      height: viewNode.getCanvas().height,
      format: "bgra8unorm",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
    });
    model._colorTextureView = model._colorTexture.createView("volumePassColorTexture");
    model._colorTextureView.addSampler(viewNode.getDevice(), {
      minFilter: "linear",
      magFilter: "linear"
    });
    model._clearEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "VolumePass Clear"
    });
    model._clearEncoder.setColorTextureView(0, model._colorTextureView);
    model._clearEncoder.setDescription({
      colorAttachments: [{
        view: null,
        clearValue: [0, 0, 0, 0],
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    model._clearEncoder.setPipelineHash("volpf");
    model._clearEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "bgra8unorm",
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
  publicAPI.createCopyEncoder = function(viewNode) {
    model._copyEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "volumePassCopy"
    });
    model._copyEncoder.setDescription({
      colorAttachments: [{
        view: null,
        loadOp: "load",
        storeOp: "store"
      }]
    });
    model._copyEncoder.setPipelineHash("volcopypf");
    model._copyEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "rgba16float",
          blend: {
            color: {
              srcFactor: "one",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
  publicAPI.createMergeEncoder = function(viewNode) {
    model._mergeEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "volumePassMerge"
    });
    model._mergeEncoder.setColorTextureView(0, model._colorTextureView);
    model._mergeEncoder.setDescription({
      colorAttachments: [{
        view: null,
        loadOp: "load",
        storeOp: "store"
      }]
    });
    model._mergeEncoder.setReplaceShaderCodeFunction(function(pipeline) {
      var fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<f32>", "outColor");
      var code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result;
      fDesc.setCode(code);
    });
    model._mergeEncoder.setPipelineHash("volpf");
    model._mergeEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: "bgra8unorm",
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
  };
  publicAPI.setVolumes = function(val) {
    if (!model.volumes || model.volumes.length !== val.length) {
      model.volumes = _toConsumableArray(val);
      publicAPI.modified();
      return;
    }
    for (var i = 0; i < val.length; i++) {
      if (val[i] !== model.volumes[i]) {
        model.volumes = _toConsumableArray(val);
        publicAPI.modified();
        return;
      }
    }
  };
}
var DEFAULT_VALUES15 = {
  colorTextureView: null,
  depthTextureView: null,
  volumes: null
};
function extend15(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES15, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  model._lastScale = 2;
  model._mapper = vtkWebGPUSimpleMapper$1.newInstance();
  model._mapper.setFragmentShaderTemplate(DepthBoundsFS);
  model._mapper.getShaderReplacements().set("replaceShaderVolumePass", function(hash, pipeline, vertexInput) {
    var fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinInput("vec4<f32>", "@builtin(position) fragPos");
  });
  model._boundsPoly = vtkPolyData$1.newInstance();
  model._lastMTimes = [];
  macro.setGet(publicAPI, model, ["colorTextureView", "depthTextureView"]);
  vtkWebGPUVolumePass(publicAPI, model);
}
var newInstance16 = macro.newInstance(extend15, "vtkWebGPUVolumePass");
var vtkWebGPUVolumePass$1 = {
  newInstance: newInstance16,
  extend: extend15
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ForwardPass.js
var finalBlitFragTemplate = "\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";
function vtkForwardPass2(publicAPI, model) {
  model.classHierarchy.push("vtkForwardPass");
  publicAPI.traverse = function(viewNode) {
    var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (model.deleted) {
      return;
    }
    model.currentParent = parent;
    publicAPI.setCurrentOperation("buildPass");
    viewNode.traverse(publicAPI);
    if (!model.opaquePass) {
      model.opaquePass = vtkWebGPUOpaquePass$1.newInstance();
    }
    var numlayers = viewNode.getRenderable().getNumberOfLayers();
    var renderers = viewNode.getChildren();
    for (var i = 0; i < numlayers; i++) {
      for (var index = 0; index < renderers.length; index++) {
        var renNode = renderers[index];
        var ren = viewNode.getRenderable().getRenderers()[index];
        if (ren.getDraw() && ren.getLayer() === i) {
          model.opaqueActorCount = 0;
          model.translucentActorCount = 0;
          model.volumes = [];
          publicAPI.setCurrentOperation("queryPass");
          renNode.traverse(publicAPI);
          publicAPI.setCurrentOperation("cameraPass");
          renNode.traverse(publicAPI);
          model.opaquePass.traverse(renNode, viewNode);
          if (model.translucentActorCount > 0) {
            if (!model.translucentPass) {
              model.translucentPass = vtkWebGPUOrderIndepenentTranslucentPass.newInstance();
            }
            model.translucentPass.setColorTextureView(model.opaquePass.getColorTextureView());
            model.translucentPass.setDepthTextureView(model.opaquePass.getDepthTextureView());
            model.translucentPass.traverse(renNode, viewNode);
          }
          if (model.volumes.length > 0) {
            if (!model.volumePass) {
              model.volumePass = vtkWebGPUVolumePass$1.newInstance();
            }
            model.volumePass.setColorTextureView(model.opaquePass.getColorTextureView());
            model.volumePass.setDepthTextureView(model.opaquePass.getDepthTextureView());
            model.volumePass.setVolumes(model.volumes);
            model.volumePass.traverse(renNode, viewNode);
          }
          publicAPI.finalPass(viewNode, renNode);
        }
      }
    }
  };
  publicAPI.finalPass = function(viewNode, renNode) {
    if (!model._finalBlitEncoder) {
      publicAPI.createFinalBlitEncoder(viewNode);
    }
    model._finalBlitOutputTextureView.createFromTextureHandle(viewNode.getCurrentTexture(), {
      depth: 1,
      format: viewNode.getPresentationFormat()
    });
    model._finalBlitEncoder.attachTextureViews();
    model._finalBlitEncoder.begin(viewNode.getCommandEncoder());
    renNode.scissorAndViewport(model._finalBlitEncoder);
    model._fullScreenQuad.prepareAndDraw(model._finalBlitEncoder);
    model._finalBlitEncoder.end();
  };
  publicAPI.createFinalBlitEncoder = function(viewNode) {
    model._finalBlitEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "forwardPassBlit"
    });
    model._finalBlitEncoder.setDescription({
      colorAttachments: [{
        view: null,
        loadOp: "load",
        storeOp: "store"
      }]
    });
    model._finalBlitEncoder.setPipelineHash("fpf");
    model._finalBlitEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      fragment: {
        targets: [{
          format: viewNode.getPresentationFormat(),
          blend: {
            color: {
              srcFactor: "src-alpha",
              dstFactor: "one-minus-src-alpha"
            },
            alpha: {
              srcfactor: "one",
              dstFactor: "one-minus-src-alpha"
            }
          }
        }]
      }
    });
    model._fsqSampler = vtkWebGPUSampler$1.newInstance({
      label: "finalPassSampler"
    });
    model._fsqSampler.create(viewNode.getDevice(), {
      minFilter: "linear",
      magFilter: "linear"
    });
    model._fullScreenQuad = vtkWebGPUFullScreenQuad$1.newInstance();
    model._fullScreenQuad.setDevice(viewNode.getDevice());
    model._fullScreenQuad.setPipelineHash("fpfsq");
    model._fullScreenQuad.setTextureViews([model.opaquePass.getColorTextureView()]);
    model._fullScreenQuad.setAdditionalBindables([model._fsqSampler]);
    model._fullScreenQuad.setFragmentShaderTemplate(finalBlitFragTemplate);
    model._finalBlitOutputTextureView = vtkWebGPUTextureView$1.newInstance();
    model._finalBlitEncoder.setColorTextureView(0, model._finalBlitOutputTextureView);
  };
  publicAPI.incrementOpaqueActorCount = function() {
    return model.opaqueActorCount++;
  };
  publicAPI.incrementTranslucentActorCount = function() {
    return model.translucentActorCount++;
  };
  publicAPI.addVolume = function(volume) {
    model.volumes.push(volume);
  };
}
var DEFAULT_VALUES16 = {
  opaqueActorCount: 0,
  translucentActorCount: 0,
  volumes: null,
  opaqueRenderEncoder: null,
  translucentPass: null,
  volumePass: null
};
function extend16(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES16, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["opaquePass", "translucentPass", "volumePass"]);
  vtkForwardPass2(publicAPI, model);
}
var newInstance17 = macro.newInstance(extend16, "vtkForwardPass");
var vtkForwardPass$12 = {
  newInstance: newInstance17,
  extend: extend16
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/TextureManager.js
var VtkDataTypes2 = vtkDataArray$1.VtkDataTypes;
function vtkWebGPUTextureManager(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUTextureManager");
  function _fillRequest(req) {
    if (req.imageData) {
      req.dataArray = req.imageData.getPointData().getScalars();
      req.time = req.dataArray.getMTime();
      req.nativeArray = req.dataArray.getData();
      var dims = req.imageData.getDimensions();
      req.width = dims[0];
      req.height = dims[1];
      req.depth = dims[2];
      var numComp = req.dataArray.getNumberOfComponents();
      switch (numComp) {
        case 1:
          req.format = "r";
          break;
        case 2:
          req.format = "rg";
          break;
        case 3:
        case 4:
        default:
          req.format = "rgba";
          break;
      }
      var dataType = req.dataArray.getDataType();
      switch (dataType) {
        case VtkDataTypes2.UNSIGNED_CHAR:
          req.format += "8unorm";
          break;
        case VtkDataTypes2.FLOAT:
        case VtkDataTypes2.UNSIGNED_INT:
        case VtkDataTypes2.INT:
        case VtkDataTypes2.DOUBLE:
        case VtkDataTypes2.UNSIGNED_SHORT:
        case VtkDataTypes2.SHORT:
        default:
          req.format += "16float";
          break;
      }
    }
    if (req.image) {
      req.width = req.image.width;
      req.height = req.image.height;
      req.depth = 1;
      req.format = "rgba8unorm";
    }
    if (req.jsImageData) {
      req.width = req.jsImageData.width;
      req.height = req.jsImageData.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      req.nativeArray = req.jsImageData.data;
    }
    if (req.canvas) {
      req.width = req.canvas.width;
      req.height = req.canvas.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      req.usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT;
    }
  }
  function _createTexture(req) {
    var newTex = vtkWebGPUTexture$1.newInstance();
    newTex.create(model.device, {
      width: req.width,
      height: req.height,
      depth: req.depth,
      format: req.format,
      usage: req.usage,
      mipLevel: req.mipLevel
    });
    if (req.nativeArray || req.image || req.canvas) {
      newTex.writeImageData(req);
    }
    return newTex;
  }
  publicAPI.getTexture = function(req) {
    if (req.hash) {
      return model.device.getCachedObject(req.hash, _createTexture, req);
    }
    return _createTexture(req);
  };
  publicAPI.getTextureForImageData = function(imgData) {
    var treq = {
      time: imgData.getMTime()
    };
    treq.imageData = imgData;
    _fillRequest(treq);
    treq.hash = treq.time + treq.format + treq.mipLevel;
    return model.device.getTextureManager().getTexture(treq);
  };
  publicAPI.getTextureForVTKTexture = function(srcTexture) {
    var treq = {
      time: srcTexture.getMTime()
    };
    if (srcTexture.getInputData()) {
      treq.imageData = srcTexture.getInputData();
    } else if (srcTexture.getImage()) {
      treq.image = srcTexture.getImage();
    } else if (srcTexture.getJsImageData()) {
      treq.jsImageData = srcTexture.getJsImageData();
    } else if (srcTexture.getCanvas()) {
      treq.canvas = srcTexture.getCanvas();
    }
    _fillRequest(treq);
    treq.mipLevel = srcTexture.getMipLevel();
    treq.hash = treq.time + treq.format + treq.mipLevel;
    return model.device.getTextureManager().getTexture(treq);
  };
}
var DEFAULT_VALUES17 = {
  handle: null,
  device: null
};
function extend17(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES17, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["device"]);
  vtkWebGPUTextureManager(publicAPI, model);
}
var newInstance18 = macro.newInstance(extend17);
var vtkWebGPUTextureManager$1 = {
  newInstance: newInstance18,
  extend: extend17
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Device.js
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var WeakRefMap = function(_Map) {
  _inherits(WeakRefMap2, _Map);
  var _super = _createSuper(WeakRefMap2);
  function WeakRefMap2() {
    var _thisSuper, _thisSuper2, _this;
    _classCallCheck(this, WeakRefMap2);
    _this = _super.call(this);
    _this.registry = new FinalizationRegistry(function(key) {
      var entry = _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(WeakRefMap2.prototype)), "get", _thisSuper).call(_thisSuper, key);
      if (entry && entry.deref && entry.deref() === void 0)
        _get((_thisSuper2 = _assertThisInitialized(_this), _getPrototypeOf(WeakRefMap2.prototype)), "delete", _thisSuper2).call(_thisSuper2, key);
    });
    return _this;
  }
  _createClass(WeakRefMap2, [{
    key: "getValue",
    value: function getValue(key) {
      var entry = _get(_getPrototypeOf(WeakRefMap2.prototype), "get", this).call(this, key);
      if (entry) {
        var value = entry.deref();
        if (value !== void 0)
          return value;
        _get(_getPrototypeOf(WeakRefMap2.prototype), "delete", this).call(this, key);
      }
      return void 0;
    }
  }, {
    key: "setValue",
    value: function setValue(key, value) {
      var entry;
      if (value && _typeof(value) === "object") {
        entry = new WeakRef(value);
        this.registry.register(value, key);
        _get(_getPrototypeOf(WeakRefMap2.prototype), "set", this).call(this, key, entry);
      }
      return entry;
    }
  }]);
  return WeakRefMap2;
}(_wrapNativeSuper(Map));
function vtkWebGPUDevice(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUDevice");
  publicAPI.initialize = function(handle) {
    model.handle = handle;
  };
  publicAPI.createCommandEncoder = function() {
    return model.handle.createCommandEncoder();
  };
  publicAPI.submitCommandEncoder = function(commandEncoder) {
    model.handle.queue.submit([commandEncoder.finish()]);
  };
  publicAPI.getShaderModule = function(sd) {
    return model.shaderCache.getShaderModule(sd);
  };
  publicAPI.getBindGroupLayout = function(val) {
    if (!val.entries) {
      return null;
    }
    for (var i = 0; i < val.entries.length; i++) {
      var ent = val.entries[i];
      ent.binding = ent.binding || 0;
      ent.visibility = ent.visibility || GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;
    }
    var sval = JSON.stringify(val);
    for (var _i = 0; _i < model.bindGroupLayouts.length; _i++) {
      if (model.bindGroupLayouts[_i].sval === sval) {
        return model.bindGroupLayouts[_i].layout;
      }
    }
    var layout = model.handle.createBindGroupLayout(val);
    model.bindGroupLayouts.push({
      sval,
      layout
    });
    return layout;
  };
  publicAPI.getBindGroupLayoutDescription = function(layout) {
    for (var i = 0; i < model.bindGroupLayouts.length; i++) {
      if (model.bindGroupLayouts[i].layout === layout) {
        return model.bindGroupLayouts[i].sval;
      }
    }
    vtkErrorMacro("layout not found");
    console.trace();
    return null;
  };
  publicAPI.getPipeline = function(hash) {
    if (hash in model.pipelines) {
      return model.pipelines[hash];
    }
    return null;
  };
  publicAPI.createPipeline = function(hash, pipeline) {
    pipeline.initialize(publicAPI, hash);
    model.pipelines[hash] = pipeline;
  };
  publicAPI.onSubmittedWorkDone = function() {
    return model.handle.queue.onSubmittedWorkDone();
  };
  publicAPI.hasCachedObject = function(hash) {
    return model.objectCache.getValue(hash);
  };
  publicAPI.getCachedObject = function(hash, creator) {
    if (!hash) {
      vtkErrorMacro("attempt to cache an object without a hash");
      return null;
    }
    var existingValue = model.objectCache.getValue(hash);
    if (existingValue) {
      return existingValue;
    }
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    var createdObject = creator.apply(void 0, args);
    model.objectCache.setValue(hash, createdObject);
    return createdObject;
  };
}
var DEFAULT_VALUES18 = {
  handle: null,
  pipelines: null,
  shaderCache: null,
  bindGroupLayouts: null,
  bufferManager: null,
  textureManager: null
};
function extend18(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES18, initialValues);
  obj(publicAPI, model);
  setGet(publicAPI, model, ["handle"]);
  get(publicAPI, model, ["bufferManager", "shaderCache", "textureManager"]);
  model.objectCache = new WeakRefMap();
  model.shaderCache = vtkWebGPUShaderCache$1.newInstance();
  model.shaderCache.setDevice(publicAPI);
  model.bindGroupLayouts = [];
  model.bufferManager = vtkWebGPUBufferManager$1.newInstance();
  model.bufferManager.setDevice(publicAPI);
  model.textureManager = vtkWebGPUTextureManager$1.newInstance();
  model.textureManager.setDevice(publicAPI);
  model.pipelines = {};
  vtkWebGPUDevice(publicAPI, model);
}
var newInstance19 = newInstance(extend18, "vtkWebGPUDevice");
var vtkWebGPUDevice$1 = {
  newInstance: newInstance19,
  extend: extend18
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/HardwareSelector.js
var import_regenerator4 = __toESM(require_regenerator());

// node_modules/@kitware/vtk.js/Rendering/WebGPU/HardwareSelectionPass.js
function vtkWebGPUHardwareSelectionPass(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUHardwareSelectionPass");
  publicAPI.traverse = function(viewNode, renNode) {
    if (model.deleted) {
      return;
    }
    model.currentParent = null;
    publicAPI.setCurrentOperation("buildPass");
    viewNode.traverse(publicAPI);
    var device = viewNode.getDevice();
    if (!model.selectionRenderEncoder) {
      publicAPI.createRenderEncoder();
      model.colorTexture = vtkWebGPUTexture$1.newInstance({
        label: "hardwareSelectorColor"
      });
      model.colorTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "rgba32uint",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
      });
      var v1 = model.colorTexture.createView("hardwareSelectColorTexture");
      model.selectionRenderEncoder.setColorTextureView(0, v1);
      model.depthTexture = vtkWebGPUTexture$1.newInstance({
        label: "hardwareSelectorDepth"
      });
      model.depthTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: "depth32float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
      });
      var v2 = model.depthTexture.createView("hardwareSelectDepthTexture");
      model.selectionRenderEncoder.setDepthTextureView(v2);
    } else {
      model.colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
      model.depthTexture.resizeToMatch(model.colorTexture);
    }
    model.selectionRenderEncoder.attachTextureViews();
    renNode.setRenderEncoder(model.selectionRenderEncoder);
    publicAPI.setCurrentOperation("cameraPass");
    renNode.traverse(publicAPI);
    publicAPI.setCurrentOperation("opaquePass");
    renNode.traverse(publicAPI);
  };
  publicAPI.createRenderEncoder = function() {
    model.selectionRenderEncoder = vtkWebGPURenderEncoder$1.newInstance({
      label: "HardwareSelectionPass"
    });
    model.selectionRenderEncoder.setPipelineHash("sel");
    model.selectionRenderEncoder.setReplaceShaderCodeFunction(function(pipeline) {
      var fDesc = pipeline.getShaderDescription("fragment");
      fDesc.addOutput("vec4<u32>", "outColor");
      var code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::RenderEncoder::Impl", ["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result;
      fDesc.setCode(code);
    });
    var renDesc = model.selectionRenderEncoder.getDescription();
    renDesc.colorAttachments[0].clearValue = [0, 0, 0, 0];
    model.selectionRenderEncoder.setPipelineSettings({
      primitive: {
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: "greater",
        format: "depth32float"
      },
      fragment: {
        targets: [{
          format: "rgba32uint",
          blend: void 0
        }]
      }
    });
  };
}
var DEFAULT_VALUES19 = {
  selectionRenderEncoder: null,
  colorTexture: null,
  depthTexture: null
};
function extend19(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES19, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["colorTexture", "depthTexture"]);
  vtkWebGPUHardwareSelectionPass(publicAPI, model);
}
var newInstance20 = macro.newInstance(extend19, "vtkWebGPUHardwareSelectionPass");
var vtkWebGPUHardwareSelectionPass$1 = {
  newInstance: newInstance20,
  extend: extend19
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/HardwareSelector.js
var SelectionContent3 = vtkSelectionNode$1.SelectionContent;
var SelectionField3 = vtkSelectionNode$1.SelectionField;
var FieldAssociations3 = vtkDataSet$1.FieldAssociations;
var vtkErrorMacro6 = macro.vtkErrorMacro;
function getInfoHash2(info) {
  return "".concat(info.propID, " ").concat(info.compositeID);
}
function convert2(xx, yy, buffdata, channel) {
  var offset = ((buffdata.height - yy - 1) * buffdata.colorBufferWidth + xx) * 4 + channel;
  return buffdata.colorValues[offset];
}
function getPixelInformationWithData2(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
  var maxDist = maxDistance < 0 ? 0 : maxDistance;
  if (maxDist === 0) {
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    if (inDisplayPosition[0] < 0 || inDisplayPosition[0] >= buffdata.width || inDisplayPosition[1] < 0 || inDisplayPosition[1] >= buffdata.height) {
      return null;
    }
    var actorid = convert2(inDisplayPosition[0], inDisplayPosition[1], buffdata, 0);
    if (actorid <= 0) {
      return null;
    }
    var _info = {};
    _info.propID = actorid;
    var compositeID = convert2(inDisplayPosition[0], inDisplayPosition[1], buffdata, 1);
    if (compositeID < 0 || compositeID > 16777215) {
      compositeID = 0;
    }
    _info.compositeID = compositeID;
    if (buffdata.captureZValues) {
      var offset = (buffdata.height - inDisplayPosition[1] - 1) * buffdata.zbufferBufferWidth + inDisplayPosition[0];
      _info.zValue = buffdata.depthValues[offset];
      _info.zValue = buffdata.webGPURenderer.convertToOpenGLDepth(_info.zValue);
      _info.displayPosition = inDisplayPosition;
    }
    return _info;
  }
  var dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
  var curPos = [0, 0];
  var info = getPixelInformationWithData2(buffdata, inDisplayPosition, 0, outSelectedPosition);
  if (info) {
    return info;
  }
  for (var dist = 1; dist < maxDist; ++dist) {
    for (var y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
      curPos[1] = y;
      if (dispPos[0] >= dist) {
        curPos[0] = dispPos[0] - dist;
        info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
        if (info) {
          return info;
        }
      }
      curPos[0] = dispPos[0] + dist;
      info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
      if (info) {
        return info;
      }
    }
    for (var x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
      curPos[0] = x;
      if (dispPos[1] >= dist) {
        curPos[1] = dispPos[1] - dist;
        info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
        if (info) {
          return info;
        }
      }
      curPos[1] = dispPos[1] + dist;
      info = getPixelInformationWithData2(buffdata, curPos, 0, outSelectedPosition);
      if (info) {
        return info;
      }
    }
  }
  outSelectedPosition[0] = inDisplayPosition[0];
  outSelectedPosition[1] = inDisplayPosition[1];
  return null;
}
function convertSelection2(fieldassociation, dataMap, buffdata) {
  var sel = [];
  var count = 0;
  dataMap.forEach(function(value, key) {
    var child = vtkSelectionNode$1.newInstance();
    child.setContentType(SelectionContent3.INDICES);
    switch (fieldassociation) {
      case FieldAssociations3.FIELD_ASSOCIATION_CELLS:
        child.setFieldType(SelectionField3.CELL);
        break;
      case FieldAssociations3.FIELD_ASSOCIATION_POINTS:
        child.setFieldType(SelectionField3.POINT);
        break;
      default:
        vtkErrorMacro6("Unknown field association");
    }
    child.getProperties().propID = value.info.propID;
    var wprop = buffdata.webGPURenderer.getPropFromID(value.info.propID);
    child.getProperties().prop = wprop.getRenderable();
    child.getProperties().compositeID = value.info.compositeID;
    child.getProperties().pixelCount = value.pixelCount;
    if (buffdata.captureZValues) {
      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
      child.getProperties().worldPosition = buffdata.webGPURenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, buffdata.renderer);
    }
    child.setSelectionList(value.attributeIDs);
    sel[count] = child;
    count++;
  });
  return sel;
}
function generateSelectionWithData2(buffdata, fx1, fy1, fx2, fy2) {
  var x1 = Math.floor(fx1);
  var y1 = Math.floor(fy1);
  var x2 = Math.floor(fx2);
  var y2 = Math.floor(fy2);
  var dataMap = /* @__PURE__ */ new Map();
  var outSelectedPosition = [0, 0];
  for (var yy = y1; yy <= y2; yy++) {
    for (var xx = x1; xx <= x2; xx++) {
      var pos = [xx, yy];
      var info = getPixelInformationWithData2(buffdata, pos, 0, outSelectedPosition);
      if (info) {
        var hash = getInfoHash2(info);
        if (!dataMap.has(hash)) {
          dataMap.set(hash, {
            info,
            pixelCount: 1,
            attributeIDs: [info.attributeID]
          });
        } else {
          var dmv = dataMap.get(hash);
          dmv.pixelCount++;
          if (buffdata.captureZValues) {
            if (info.zValue < dmv.info.zValue) {
              dmv.info = info;
            }
          }
          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
            dmv.attributeIDs.push(info.attributeID);
          }
        }
      }
    }
  }
  return convertSelection2(buffdata.fieldAssociation, dataMap, buffdata);
}
function vtkWebGPUHardwareSelector(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUHardwareSelector");
  publicAPI.endSelection = function() {
    model.WebGPURenderer.setSelector(null);
  };
  publicAPI.getSourceDataAsync = function() {
    var _ref = _asyncToGenerator(import_regenerator4.default.mark(function _callee(renderer) {
      var webGPURenderer, originalSuppress, device, texture, depthTexture, result, colorBuffer, cmdEnc, zbuffer, cLoad, zLoad;
      return import_regenerator4.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!renderer || !model.WebGPURenderWindow)) {
                _context.next = 3;
                break;
              }
              vtkErrorMacro6("Renderer and view must be set before calling Select.");
              return _context.abrupt("return", false);
            case 3:
              model.WebGPURenderWindow.getRenderable().preRender();
              if (model.WebGPURenderWindow.getInitialized()) {
                _context.next = 8;
                break;
              }
              model.WebGPURenderWindow.initialize();
              _context.next = 8;
              return new Promise(function(resolve) {
                model.WebGPURenderWindow.onInitialized(resolve);
              });
            case 8:
              webGPURenderer = model.WebGPURenderWindow.getViewNodeFor(renderer);
              if (webGPURenderer) {
                _context.next = 11;
                break;
              }
              return _context.abrupt("return", false);
            case 11:
              originalSuppress = webGPURenderer.getSuppressClear();
              webGPURenderer.setSuppressClear(true);
              model._selectionPass.traverse(model.WebGPURenderWindow, webGPURenderer);
              webGPURenderer.setSuppressClear(originalSuppress);
              device = model.WebGPURenderWindow.getDevice();
              texture = model._selectionPass.getColorTexture();
              depthTexture = model._selectionPass.getDepthTexture();
              result = {
                area: [0, 0, texture.getWidth() - 1, texture.getHeight() - 1],
                captureZValues: model.captureZValues,
                fieldAssociation: model.fieldAssociation,
                renderer,
                webGPURenderer,
                webGPURenderWindow: model.WebGPURenderWindow,
                width: texture.getWidth(),
                height: texture.getHeight()
              };
              result.colorBufferWidth = 16 * Math.floor((result.width + 15) / 16);
              result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 4 * 4;
              colorBuffer = vtkWebGPUBuffer$1.newInstance({
                label: "hardwareSelectColorBuffer"
              });
              colorBuffer.setDevice(device);
              colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
              cmdEnc = model.WebGPURenderWindow.getCommandEncoder();
              cmdEnc.copyTextureToBuffer({
                texture: texture.getHandle()
              }, {
                buffer: colorBuffer.getHandle(),
                bytesPerRow: 16 * result.colorBufferWidth,
                rowsPerImage: result.height
              }, {
                width: result.width,
                height: result.height,
                depthOrArrayLayers: 1
              });
              if (model.captureZValues) {
                result.zbufferBufferWidth = 64 * Math.floor((result.width + 63) / 64);
                zbuffer = vtkWebGPUBuffer$1.newInstance({
                  label: "hardwareSelectDepthBuffer"
                });
                zbuffer.setDevice(device);
                result.zbufferSizeInBytes = result.height * result.zbufferBufferWidth * 4;
                zbuffer.create(result.zbufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
                cmdEnc.copyTextureToBuffer({
                  texture: depthTexture.getHandle(),
                  aspect: "depth-only"
                }, {
                  buffer: zbuffer.getHandle(),
                  bytesPerRow: 4 * result.zbufferBufferWidth,
                  rowsPerImage: result.height
                }, {
                  width: result.width,
                  height: result.height,
                  depthOrArrayLayers: 1
                });
              }
              device.submitCommandEncoder(cmdEnc);
              cLoad = colorBuffer.mapAsync(GPUMapMode.READ);
              if (!model.captureZValues) {
                _context.next = 37;
                break;
              }
              zLoad = zbuffer.mapAsync(GPUMapMode.READ);
              _context.next = 33;
              return Promise.all([cLoad, zLoad]);
            case 33:
              result.depthValues = new Float32Array(zbuffer.getMappedRange().slice());
              zbuffer.unmap();
              _context.next = 39;
              break;
            case 37:
              _context.next = 39;
              return cLoad;
            case 39:
              result.colorValues = new Uint32Array(colorBuffer.getMappedRange().slice());
              colorBuffer.unmap();
              result.generateSelection = function(fx1, fy1, fx2, fy2) {
                return generateSelectionWithData2(result, fx1, fy1, fx2, fy2);
              };
              return _context.abrupt("return", result);
            case 43:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function(_x) {
      return _ref.apply(this, arguments);
    };
  }();
}
var DEFAULT_VALUES20 = {
  WebGPURenderWindow: null
};
function extend20(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES20, initialValues);
  vtkHardwareSelector$1.extend(publicAPI, model, initialValues);
  model._selectionPass = vtkWebGPUHardwareSelectionPass$1.newInstance();
  macro.setGet(publicAPI, model, ["WebGPURenderWindow"]);
  vtkWebGPUHardwareSelector(publicAPI, model);
}
var newInstance21 = macro.newInstance(extend20, "vtkWebGPUHardwareSelector");
var vtkWebGPUHardwareSelector$1 = {
  newInstance: newInstance21,
  extend: extend20
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/RenderWindow.js
var vtkErrorMacro7 = macro.vtkErrorMacro;
var SCREENSHOT_PLACEHOLDER2 = {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%"
};
function vtkWebGPURenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPURenderWindow");
  publicAPI.getViewNodeFactory = function() {
    return model.myFactory;
  };
  var previousSize = [0, 0];
  function updateWindow() {
    if (model.renderable) {
      if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
        previousSize[0] = model.size[0];
        previousSize[1] = model.size[1];
        model.canvas.setAttribute("width", model.size[0]);
        model.canvas.setAttribute("height", model.size[1]);
        publicAPI.recreateSwapChain();
      }
    }
    if (model.viewStream) {
      model.viewStream.setSize(model.size[0], model.size[1]);
    }
    model.canvas.style.display = model.useOffScreen ? "none" : "block";
    if (model.el) {
      model.el.style.cursor = model.cursorVisibility ? model.cursor : "none";
    }
    model.containerSize = null;
  }
  publicAPI.onModified(updateWindow);
  publicAPI.recreateSwapChain = function() {
    if (model.context) {
      model.context.unconfigure();
      model.presentationFormat = navigator.gpu.getPreferredCanvasFormat(model.adapter);
      model.context.configure({
        device: model.device.getHandle(),
        format: model.presentationFormat,
        alphaMode: "premultiplied",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,
        width: model.size[0],
        height: model.size[1]
      });
      model._configured = true;
    }
  };
  publicAPI.getCurrentTexture = function() {
    return model.context.getCurrentTexture();
  };
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
      publicAPI.removeUnusedNodes();
      publicAPI.initialize();
    } else if (model.initialized) {
      if (!model._configured) {
        publicAPI.recreateSwapChain();
      }
      model.commandEncoder = model.device.createCommandEncoder();
    }
  };
  publicAPI.initialize = function() {
    if (!model.initializing) {
      model.initializing = true;
      if (!navigator.gpu) {
        vtkErrorMacro7("WebGPU is not enabled.");
        return;
      }
      publicAPI.create3DContextAsync().then(function() {
        model.initialized = true;
        if (model.deleted) {
          return;
        }
        publicAPI.invokeInitialized();
      });
    }
  };
  publicAPI.setContainer = function(el) {
    if (model.el && model.el !== el) {
      if (model.canvas.parentNode !== model.el) {
        vtkErrorMacro7("Error: canvas parent node does not match container");
      }
      model.el.removeChild(model.canvas);
      if (model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    }
    if (model.el !== el) {
      model.el = el;
      if (model.el) {
        model.el.appendChild(model.canvas);
        if (model.useBackgroundImage) {
          model.el.appendChild(model.bgImage);
        }
      }
      publicAPI.modified();
    }
  };
  publicAPI.getContainer = function() {
    return model.el;
  };
  publicAPI.getContainerSize = function() {
    if (!model.containerSize && model.el) {
      var _model$el$getBounding = model.el.getBoundingClientRect(), width = _model$el$getBounding.width, height = _model$el$getBounding.height;
      model.containerSize = [width, height];
    }
    return model.containerSize || model.size;
  };
  publicAPI.getFramebufferSize = function() {
    return model.size;
  };
  publicAPI.create3DContextAsync = _asyncToGenerator(import_regenerator5.default.mark(function _callee() {
    return import_regenerator5.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return navigator.gpu.requestAdapter({
              powerPreference: "high-performance"
            });
          case 2:
            model.adapter = _context.sent;
            if (!model.deleted) {
              _context.next = 5;
              break;
            }
            return _context.abrupt("return");
          case 5:
            model.device = vtkWebGPUDevice$1.newInstance();
            _context.t0 = model.device;
            _context.next = 9;
            return model.adapter.requestDevice();
          case 9:
            _context.t1 = _context.sent;
            _context.t0.initialize.call(_context.t0, _context.t1);
            if (!model.deleted) {
              _context.next = 14;
              break;
            }
            model.device = null;
            return _context.abrupt("return");
          case 14:
            model.context = model.canvas.getContext("webgpu");
          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  publicAPI.releaseGraphicsResources = function() {
    var rp = vtkRenderPass$1.newInstance();
    rp.setCurrentOperation("Release");
    rp.traverse(publicAPI, null);
    model.adapter = null;
    model.device = null;
    model.context = null;
    model.initialized = false;
    model.initializing = false;
  };
  publicAPI.setBackgroundImage = function(img) {
    model.bgImage.src = img.src;
  };
  publicAPI.setUseBackgroundImage = function(value) {
    model.useBackgroundImage = value;
    if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
      model.el.appendChild(model.bgImage);
    } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
      model.el.removeChild(model.bgImage);
    }
  };
  function getCanvasDataURL() {
    return _getCanvasDataURL.apply(this, arguments);
  }
  function _getCanvasDataURL() {
    _getCanvasDataURL = _asyncToGenerator(import_regenerator5.default.mark(function _callee3() {
      var format, temporaryCanvas, temporaryContext, result, imageData, mainBoundingClientRect, renderWindow, renderers, screenshot, _args3 = arguments;
      return import_regenerator5.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              format = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : model.imageFormat;
              temporaryCanvas = document.createElement("canvas");
              temporaryContext = temporaryCanvas.getContext("2d");
              temporaryCanvas.width = model.canvas.width;
              temporaryCanvas.height = model.canvas.height;
              _context3.next = 7;
              return publicAPI.getPixelsAsync();
            case 7:
              result = _context3.sent;
              imageData = new ImageData(result.colorValues, result.width, result.height);
              temporaryContext.putImageData(imageData, 0, 0);
              mainBoundingClientRect = model.canvas.getBoundingClientRect();
              renderWindow = model.renderable;
              renderers = renderWindow.getRenderers();
              renderers.forEach(function(renderer) {
                var viewProps = renderer.getViewProps();
                viewProps.forEach(function(viewProp) {
                  if (viewProp.getContainer) {
                    var container = viewProp.getContainer();
                    var canvasList = container.getElementsByTagName("canvas");
                    for (var i = 0; i < canvasList.length; i++) {
                      var currentCanvas = canvasList[i];
                      var boundingClientRect = currentCanvas.getBoundingClientRect();
                      var newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
                      var newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
                      temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
                    }
                  }
                });
              });
              screenshot = temporaryCanvas.toDataURL(format);
              temporaryCanvas.remove();
              publicAPI.invokeImageReady(screenshot);
            case 17:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _getCanvasDataURL.apply(this, arguments);
  }
  publicAPI.captureNextImage = function() {
    var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png";
    var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$resetCamera = _ref2.resetCamera, resetCamera = _ref2$resetCamera === void 0 ? false : _ref2$resetCamera, _ref2$size = _ref2.size, size = _ref2$size === void 0 ? null : _ref2$size, _ref2$scale = _ref2.scale, scale = _ref2$scale === void 0 ? 1 : _ref2$scale;
    if (model.deleted) {
      return null;
    }
    model.imageFormat = format;
    var previous = model.notifyStartCaptureImage;
    model.notifyStartCaptureImage = true;
    model._screenshot = {
      size: !!size || scale !== 1 ? size || model.size.map(function(val) {
        return val * scale;
      }) : null
    };
    return new Promise(function(resolve, reject) {
      var subscription = publicAPI.onImageReady(function(imageURL) {
        if (model._screenshot.size === null) {
          model.notifyStartCaptureImage = previous;
          subscription.unsubscribe();
          if (model._screenshot.placeHolder) {
            model.size = model._screenshot.originalSize;
            publicAPI.modified();
            if (model._screenshot.cameras) {
              model._screenshot.cameras.forEach(function(_ref3) {
                var restoreParamsFn = _ref3.restoreParamsFn, arg = _ref3.arg;
                return restoreParamsFn(arg);
              });
            }
            publicAPI.traverseAllPasses();
            model.el.removeChild(model._screenshot.placeHolder);
            model._screenshot.placeHolder.remove();
            model._screenshot = null;
          }
          resolve(imageURL);
        } else {
          var tmpImg = document.createElement("img");
          tmpImg.style = SCREENSHOT_PLACEHOLDER2;
          tmpImg.src = imageURL;
          model._screenshot.placeHolder = model.el.appendChild(tmpImg);
          model.canvas.style.display = "none";
          model._screenshot.originalSize = model.size;
          model.size = model._screenshot.size;
          model._screenshot.size = null;
          publicAPI.modified();
          if (resetCamera) {
            var isUserResetCamera = resetCamera !== true;
            model._screenshot.cameras = model.renderable.getRenderers().map(function(renderer) {
              var camera = renderer.getActiveCamera();
              var params = camera.get("focalPoint", "position", "parallelScale");
              return {
                resetCameraArgs: isUserResetCamera ? {
                  renderer
                } : void 0,
                resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,
                restoreParamsFn: camera.set,
                arg: JSON.parse(JSON.stringify(params))
              };
            });
            model._screenshot.cameras.forEach(function(_ref4) {
              var resetCameraFn = _ref4.resetCameraFn, resetCameraArgs = _ref4.resetCameraArgs;
              return resetCameraFn(resetCameraArgs);
            });
          }
          publicAPI.traverseAllPasses();
        }
      });
    });
  };
  publicAPI.traverseAllPasses = function() {
    if (model.deleted) {
      return;
    }
    if (!model.initialized) {
      publicAPI.initialize();
      var subscription = publicAPI.onInitialized(function() {
        subscription.unsubscribe();
        publicAPI.traverseAllPasses();
      });
    } else {
      if (model.renderPasses) {
        for (var index = 0; index < model.renderPasses.length; ++index) {
          model.renderPasses[index].traverse(publicAPI, null);
        }
      }
      if (model.commandEncoder) {
        model.device.submitCommandEncoder(model.commandEncoder);
        model.commandEncoder = null;
        if (model.notifyStartCaptureImage) {
          model.device.onSubmittedWorkDone().then(function() {
            getCanvasDataURL();
          });
        }
      }
    }
  };
  publicAPI.setViewStream = function(stream) {
    if (model.viewStream === stream) {
      return false;
    }
    if (model.subscription) {
      model.subscription.unsubscribe();
      model.subscription = null;
    }
    model.viewStream = stream;
    if (model.viewStream) {
      var mainRenderer = model.renderable.getRenderers()[0];
      mainRenderer.getBackgroundByReference()[3] = 0;
      publicAPI.setUseBackgroundImage(true);
      model.subscription = model.viewStream.onImageReady(function(e) {
        return publicAPI.setBackgroundImage(e.image);
      });
      model.viewStream.setSize(model.size[0], model.size[1]);
      model.viewStream.invalidateCache();
      model.viewStream.render();
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.getUniquePropID = function() {
    return model.nextPropID++;
  };
  publicAPI.getPropFromID = function(id) {
    for (var i = 0; i < model.children.length; i++) {
      var res = model.children[i].getPropFromID(id);
      if (res !== null) {
        return res;
      }
    }
    return null;
  };
  publicAPI.getPixelsAsync = _asyncToGenerator(import_regenerator5.default.mark(function _callee2() {
    var device, texture, result, colorBuffer, cmdEnc, cLoad, tmparray, y, x, doffset, soffset;
    return import_regenerator5.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            device = model.device;
            texture = model.renderPasses[0].getOpaquePass().getColorTexture();
            result = {
              width: texture.getWidth(),
              height: texture.getHeight()
            };
            result.colorBufferWidth = 32 * Math.floor((result.width + 31) / 32);
            result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 8;
            colorBuffer = vtkWebGPUBuffer$1.newInstance();
            colorBuffer.setDevice(device);
            colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
            cmdEnc = model.device.createCommandEncoder();
            cmdEnc.copyTextureToBuffer({
              texture: texture.getHandle()
            }, {
              buffer: colorBuffer.getHandle(),
              bytesPerRow: 8 * result.colorBufferWidth,
              rowsPerImage: result.height
            }, {
              width: result.width,
              height: result.height,
              depthOrArrayLayers: 1
            });
            device.submitCommandEncoder(cmdEnc);
            cLoad = colorBuffer.mapAsync(GPUMapMode.READ);
            _context2.next = 14;
            return cLoad;
          case 14:
            result.colorValues = new Uint16Array(colorBuffer.getMappedRange().slice());
            colorBuffer.unmap();
            tmparray = new Uint8ClampedArray(result.height * result.width * 4);
            for (y = 0; y < result.height; y++) {
              for (x = 0; x < result.width; x++) {
                doffset = (y * result.width + x) * 4;
                soffset = (y * result.colorBufferWidth + x) * 4;
                tmparray[doffset] = 255 * HalfFloat.fromHalf(result.colorValues[soffset]);
                tmparray[doffset + 1] = 255 * HalfFloat.fromHalf(result.colorValues[soffset + 1]);
                tmparray[doffset + 2] = 255 * HalfFloat.fromHalf(result.colorValues[soffset + 2]);
                tmparray[doffset + 3] = 255 * HalfFloat.fromHalf(result.colorValues[soffset + 3]);
              }
            }
            result.colorValues = tmparray;
            return _context2.abrupt("return", result);
          case 20:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  publicAPI.createSelector = function() {
    var ret = vtkWebGPUHardwareSelector$1.newInstance();
    ret.setWebGPURenderWindow(publicAPI);
    return ret;
  };
  publicAPI.delete = macro.chain(publicAPI.delete, publicAPI.setViewStream);
}
var DEFAULT_VALUES21 = {
  initialized: false,
  context: null,
  adapter: null,
  device: null,
  canvas: null,
  cursorVisibility: true,
  cursor: "pointer",
  containerSize: null,
  renderPasses: [],
  notifyStartCaptureImage: false,
  imageFormat: "image/png",
  useOffScreen: false,
  useBackgroundImage: false,
  nextPropID: 1,
  xrSupported: false,
  presentationFormat: null
};
function extend21(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES21, initialValues);
  model.canvas = document.createElement("canvas");
  model.canvas.style.width = "100%";
  model.bgImage = new Image();
  model.bgImage.style.position = "absolute";
  model.bgImage.style.left = "0";
  model.bgImage.style.top = "0";
  model.bgImage.style.width = "100%";
  model.bgImage.style.height = "100%";
  model.bgImage.style.zIndex = "-1";
  vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);
  model.myFactory = vtkWebGPUViewNodeFactory$1.newInstance();
  model.myFactory.registerOverride("vtkRenderWindow", newInstance22);
  model.renderPasses[0] = vtkForwardPass$12.newInstance();
  if (!model.selector) {
    model.selector = vtkWebGPUHardwareSelector$1.newInstance();
    model.selector.setWebGPURenderWindow(publicAPI);
  }
  macro.event(publicAPI, model, "imageReady");
  macro.event(publicAPI, model, "initialized");
  macro.get(publicAPI, model, ["commandEncoder", "device", "presentationFormat", "useBackgroundImage", "xrSupported"]);
  macro.setGet(publicAPI, model, ["initialized", "context", "canvas", "device", "renderPasses", "notifyStartCaptureImage", "cursor", "useOffScreen"]);
  macro.setGetArray(publicAPI, model, ["size"], 2);
  vtkWebGPURenderWindow(publicAPI, model);
}
var newInstance22 = macro.newInstance(extend21, "vtkWebGPURenderWindow");
registerViewConstructor("WebGPU", newInstance22);
//# sourceMappingURL=chunk-QQN2ZB6Y.js.map
