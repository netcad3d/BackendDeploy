import {
  InterpolationType,
  OpacityMode
} from "./chunk-6RJ4JBDV.js";
import {
  vtkOpenGLFramebuffer
} from "./chunk-XMTP2BGC.js";
import {
  BlendMode
} from "./chunk-CPX3F44X.js";
import {
  vtkPolyDataFS,
  vtkPolyDataVS,
  vtkReplacementShaderMapper
} from "./chunk-YBEMB22E.js";
import {
  Filter,
  Wrap,
  registerOverride,
  registerOverride2,
  vtkHelper,
  vtkOpenGLTexture$1,
  vtkShaderProgram$1,
  vtkVertexArrayObject,
  vtkViewNode$1,
  vtkWebGPUFullScreenQuad$1,
  vtkWebGPUSampler$1,
  vtkWebGPUShaderCache$1,
  vtkWebGPUUniformBuffer$1
} from "./chunk-WDDAGUM6.js";
import {
  Representation
} from "./chunk-PIUKKK4M.js";
import {
  vtkDataArray$1
} from "./chunk-Z5OKWKLG.js";
import {
  VtkDataTypes
} from "./chunk-SWDS6M4V.js";
import {
  mat3_exports,
  mat4_exports,
  vec3_exports,
  vec4_exports
} from "./chunk-GC37RKNO.js";
import {
  uninitializeBounds
} from "./chunk-FOWOP5PK.js";
import {
  chain,
  get,
  macro,
  newInstance,
  obj,
  setGet,
  vtkErrorMacro,
  vtkWarningMacro
} from "./chunk-OTTIIP4A.js";
import {
  _defineProperty
} from "./chunk-HKWV5KNA.js";
import "./chunk-XL65WI7U.js";
import "./chunk-HUBM7RA2.js";

// node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper/Constants.js
var SlicingMode = {
  NONE: -1,
  I: 0,
  J: 1,
  K: 2,
  X: 3,
  Y: 4,
  Z: 5
};
var Constants = {
  SlicingMode
};

// node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty/Constants.js
var InterpolationType2 = {
  NEAREST: 0,
  LINEAR: 1
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageMapper.js
var vtkErrorMacro2 = vtkErrorMacro;
var SlicingMode2 = Constants.SlicingMode;
function computeFnToString(property, fn, numberOfComponents) {
  var pwfun = fn.apply(property);
  if (pwfun) {
    var iComps = property.getIndependentComponents();
    return "".concat(property.getMTime(), "-").concat(iComps, "-").concat(numberOfComponents);
  }
  return "0";
}
function vtkOpenGLImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageMapper");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLImageSlice = publicAPI.getFirstAncestorOfType("vtkOpenGLImageSlice");
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model.openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      var ren = model.openGLRenderer.getRenderable();
      model.openGLCamera = model.openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      if (model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = function(prepass, renderPass) {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.opaqueZBufferPass = function(prepass) {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaquePass = function(prepass) {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getCoincidentParameters = function(ren, actor) {
    if (model.renderable.getResolveCoincidentTopology()) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };
  publicAPI.render = function() {
    var actor = model.openGLImageSlice.getRenderable();
    var ren = model.openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.buildShaders = function(shaders, ren, actor) {
    publicAPI.getShaderTemplate(shaders, ren, actor);
    if (model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement(shaders);
    }
    publicAPI.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.getShaderTemplate = function(shaders, ren, actor) {
    shaders.Vertex = vtkPolyDataVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = function(shaders, ren, actor) {
    var VSSource = shaders.Vertex;
    var FSSource = shaders.Fragment;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["  gl_Position = MCPCMatrix * vertexMC;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;
    var tNumComp = model.openGLTexture.getComponents();
    var iComps = actor.getProperty().getIndependentComponents();
    var tcoordDec = [
      "varying vec2 tcoordVCVSOutput;",
      "uniform float cshift0;",
      "uniform float cscale0;",
      "uniform float pwfshift0;",
      "uniform float pwfscale0;",
      "uniform sampler2D texture1;",
      "uniform sampler2D colorTexture1;",
      "uniform sampler2D pwfTexture1;",
      "uniform float opacity;"
    ];
    if (iComps) {
      for (var comp = 1; comp < tNumComp; comp++) {
        tcoordDec = tcoordDec.concat([
          "uniform float cshift".concat(comp, ";"),
          "uniform float cscale".concat(comp, ";"),
          "uniform float pwfshift".concat(comp, ";"),
          "uniform float pwfscale".concat(comp, ";")
        ]);
      }
      switch (tNumComp) {
        case 1:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "#define height0 0.5"]);
          break;
        case 2:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "#define height0 0.25", "#define height1 0.75"]);
          break;
        case 3:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "#define height0 0.17", "#define height1 0.5", "#define height2 0.83"]);
          break;
        case 4:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "uniform float mix3;", "#define height0 0.125", "#define height1 0.375", "#define height2 0.625", "#define height3 0.875"]);
          break;
        default:
          vtkErrorMacro2("Unsupported number of independent coordinates.");
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", tcoordDec).result;
    if (iComps) {
      var rgba = ["r", "g", "b", "a"];
      var tcoordImpl = ["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];
      for (var _comp = 0; _comp < tNumComp; _comp++) {
        tcoordImpl = tcoordImpl.concat(["vec3 tcolor".concat(_comp, " = mix").concat(_comp, " * texture2D(colorTexture1, vec2(tvalue.").concat(rgba[_comp], " * cscale").concat(_comp, " + cshift").concat(_comp, ", height").concat(_comp, ")).rgb;"), "float compWeight".concat(_comp, " = mix").concat(_comp, " * texture2D(pwfTexture1, vec2(tvalue.").concat(rgba[_comp], " * pwfscale").concat(_comp, " + pwfshift").concat(_comp, ", height").concat(_comp, ")).r;")]);
      }
      switch (tNumComp) {
        case 1:
          tcoordImpl = tcoordImpl.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);
          break;
        case 2:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);
          break;
        case 3:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);
          break;
        case 4:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);
          break;
        default:
          vtkErrorMacro2("Unsupported number of independent coordinates.");
      }
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", tcoordImpl).result;
    } else {
      switch (tNumComp) {
        case 1:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["float intensity = texture2D(texture1, tcoordVCVSOutput).r;", "vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;", "float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;", "gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]).result;
          break;
        case 2:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "float intensity = tcolor.r*cscale0 + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;
          break;
        case 3:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;
          break;
        default:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result;
      }
    }
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderClip = function(shaders, ren, actor) {
    var VSSource = shaders.Vertex;
    var FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtkErrorMacro("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "uniform vec4 clipPlanes[6];", "varying float clipDistancesVSOutput[6];"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);", "    }"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "varying float clipDistancesVSOutput[6];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getNeedToRebuildShaders = function(cellBO, ren, actor) {
    var tNumComp = model.openGLTexture.getComponents();
    var iComp = actor.getProperty().getIndependentComponents();
    var needRebuild = false;
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement) {
      needRebuild = true;
      model.lastRenderPassShaderReplacement = null;
    }
    if (model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement = model.currentRenderPass.getShaderReplacement();
      needRebuild = true;
    }
    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = function(cellBO, ren, actor) {
    model.lastBoundBO = cellBO;
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      var shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      var newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = function(cellBO, ren, actor) {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed("vertexMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexMC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro2("Error setting vertexMC in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {
          vtkErrorMacro2("Error setting tcoordMC in shader VAO.");
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    var texUnit = model.openGLTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("texture1", texUnit);
    var numComp = model.openGLTexture.getComponents();
    var iComps = actor.getProperty().getIndependentComponents();
    if (iComps) {
      for (var i = 0; i < numComp; i++) {
        cellBO.getProgram().setUniformf("mix".concat(i), actor.getProperty().getComponentWeight(i));
      }
    }
    var oglShiftScale = model.openGLTexture.getShiftAndScale();
    for (var _i = 0; _i < numComp; _i++) {
      var cw = actor.getProperty().getColorWindow();
      var cl = actor.getProperty().getColorLevel();
      var target = iComps ? _i : 0;
      var cfun = actor.getProperty().getRGBTransferFunction(target);
      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {
        var cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      var scale = oglShiftScale.scale / cw;
      var shift = (oglShiftScale.shift - cl) / cw + 0.5;
      cellBO.getProgram().setUniformf("cshift".concat(_i), shift);
      cellBO.getProgram().setUniformf("cscale".concat(_i), scale);
    }
    for (var _i2 = 0; _i2 < numComp; _i2++) {
      var pwfScale = 1;
      var pwfShift = 0;
      var _target = iComps ? _i2 : 0;
      var pwfun = actor.getProperty().getPiecewiseFunction(_target);
      if (pwfun) {
        var pwfRange = pwfun.getRange();
        var length = pwfRange[1] - pwfRange[0];
        var mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = oglShiftScale.scale / length;
        pwfShift = (oglShiftScale.shift - mid) / length + 0.5;
      }
      cellBO.getProgram().setUniformf("pwfshift".concat(_i2), pwfShift);
      cellBO.getProgram().setUniformf("pwfscale".concat(_i2), pwfScale);
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (cellBO.getProgram().isUniformUsed("coffset")) {
      var cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf("coffset", cp.offset);
      if (cellBO.getProgram().isUniformUsed("cfactor")) {
        cellBO.getProgram().setUniformf("cfactor", cp.factor);
      }
    }
    var texColorUnit = model.colorTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("colorTexture1", texColorUnit);
    var texOpacityUnit = model.pwfTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("pwfTexture1", texOpacityUnit);
    if (model.renderable.getNumberOfClippingPlanes()) {
      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtkErrorMacro("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      var mat = inverseShiftScaleMatrix ? mat4_exports.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        mat4_exports.transpose(mat, mat);
        mat4_exports.multiply(mat, mat, inverseShiftScaleMatrix);
        mat4_exports.transpose(mat, mat);
      }
      mat4_exports.transpose(model.imagemat, model.currentInput.getIndexToWorld());
      mat4_exports.multiply(model.imagematinv, mat, model.imagemat);
      var planeEquations = [];
      for (var _i3 = 0; _i3 < numClipPlanes; _i3++) {
        var planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, _i3, planeEquation);
        for (var j = 0; j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      cellBO.getProgram().setUniformi("numClipPlanes", numClipPlanes);
      cellBO.getProgram().setUniform4fv("clipPlanes", planeEquations);
    }
  };
  publicAPI.setCameraShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    var actMats = model.openGLImageSlice.getKeyMatrices();
    var image = model.currentInput;
    var i2wmat4 = image.getIndexToWorld();
    mat4_exports.multiply(model.imagemat, actMats.mcwc, i2wmat4);
    var keyMats = model.openGLCamera.getKeyMatrices(ren);
    mat4_exports.multiply(model.imagemat, keyMats.wcpc, model.imagemat);
    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
      var inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();
      mat4_exports.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);
    }
    program.setUniformMatrix("MCPCMatrix", model.imagemat);
  };
  publicAPI.setPropertyShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    var ppty = actor.getProperty();
    var opacity = ppty.getOpacity();
    program.setUniformf("opacity", opacity);
  };
  publicAPI.renderPieceStart = function(ren, actor) {
    publicAPI.updateBufferObjects(ren, actor);
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = function(ren, actor) {
    var gl = model.context;
    model.openGLTexture.activate();
    model.colorTexture.activate();
    model.pwfTexture.activate();
    if (model.tris.getCABO().getElementCount()) {
      publicAPI.updateShaders(model.tris, ren, actor);
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
    }
    model.openGLTexture.deactivate();
    model.colorTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = function(ren, actor) {
  };
  publicAPI.renderPiece = function(ren, actor) {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (!model.currentInput) {
      vtkErrorMacro2("No input!");
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = function(ren, actor) {
    if (!publicAPI.getInput()) {
      uninitializeBounds(model.bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = function(ren, actor) {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = function(ren, actor) {
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = function(ren, actor) {
    var image = model.currentInput;
    if (!image) {
      return;
    }
    var imgScalars = image.getPointData() && image.getPointData().getScalars();
    if (!imgScalars) {
      return;
    }
    var actorProperty = actor.getProperty();
    var iType = actorProperty.getInterpolationType();
    if (iType === InterpolationType2.NEAREST) {
      model.colorTexture.setMinificationFilter(Filter.NEAREST);
      model.colorTexture.setMagnificationFilter(Filter.NEAREST);
      model.pwfTexture.setMinificationFilter(Filter.NEAREST);
      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);
    } else {
      model.colorTexture.setMinificationFilter(Filter.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      model.pwfTexture.setMinificationFilter(Filter.LINEAR);
      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);
    }
    var numComp = imgScalars.getNumberOfComponents();
    var iComps = actorProperty.getIndependentComponents();
    var numIComps = iComps ? numComp : 1;
    var textureHeight = iComps ? 2 * numIComps : 1;
    var cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);
    if (model.colorTextureString !== cfunToString) {
      var cWidth = 1024;
      var cSize = cWidth * textureHeight * 3;
      var cTable = new Uint8Array(cSize);
      var cfun = actorProperty.getRGBTransferFunction();
      if (cfun) {
        var tmpTable = new Float32Array(cWidth * 3);
        for (var c = 0; c < numIComps; c++) {
          cfun = actorProperty.getRGBTransferFunction(c);
          var cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (var i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255 * tmpTable[i];
              cTable[c * cWidth * 6 + i + cWidth * 3] = 255 * tmpTable[i];
            }
          } else {
            for (var _i4 = 0; _i4 < cWidth * 3; _i4++) {
              cTable[c * cWidth * 6 + _i4] = 255 * tmpTable[_i4];
            }
          }
        }
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      } else {
        for (var _i5 = 0; _i5 < cWidth * 3; ++_i5) {
          cTable[_i5] = 255 * _i5 / ((cWidth - 1) * 3);
          cTable[_i5 + 1] = 255 * _i5 / ((cWidth - 1) * 3);
          cTable[_i5 + 2] = 255 * _i5 / ((cWidth - 1) * 3);
        }
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      }
      model.colorTextureString = cfunToString;
    }
    var pwfunToString = computeFnToString(actorProperty, actorProperty.getPiecewiseFunction, numIComps);
    if (model.pwfTextureString !== pwfunToString) {
      var pwfWidth = 1024;
      var pwfSize = pwfWidth * textureHeight;
      var pwfTable = new Uint8Array(pwfSize);
      var pwfun = actorProperty.getPiecewiseFunction();
      model.pwfTexture.resetFormatAndType();
      if (pwfun) {
        var pwfFloatTable = new Float32Array(pwfSize);
        var _tmpTable = new Float32Array(pwfWidth);
        for (var _c = 0; _c < numIComps; ++_c) {
          pwfun = actorProperty.getPiecewiseFunction(_c);
          if (pwfun === null) {
            pwfFloatTable.fill(1);
          } else {
            var pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, _tmpTable, 1);
            if (iComps) {
              for (var _i6 = 0; _i6 < pwfWidth; _i6++) {
                pwfFloatTable[_c * pwfWidth * 2 + _i6] = _tmpTable[_i6];
                pwfFloatTable[_c * pwfWidth * 2 + _i6 + pwfWidth] = _tmpTable[_i6];
              }
            } else {
              for (var _i7 = 0; _i7 < pwfWidth; _i7++) {
                pwfFloatTable[_c * pwfWidth * 2 + _i7] = _tmpTable[_i7];
              }
            }
          }
        }
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);
      } else {
        pwfTable.fill(255);
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);
      }
      model.pwfTextureString = pwfunToString;
    }
    var _model$renderable$get = model.renderable.getClosestIJKAxis(), ijkMode = _model$renderable$get.ijkMode;
    var slice = model.renderable.getSlice();
    if (ijkMode !== model.renderable.getSlicingMode()) {
      slice = model.renderable.getSliceAtPosition(slice);
    }
    var nSlice = Math.round(slice);
    var ext = image.getExtent();
    var sliceOffset;
    if (ijkMode === SlicingMode2.I) {
      sliceOffset = nSlice - ext[0];
    }
    if (ijkMode === SlicingMode2.J) {
      sliceOffset = nSlice - ext[2];
    }
    if (ijkMode === SlicingMode2.K || ijkMode === SlicingMode2.NONE) {
      sliceOffset = nSlice - ext[4];
    }
    var toString = "".concat(slice, "A").concat(image.getMTime(), "A").concat(imgScalars.getMTime(), "B").concat(publicAPI.getMTime(), "C").concat(model.renderable.getSlicingMode(), "D").concat(actor.getProperty().getMTime());
    if (model.VBOBuildString !== toString) {
      var dims = image.getDimensions();
      if (iType === InterpolationType2.NEAREST) {
        if (numComp === 4) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(Filter.NEAREST);
        } else {
          model.openGLTexture.setMinificationFilter(Filter.NEAREST);
        }
        model.openGLTexture.setMagnificationFilter(Filter.NEAREST);
      } else {
        if (numComp === 4) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        } else {
          model.openGLTexture.setMinificationFilter(Filter.LINEAR);
        }
        model.openGLTexture.setMagnificationFilter(Filter.LINEAR);
      }
      model.openGLTexture.setWrapS(Wrap.CLAMP_TO_EDGE);
      model.openGLTexture.setWrapT(Wrap.CLAMP_TO_EDGE);
      var sliceSize = dims[0] * dims[1] * numComp;
      var ptsArray = new Float32Array(12);
      var tcoordArray = new Float32Array(8);
      for (var _i8 = 0; _i8 < 4; _i8++) {
        tcoordArray[_i8 * 2] = _i8 % 2 ? 1 : 0;
        tcoordArray[_i8 * 2 + 1] = _i8 > 1 ? 1 : 0;
      }
      var sliceDepth = [SlicingMode2.X, SlicingMode2.Y, SlicingMode2.Z].includes(model.renderable.getSlicingMode()) ? slice : nSlice;
      var spatialExt = image.getSpatialExtent();
      var basicScalars = imgScalars.getData();
      var scalars = null;
      if (ijkMode === SlicingMode2.I) {
        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);
        var id = 0;
        for (var k = 0; k < dims[2]; k++) {
          for (var j = 0; j < dims[1]; j++) {
            var bsIdx = (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;
            id = (k * dims[1] + j) * numComp;
            scalars.set(basicScalars.subarray(bsIdx, bsIdx + numComp), id);
          }
        }
        dims[0] = dims[1];
        dims[1] = dims[2];
        ptsArray[0] = sliceDepth;
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = sliceDepth;
        ptsArray[4] = spatialExt[3];
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = sliceDepth;
        ptsArray[7] = spatialExt[2];
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = sliceDepth;
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode2.J) {
        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);
        var _id = 0;
        for (var _k = 0; _k < dims[2]; _k++) {
          for (var _i9 = 0; _i9 < dims[0]; _i9++) {
            var _bsIdx = (_i9 + sliceOffset * dims[0] + _k * dims[0] * dims[1]) * numComp;
            _id = (_k * dims[0] + _i9) * numComp;
            scalars.set(basicScalars.subarray(_bsIdx, _bsIdx + numComp), _id);
          }
        }
        dims[1] = dims[2];
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = sliceDepth;
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = sliceDepth;
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = sliceDepth;
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = sliceDepth;
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode2.K || ijkMode === SlicingMode2.NONE) {
        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = sliceDepth;
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = spatialExt[2];
        ptsArray[5] = sliceDepth;
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = spatialExt[3];
        ptsArray[8] = sliceDepth;
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = sliceDepth;
      } else {
        vtkErrorMacro2("Reformat slicing not yet supported.");
      }
      model.openGLTexture.create2DFromRaw(dims[0], dims[1], numComp, imgScalars.getDataType(), scalars);
      model.openGLTexture.activate();
      model.openGLTexture.sendParameters();
      model.openGLTexture.deactivate();
      var points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      var tcoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcoordArray
      });
      tcoords.setName("tcoords");
      var cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      var cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        tcoords,
        cellOffset: 0
      });
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
}
var DEFAULT_VALUES = {
  VBOBuildTime: 0,
  VBOBuildString: null,
  openGLTexture: null,
  tris: null,
  imagemat: null,
  imagematinv: null,
  colorTexture: null,
  pwfTexture: null,
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastTextureComponents: 0
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  model.tris = vtkHelper.newInstance();
  model.openGLTexture = vtkOpenGLTexture$1.newInstance();
  model.colorTexture = vtkOpenGLTexture$1.newInstance();
  model.pwfTexture = vtkOpenGLTexture$1.newInstance();
  model.imagemat = mat4_exports.identity(new Float64Array(16));
  model.imagematinv = mat4_exports.identity(new Float64Array(16));
  setGet(publicAPI, model, []);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  vtkOpenGLImageMapper(publicAPI, model);
}
var newInstance2 = newInstance(extend, "vtkOpenGLImageMapper");
registerOverride("vtkImageMapper", newInstance2);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageSlice.js
function vtkOpenGLImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageSlice");
  publicAPI.buildPass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaqueZBufferPass = function(renderPass) {
    publicAPI.traverseOpaquePass(renderPass);
  };
  publicAPI.traverseOpaquePass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(function(child) {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(function(child) {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.opaqueZBufferPass = function(prepass, renderPass) {
    return publicAPI.opaquePass(prepass, renderPass);
  };
  publicAPI.opaquePass = function(prepass, renderPass) {
    if (prepass) {
      model.context.depthMask(true);
    }
  };
  publicAPI.translucentPass = function(prepass, renderPass) {
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = function() {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      mat4_exports.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      mat4_exports.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES2 = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null
};
function extend2(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLImageSlice(publicAPI, model);
}
var newInstance3 = newInstance(extend2, "vtkOpenGLImageSlice");
registerOverride("vtkImageSlice", newInstance3);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Volume.js
function vtkOpenGLVolume(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVolume");
  publicAPI.buildPass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementVolumeCount();
    }
  };
  publicAPI.traverseVolumePass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children[0].traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.volumePass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = function() {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      mat4_exports.copy(model.MCWCMatrix, model.renderable.getMatrix());
      mat4_exports.transpose(model.MCWCMatrix, model.MCWCMatrix);
      if (model.renderable.getIsIdentity()) {
        mat3_exports.identity(model.normalMatrix);
      } else {
        mat3_exports.fromMat4(model.normalMatrix, model.MCWCMatrix);
        mat3_exports.invert(model.normalMatrix, model.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return {
      mcwc: model.MCWCMatrix,
      normalMatrix: model.normalMatrix
    };
  };
}
var DEFAULT_VALUES3 = {};
function extend3(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.normalMatrix = new Float64Array(9);
  model.MCWCMatrix = new Float64Array(16);
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLVolume(publicAPI, model);
}
var newInstance4 = newInstance(extend3, "vtkOpenGLVolume");
registerOverride("vtkVolume", newInstance4);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeVS.glsl.js
var vtkVolumeVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeFS.glsl.js
var vtkVolumeFS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkVolumeFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the volume mappers fragment shader

// the output of this shader
//VTK::Output::Dec

varying vec3 vertexVCVSOutput;

// first declare the settings from the mapper
// that impact the code paths in here

// always set vtkNumComponents 1,2,3,4
//VTK::NumComponents

// possibly define vtkTrilinearOn
//VTK::TrilinearOn

// possibly define vtkIndependentComponents
//VTK::IndependentComponentsOn

// possibly define any "proportional" components
//VTK::vtkProportionalComponents

// Define the blend mode to use
#define vtkBlendMode //VTK::BlendMode

// Possibly define vtkImageLabelOutlineOn
//VTK::ImageLabelOutlineOn

#ifdef vtkImageLabelOutlineOn
uniform int outlineThickness;
uniform float vpWidth;
uniform float vpHeight;
uniform float vpOffsetX;
uniform float vpOffsetY;
uniform mat4 PCWCMatrix;
uniform mat4 vWCtoIDX;
#endif

// define vtkLightComplexity
//VTK::LightComplexity
#if vtkLightComplexity > 0
uniform float vSpecularPower;
uniform float vAmbient;
uniform float vDiffuse;
uniform float vSpecular;
//VTK::Light::Dec
#endif

//VTK::VolumeShadowOn
//VTK::SurfaceShadowOn
//VTK::localAmbientOcclusionOn
//VTK::LAO::Dec
//VTK::VolumeShadow::Dec

// define vtkComputeNormalFromOpacity
//VTK::vtkComputeNormalFromOpacity

// possibly define vtkGradientOpacityOn
//VTK::GradientOpacityOn
#ifdef vtkGradientOpacityOn
uniform float goscale0;
uniform float goshift0;
uniform float gomin0;
uniform float gomax0;
#if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)
uniform float goscale1;
uniform float goshift1;
uniform float gomin1;
uniform float gomax1;
#if vtkNumComponents >= 3
uniform float goscale2;
uniform float goshift2;
uniform float gomin2;
uniform float gomax2;
#endif
#if vtkNumComponents >= 4
uniform float goscale3;
uniform float goshift3;
uniform float gomin3;
uniform float gomax3;
#endif
#endif
#endif

// if you want to see the raw tiled
// data in webgl1 uncomment the following line
// #define debugtile

// camera values
uniform float camThick;
uniform float camNear;
uniform float camFar;
uniform int cameraParallel;

// values describing the volume geometry
uniform vec3 vOriginVC;
uniform vec3 vSpacing;
uniform ivec3 volumeDimensions; // 3d texture dimensions
uniform vec3 vPlaneNormal0;
uniform float vPlaneDistance0;
uniform vec3 vPlaneNormal1;
uniform float vPlaneDistance1;
uniform vec3 vPlaneNormal2;
uniform float vPlaneDistance2;
uniform vec3 vPlaneNormal3;
uniform float vPlaneDistance3;
uniform vec3 vPlaneNormal4;
uniform float vPlaneDistance4;
uniform vec3 vPlaneNormal5;
uniform float vPlaneDistance5;

//VTK::ClipPlane::Dec

// opacity and color textures
uniform sampler2D otexture;
uniform float oshift0;
uniform float oscale0;
uniform sampler2D ctexture;
uniform float cshift0;
uniform float cscale0;

// jitter texture
uniform sampler2D jtexture;

// some 3D texture values
uniform float sampleDistance;
uniform vec3 vVCToIJK;

// the heights defined below are the locations
// for the up to four components of the tfuns
// the tfuns have a height of 2XnumComps pixels so the
// values are computed to hit the middle of the two rows
// for that component
#ifdef vtkIndependentComponentsOn
#if vtkNumComponents == 2
uniform float mix0;
uniform float mix1;
#define height0 0.25
#define height1 0.75
#endif
#if vtkNumComponents == 3
uniform float mix0;
uniform float mix1;
uniform float mix2;
#define height0 0.17
#define height1 0.5
#define height2 0.83
#endif
#if vtkNumComponents == 4
uniform float mix0;
uniform float mix1;
uniform float mix2;
uniform float mix3;
#define height0 0.125
#define height1 0.375
#define height2 0.625
#define height3 0.875
#endif
#endif

#if vtkNumComponents >= 2
uniform float oshift1;
uniform float oscale1;
uniform float cshift1;
uniform float cscale1;
#endif
#if vtkNumComponents >= 3
uniform float oshift2;
uniform float oscale2;
uniform float cshift2;
uniform float cscale2;
#endif
#if vtkNumComponents >= 4
uniform float oshift3;
uniform float oscale3;
uniform float cshift3;
uniform float cscale3;
#endif

uniform vec4 ipScalarRangeMin;
uniform vec4 ipScalarRangeMax;

// declaration for intermixed geometry
//VTK::ZBuffer::Dec

//=======================================================================
// global and custom variables (a temporary section before photorealistics rendering module is complete)
vec3 rayDirVC;
float sampleDistanceISVS;
float sampleDistanceIS;

#define SQRT3    1.7321
#define INV4PI   0.0796
#define EPSILON  0.001
#define PI       3.1415
#define PI2      9.8696

//=======================================================================
// Webgl2 specific version of functions
#if __VERSION__ == 300

uniform highp sampler3D texture1;

vec4 getTextureValue(vec3 pos)
{
  vec4 tmp = texture(texture1, pos);
#if vtkNumComponents == 1
  tmp.a = tmp.r;
#endif
#if vtkNumComponents == 2
  tmp.a = tmp.g;
#endif
#if vtkNumComponents == 3
  tmp.a = length(tmp.rgb);
#endif
  return tmp;
}

//=======================================================================
// WebGL1 specific version of functions
#else

uniform sampler2D texture1;

uniform float texWidth;
uniform float texHeight;
uniform int xreps;
uniform int xstride;
uniform int ystride;

// if computing trilinear values from multiple z slices
#ifdef vtkTrilinearOn
vec4 getTextureValue(vec3 ijk)
{
  float zoff = 1.0/float(volumeDimensions.z);
  vec4 val1 = getOneTextureValue(ijk);
  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));

  float indexZ = float(volumeDimensions)*ijk.z;
  float zmix =  indexZ - floor(indexZ);

  return mix(val1, val2, zmix);
}

vec4 getOneTextureValue(vec3 ijk)
#else // nearest or fast linear
vec4 getTextureValue(vec3 ijk)
#endif
{
  vec3 tdims = vec3(volumeDimensions);

#ifdef debugtile
  vec2 tpos = vec2(ijk.x, ijk.y);
  vec4 tmp = texture2D(texture1, tpos);
  tmp.a = 1.0;

#else
  int z = int(ijk.z * tdims.z);
  int yz = z / xreps;
  int xz = z - yz*xreps;

  int tileWidth = volumeDimensions.x/xstride;
  int tileHeight = volumeDimensions.y/ystride;

  xz *= tileWidth;
  yz *= tileHeight;

  float ni = float(xz) + (ijk.x*float(tileWidth));
  float nj = float(yz) + (ijk.y*float(tileHeight));

  vec2 tpos = vec2(ni/texWidth, nj/texHeight);

  vec4 tmp = texture2D(texture1, tpos);

#if vtkNumComponents == 1
  tmp.a = tmp.r;
#endif
#if vtkNumComponents == 2
  tmp.g = tmp.a;
#endif
#if vtkNumComponents == 3
  tmp.a = length(tmp.rgb);
#endif
#endif

  return tmp;
}

// End of Webgl1 specific code
//=======================================================================
#endif

//=======================================================================
// transformation between VC and IS space

// convert vector position from idx to vc
#if vtkLightComplexity > 0
vec3 IStoVC(vec3 posIS){
  vec3 posVC = posIS / vVCToIJK;
  return posVC.x * vPlaneNormal0 + 
         posVC.y * vPlaneNormal2 + 
         posVC.z * vPlaneNormal4 + 
         vOriginVC;
}

// convert vector position from vc to idx
vec3 VCtoIS(vec3 posVC){
  posVC = posVC - vOriginVC;
  posVC = vec3(
    dot(posVC, vPlaneNormal0),
    dot(posVC, vPlaneNormal2),
    dot(posVC, vPlaneNormal4));  
  return posVC * vVCToIJK;
}
#endif

//Rotate vector to view coordinate
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
void rotateToViewCoord(inout vec3 dirIS){
  dirIS.xyz =
    dirIS.x * vPlaneNormal0 +
    dirIS.y * vPlaneNormal2 +
    dirIS.z * vPlaneNormal4;
}

//Rotate vector to idx coordinate
vec3 rotateToIDX(vec3 dirVC){
  vec3 dirIS;
  dirIS.xyz = vec3(
    dot(dirVC, vPlaneNormal0),
    dot(dirVC, vPlaneNormal2),
    dot(dirVC, vPlaneNormal4));  
  return dirIS;
}
#endif

//=======================================================================
// Given a normal compute the gradient opacity factors
float computeGradientOpacityFactor(
  float normalMag, float goscale, float goshift, float gomin, float gomax)
{
#if defined(vtkGradientOpacityOn)
  return clamp(normalMag * goscale + goshift, gomin, gomax);
#else
  return 1.0;
#endif
}

//=======================================================================
// compute the normal and gradient magnitude for a position, uses forward difference
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
  #ifdef vtkComputeNormalFromOpacity
    #ifdef vtkGradientOpacityOn
      vec4 computeNormalForDensity(vec3 pos, float scalar, vec3 tstep, out mat3 scalarInterp, out vec3 secondaryGradientMag)
      {
        vec4 result;
        scalarInterp[0][0] = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)).a;
        scalarInterp[0][1] = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)).a;
        scalarInterp[0][2] = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)).a;
        // look up scalar values for computing secondary gradient
        scalarInterp[1][0] = getTextureValue(pos + vec3(2.0*tstep.x, 0.0, 0.0)).a;
        scalarInterp[1][1] = getTextureValue(pos + vec3(0.0, 2.0*tstep.y, 0.0)).a;
        scalarInterp[1][2] = getTextureValue(pos + vec3(0.0, 0.0, 2.0*tstep.z)).a;
        scalarInterp[2][0] = getTextureValue(pos + vec3(tstep.x, tstep.y, 0.0)).a;
        scalarInterp[2][1] = getTextureValue(pos + vec3(tstep.x, 0.0, tstep.z)).a;
        scalarInterp[2][2] = getTextureValue(pos + vec3(0.0, tstep.y, tstep.z)).a;
        result.x = scalarInterp[0][0] - scalar;
        result.y = scalarInterp[0][1] - scalar;
        result.z = scalarInterp[0][2] - scalar;
        // divide by spacing
        result.xyz /= vSpacing;
        result.w = length(result.xyz);
        rotateToViewCoord(result.xyz);
        secondaryGradientMag.x = length(vec3(scalarInterp[1][0] - scalarInterp[0][0],
                                             scalarInterp[2][0] - scalarInterp[0][0],
                                             scalarInterp[2][1] - scalarInterp[0][0]) / vSpacing);
        secondaryGradientMag.y = length(vec3(scalarInterp[2][0] - scalarInterp[0][1],
                                             scalarInterp[1][1] - scalarInterp[0][1],
                                             scalarInterp[2][2] - scalarInterp[0][1]) / vSpacing);
        secondaryGradientMag.z = length(vec3(scalarInterp[2][1] - scalarInterp[0][2],
                                             scalarInterp[2][2] - scalarInterp[0][2],
                                             scalarInterp[1][2] - scalarInterp[0][2]) / vSpacing);
        if (length(result.xyz) > 0.0) {
          return vec4(normalize(result.xyz),result.w);
        } else {
          return vec4(0.0);
        }
      }

      vec4 computeDensityNormal(float scalar, float gradientMag, mat3 scalarInterp, vec3 secondaryGradientMag)
      {
        vec4 opacityG;
        vec3 opacityInterp = vec3(0.0);
        float opacity = texture2D(otexture, vec2(scalar * oscale0 + oshift0, 0.5)).r;
        if (gradientMag >= 0.0){
          opacity *= computeGradientOpacityFactor(gradientMag, goscale0, goshift0, gomin0, gomax0);
        }
        opacityInterp.x = texture2D(otexture, vec2(scalarInterp[0][0] * oscale0 + oshift0, 0.5)).r; 
        if (secondaryGradientMag.x >= 0.0){
          opacityInterp.x *= computeGradientOpacityFactor(secondaryGradientMag.x, goscale0, goshift0, gomin0, gomax0);
        }
    
        opacityInterp.y = texture2D(otexture, vec2(scalarInterp[0][1] * oscale0 + oshift0, 0.5)).r;
        if (secondaryGradientMag.y >= 0.0){
          opacityInterp.y *= computeGradientOpacityFactor(secondaryGradientMag.y, goscale0, goshift0, gomin0, gomax0);
        }

        opacityInterp.z = texture2D(otexture, vec2(scalarInterp[0][2] * oscale0 + oshift0, 0.5)).r;
        if (secondaryGradientMag.z >= 0.0){
          opacityInterp.z *= computeGradientOpacityFactor(secondaryGradientMag.z, goscale0, goshift0, gomin0, gomax0);
        }

        opacityG.xyz = opacityInterp - vec3(opacity,opacity,opacity);
        // divide by spacing
        opacityG.xyz /= vSpacing;
        opacityG.w = length(opacityG.xyz);
        rotateToViewCoord(opacityG.xyz);
        if (length(opacityG.xyz) > 0.0) {  
          return vec4(normalize(opacityG.xyz),opacityG.w);
        } else {
          return vec4(0.0);
        }
      } 

    #else
    //if gradient opacity not on but using density gradient
      vec4 computeDensityNormal(float scalar, vec3 scalarInterp) 
      { 
        vec4 opacityG; 
        float opacity = texture2D(otexture, vec2(scalar * oscale0 + oshift0, 0.5)).r; 
        opacityG.x = texture2D(otexture, vec2(scalarInterp.x * oscale0 + oshift0, 0.5)).r - opacity; 
        opacityG.y = texture2D(otexture, vec2(scalarInterp.y * oscale0 + oshift0, 0.5)).r - opacity; 
        opacityG.z = texture2D(otexture, vec2(scalarInterp.z * oscale0 + oshift0, 0.5)).r - opacity; 
        // divide by spacing 
        opacityG.xyz /= vSpacing; 
        opacityG.w = length(opacityG.xyz); 
        // rotate to View Coords 
        rotateToViewCoord(opacityG.xyz);
        if (length(opacityG.xyz) > 0.0) {     
          return vec4(normalize(opacityG.xyz),opacityG.w); 
        } else { 
          return vec4(0.0); 
        } 
      } 
      vec4 computeNormalForDensity(vec3 pos, float scalar, vec3 tstep, out vec3 scalarInterp) 
      { 
        vec4 result; 
        scalarInterp.x = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)).a; 
        scalarInterp.y = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)).a; 
        scalarInterp.z = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)).a; 
        result.x = scalarInterp.x - scalar; 
        result.y = scalarInterp.y - scalar; 
        result.z = scalarInterp.z - scalar;   
        // divide by spacing
        result.xyz /= vSpacing;
        result.w = length(result.xyz); 
        // rotate to View Coords 
        rotateToViewCoord(result.xyz);      
        if (length(result.xyz) > 0.0) {     
          return vec4(normalize(result.xyz),result.w); 
        } else { 
          return vec4(0.0); 
        } 
      }           
    #endif
  #endif
  // compute scalar density
  vec4 computeNormal(vec3 pos, float scalar, vec3 tstep)  
  {  
    vec4 result;  
    result.x = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)).a - scalar;  
    result.y = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)).a - scalar;  
    result.z = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)).a - scalar;  
    // divide by spacing  
    result.xyz /= vSpacing;  
    result.w = length(result.xyz);
    if (result.w > 0.0){
      // rotate to View Coords  
      rotateToViewCoord(result.xyz);
      return vec4(normalize(result.xyz),result.w);  
    } else {
      return vec4(0.0);
    }
  }  
#endif

#ifdef vtkImageLabelOutlineOn
vec3 fragCoordToIndexSpace(vec4 fragCoord) {
  vec4 pcPos = vec4(
    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,
    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,
    (fragCoord.z - 0.5) * 2.0,
    1.0);

  vec4 worldCoord = PCWCMatrix * pcPos;
  vec4 vertex = (worldCoord/worldCoord.w);

  vec3 index = (vWCtoIDX * vertex).xyz;

  // half voxel fix for labelmapOutline 
  return (index + vec3(0.5)) / vec3(volumeDimensions);
}
#endif

//=======================================================================
// compute the normals and gradient magnitudes for a position
// for independent components
mat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)
{
  mat4 result;
  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;
  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;
  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;

  // divide by spacing
  distX /= vSpacing.x;
  distY /= vSpacing.y;
  distZ /= vSpacing.z;

  mat3 rot;
  rot[0] = vPlaneNormal0;
  rot[1] = vPlaneNormal2;
  rot[2] = vPlaneNormal4;

#if !defined(vtkComponent0Proportional)
  result[0].xyz = vec3(distX.r, distY.r, distZ.r);
  result[0].a = length(result[0].xyz);
  result[0].xyz *= rot;
  if (result[0].w > 0.0)
  {
    result[0].xyz /= result[0].w;
  }
#endif

// optionally compute the 2nd component
#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)
  result[1].xyz = vec3(distX.g, distY.g, distZ.g);
  result[1].a = length(result[1].xyz);
  result[1].xyz *= rot;
  if (result[1].w > 0.0)
  {
    result[1].xyz /= result[1].w;
  }
#endif

// optionally compute the 3rd component
#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)
  result[2].xyz = vec3(distX.b, distY.b, distZ.b);
  result[2].a = length(result[2].xyz);
  result[2].xyz *= rot;
  if (result[2].w > 0.0)
  {
    result[2].xyz /= result[2].w;
  }
#endif

// optionally compute the 4th component
#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)
  result[3].xyz = vec3(distX.a, distY.a, distZ.a);
  result[3].a = length(result[3].xyz);
  result[3].xyz *= rot;
  if (result[3].w > 0.0)
  {
    result[3].xyz /= result[3].w;
  }
#endif

  return result;
}

//=======================================================================
// global shadow - secondary ray
#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)
float random()
{ 
  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);
  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;
  uint pcg_state = floatBitsToUint(jitter);
  uint state = pcg_state;
  pcg_state = pcg_state * uint(747796405) + uint(2891336453);
  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);
  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;
}
#endif

#ifdef VolumeShadowOn
// henyey greenstein phase function
float phase_function(float cos_angle)
{
  // divide by 2.0 instead of 4pi to increase intensity
  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;
}

// Computes the intersection between a ray and a box
struct Hit
{
  float tmin;
  float tmax;
};

struct Ray
{
  vec3 origin;
  vec3 dir;
  vec3 invDir;
};

bool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)
{
  vec3 tbot = r.invDir * (boundMin - r.origin);
  vec3 ttop = r.invDir * (boundMax - r.origin);
  vec3 tmin = min(ttop, tbot);
  vec3 tmax = max(ttop, tbot);
  vec2 t = max(tmin.xx, tmin.yz);
  float t0 = max(t.x, t.y);
  t = min(tmax.xx, tmax.yz);
  float t1 = min(t.x, t.y);
  hit.tmin = t0;
  hit.tmax = t1;
  return t1 > max(t0,0.0);
}

// As BBoxIntersect requires the inverse of the ray coords,
// this function is used to avoid numerical issues
void safe_0_vector(inout Ray ray)
{
  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;
  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;
  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;
}

float volume_shadow(vec3 posIS, vec3 lightDirNormIS)
{
  float shadow = 1.0;
  float opacity = 0.0;

  // modify sample distance with a random number between 0.8 and 1.0
  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(0.8, 1.0, random());
  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;
  
  // in case the first sample near surface has a very tiled light ray, we need to offset start position 
  posIS += sampleDistanceISVS_jitter * lightDirNormIS;  

  // compute the start and end points for the ray
  Ray ray;
  Hit hit;  
  ray.origin = posIS;
  ray.dir = lightDirNormIS;
  safe_0_vector(ray);
  ray.invDir = 1.0/ray.dir;
  
  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))
  {
    return 1.0;
  }
  vec4 scalar = vec4(0.0);
  float maxdist = hit.tmax;
  if(maxdist < EPSILON) {
    return 1.0;
  }

  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach
  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);
  maxdist = min(maxdist,maxgi);

  // support gradient opacity
  #ifdef vtkGradientOpacityOn
    vec4 normal;
  #endif

  vec3 current_step = sampleDistanceISVS_jitter * lightDirNormIS;
  float maxSteps = ceil(maxdist/sampleDistanceISVS_jitter);
  float opacityDelta = 0.0;

  for (float i = 0.0; i < maxSteps; i++)
  {
    scalar = getTextureValue(posIS);
    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;
    #ifdef vtkGradientOpacityOn 
      normal = computeNormal(posIS, scalar.a, vec3(1.0/vec3(volumeDimensions))); 
      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
    #endif    
    shadow *= 1.0 - opacity;

    // optimization: early termination
    if (shadow < EPSILON){
      return 0.0;
    }

    // optimization: increase/decrease sample distance based on changed in opacity value
    opacityDelta = opacityPrev - opacity;
    opacityPrev = opacity;
    if (opacityDelta > 0.0){
      current_step *= 0.9;
    } else if (opacityDelta < 0.0){
      current_step *= 1.1;
    }
    posIS += current_step;
  }

  return shadow;  
}

vec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)
{
  vec3 vertLight = vec3(0.0);
  vec3 secondary_contrib = vec3(0.0);
  // here we assume only positional light, no effect of cones
  for (int i = 0; i < lightNum; i++)
  {
    #if(vtkLightComplexity==3)
      if (lightPositional[i] == 1){
        vertLight = lightPositionVC[i] - IStoVC(posIS);
      }else{
        vertLight = - lightDirectionVC[i];
      }
    #else
      vertLight = - lightDirectionVC[i];
    #endif
    // here we assume achromatic light, only intensity
    float dDotL = dot(viewDirectionVC, normalize(vertLight));
    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity
    float phase_attenuation = 0.5;
    if (abs(anisotropy) > EPSILON){
      phase_attenuation = phase_function(dDotL);
    }
    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));
    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;     
    secondary_contrib += tColor * vAmbient;
  } 
  return secondary_contrib;
}
#endif

//=======================================================================
// local ambient occlusion
#ifdef localAmbientOcclusionOn
vec3 sample_direction_uniform(int i)
{
  float rand = random() * 0.5;
  float theta = PI2 * (kernelSample[i][0] + rand);
  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;
  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));
}

// return a matrix that transform startDir into z axis; startDir should be normalized
mat3 zBaseRotationalMatrix(vec3 startDir){
  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));
  float cosA = startDir.z;
  float k = 1.0 / (1.0 + cosA);
  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,
              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,
              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);
  return matrix;
}

float computeLAO(vec3 posIS, float opacity, vec3 lightDir, vec4 normal){
  // apply LAO only at selected locations, otherwise return full brightness
  if (normal.w > 0.0 && opacity > 0.05){
    float total_transmittance = 0.0;
    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));
    vec3 currPos, randomDirStep;
    float weight, transmittance, opacity;
    for (int i = 0; i < kernelSize; i++)
    {
      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;
      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));
      currPos = posIS;
      transmittance = 1.0;
      for (int j = 0; j < kernelRadius ; j++){
        currPos += randomDirStep;
        // check if it's at clipping plane, if so return full brightness
        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){
          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;
          #ifdef vtkGradientOpacityOn
             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
          #endif
          transmittance *= 1.0 - opacity;
        }
        else{
          break;
        }
      }
      total_transmittance += transmittance / float(kernelRadius) * weight;

      // early termination if fully translucent
      if (total_transmittance > 1.0 - EPSILON){
        return 1.0;
      }
    }
    // average transmittance and reduce variance
    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0); 
  } else {
    return 1.0;
  }
}
#endif

//=======================================================================
// surface light contribution
#if vtkLightComplexity > 0
  void applyLighting(inout vec3 tColor, vec4 normal)
  {
    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    float df, sf = 0.0;
    for (int i = 0; i < lightNum; i++){
        df = abs(dot(normal.rgb, -lightDirectionVC[i]));
        diffuse += df * lightColor[i];
        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);
        specular += sf * lightColor[i];
    }
    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;
  }
  #ifdef SurfaceShadowOn
  #if vtkLightComplexity < 3
    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif        
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float ndotL,vdotR;
        vertLightDirection = lightDirectionVC[i];
        ndotL = dot(normal.xyz, vertLightDirection);
        if (ndotL < 0.0 && twoSidedLighting)
        {
          ndotL = -ndotL;
        }
        if (ndotL > 0.0)
        {
          diffuse += ndotL * lightColor[i];
          //specular
          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
          if (vdotR > 0.0)
          {
            specular += pow(vdotR, vSpecularPower) * lightColor[i];
          }
        }
        #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
        #endif
      }  
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else 
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif    
    }
  #else
    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif      
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float distance,attenuation,ndotL,vdotR;
        vec3 lightDir;
        if (lightPositional[i] == 1){
          lightDir = lightDirectionVC[i];
          vertLightDirection = posVC - lightPositionVC[i]; 
          distance = length(vertLightDirection);
          vertLightDirection = normalize(vertLightDirection);
          attenuation = 1.0 / (lightAttenuation[i].x
                              + lightAttenuation[i].y * distance
                              + lightAttenuation[i].z * distance * distance);
          // per OpenGL standard cone angle is 90 or less for a spot light
          if (lightConeAngle[i] <= 90.0){
            float coneDot = dot(vertLightDirection, lightDir);
            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone
              attenuation = attenuation * pow(coneDot, lightExponent[i]);
            }
            else {
              attenuation = 0.0;
            }
          }
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * attenuation * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif          
        } else {
          vertLightDirection = lightDirectionVC[i];
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif          
        }
      }
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else 
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif
    }
  #endif 
  #endif
#endif

//=======================================================================
// Given a texture value compute the color and opacity
//
vec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)
{
#ifdef vtkImageLabelOutlineOn
  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space
  vec4 centerValue = getTextureValue(centerPosIS);
  bool pixelOnBorder = false;
  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));

  // Get alpha of segment from opacity function.
  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;

  // Only perform outline check on fragments rendering voxels that aren't invisible.
  // Saves a bunch of needless checks on the background.
  // TODO define epsilon when building shader?
  if (float(tColor.a) > 0.01) {
    for (int i = -outlineThickness; i <= outlineThickness; i++) {
      for (int j = -outlineThickness; j <= outlineThickness; j++) {
        if (i == 0 || j == 0) {
          continue;
        }

        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
          gl_FragCoord.y + float(j),
          gl_FragCoord.z, gl_FragCoord.w);

        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
        vec4 value = getTextureValue(neighborPosIS);

        // If any of my neighbours are not the same value as I
        // am, this means I am on the border of the segment.
        // We can break the loops
        if (any(notEqual(value, centerValue))) {
          pixelOnBorder = true;
          break;
        }
      }

      if (pixelOnBorder == true) {
        break;
      }
    }

    // If I am on the border, I am displayed at full opacity
    if (pixelOnBorder == true) {
      tColor.a = 1.0;
    }
  }

#else
  // compute the normal and gradient magnitude if needed
  // We compute it as a vec4 if possible otherwise a mat4
  //
  vec4 goFactor = vec4(1.0,1.0,1.0,1.0);

  // compute the normal vectors as needed
  #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)
    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)
      mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
      #if !defined(vtkComponent0Proportional)
        vec4 normal0 = normalMat[0];
      #endif
      #if !defined(vtkComponent1Proportional)
        vec4 normal1 = normalMat[1];
      #endif
      #if vtkNumComponents > 2
        #if !defined(vtkComponent2Proportional)
          vec4 normal2 = normalMat[2];
        #endif
        #if vtkNumComponents > 3
          #if !defined(vtkComponent3Proportional)
            vec4 normal3 = normalMat[3];
          #endif
        #endif
      #endif
    #else
      vec4 normalLight;
      #ifdef vtkComputeNormalFromOpacity
        #ifdef vtkGradientOpacityOn
          mat3 scalarInterp;  
          vec3 secondaryGradientMag;  
          vec4 normal0 = computeNormalForDensity(posIS, tValue.a, tstep, scalarInterp, secondaryGradientMag);  
          normalLight = computeDensityNormal(tValue.a, normal0.w, scalarInterp,secondaryGradientMag);       
          if (length(normalLight) == 0.0){  
            normalLight = normal0;   
          }                      
        #else
          vec3 scalarInterp;  
          vec4 normal0 = computeNormalForDensity(posIS, tValue.a, tstep, scalarInterp);  
          if (length(normal0)>0.0){  
            normalLight = computeDensityNormal(tValue.a,scalarInterp);  
            if (length(normalLight)==0.0){  
              normalLight = normal0;  
            }  
          }                
        #endif
      #else 
        vec4 normal0 = computeNormal(posIS, tValue.a, tstep);  
        normalLight = normal0;             
      #endif
    #endif
  #endif

  // compute gradient opacity factors as needed
  #if defined(vtkGradientOpacityOn)
    #if !defined(vtkComponent0Proportional)
      goFactor.x =
        computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);
    #endif
    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)
      #if !defined(vtkComponent1Proportional)
        goFactor.y =
          computeGradientOpacityFactor(normal1.a, goscale1, goshift1, gomin1, gomax1);
      #endif
      #if vtkNumComponents > 2
        #if !defined(vtkComponent2Proportional)
          goFactor.z =
            computeGradientOpacityFactor(normal2.a, goscale2, goshift2, gomin2, gomax2);
        #endif
        #if vtkNumComponents > 3
          #if !defined(vtkComponent3Proportional)
            goFactor.w =
              computeGradientOpacityFactor(normal3.a, goscale3, goshift3, gomin3, gomax3);
          #endif
        #endif
      #endif
    #endif
  #endif

  // single component is always independent
  #if vtkNumComponents == 1
    vec4 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5));
    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
    if (tColor.a < EPSILON){
      return vec4(0.0);
    }    
  #endif

  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2
    vec4 tColor = mix0*texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0));
    #if !defined(vtkComponent0Proportional)
      tColor.a = goFactor.x*mix0*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;
    #else
      float pwfValue = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;
      tColor *= pwfValue;
      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix0));
    #endif

    vec3 tColor1 = mix1*texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;
    #if !defined(vtkComponent1Proportional)
      tColor.a += goFactor.y*mix1*texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;
    #else
      float pwfValue = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;
      tColor1 *= pwfValue;
      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix1));
    #endif

    #if vtkNumComponents >= 3
      vec3 tColor2 = mix2*texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;
      #if !defined(vtkComponent2Proportional)
        tColor.a += goFactor.z*mix2*texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;
      #else
        float pwfValue = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;
        tColor2 *= pwfValue;
        tColor.a *= mix(pwfValue, 1.0, (1.0 - mix2));
      #endif

      #if vtkNumComponents >= 4
        vec3 tColor3 = mix3*texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;
        #if !defined(vtkComponent3Proportional)
          tColor.a += goFactor.w*mix3*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;
        #else
          float pwfValue = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;
          tColor3 *= pwfValue;
          tColor.a *= mix(pwfValue, 1.0, (1.0 - mix3));
        #endif
      #endif
    #endif
  #else // then not independent

  #if vtkNumComponents == 2
    float lum = tValue.r * cscale0 + cshift0;
    float alpha = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;
    vec4 tColor = vec4(lum, lum, lum, alpha);
  #endif
  #if vtkNumComponents == 3
    vec4 tColor;
    tColor.r = tValue.r * cscale0 + cshift0;
    tColor.g = tValue.g * cscale1 + cshift1;
    tColor.b = tValue.b * cscale2 + cshift2;
    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;
  #endif
  #if vtkNumComponents == 4
    vec4 tColor;
    tColor.r = tValue.r * cscale0 + cshift0;
    tColor.g = tValue.g * cscale1 + cshift1;
    tColor.b = tValue.b * cscale2 + cshift2;
    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;
  #endif
  #endif // dependent

  // apply lighting if requested as appropriate
  #if vtkLightComplexity > 0
    #if !defined(vtkComponent0Proportional) 
      #if vtkNumComponents == 1
    
        #ifdef SurfaceShadowOn
            #if vtkLightComplexity < 3
                vec3 tColorS = applyLightingDirectional(posIS, tColor, normalLight);
            #else
                vec3 tColorS = applyLightingPositional(posIS, tColor, normalLight, IStoVC(posIS));
            #endif
        #endif

        #ifdef VolumeShadowOn
          vec3 tColorVS = applyShadowRay(tColor.rgb, posIS, rayDirVC);
          #ifdef SurfaceShadowOn
            float vol_coef = volumetricScatteringBlending * (1.0 - tColor.a / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);
            tColor.rgb = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;
          #else
            tColor.rgb = tColorVS;
          #endif
        #else
            tColor.rgb = tColorS;
        #endif
        
      #else
        applyLighting(tColor.rgb, normal0);
      #endif
    #endif

    #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2
      #if !defined(vtkComponent1Proportional)
        applyLighting(tColor1, normal1);
      #endif
    #if vtkNumComponents >= 3
      #if !defined(vtkComponent2Proportional)
        applyLighting(tColor2, normal2);
      #endif
    #if vtkNumComponents >= 4
      #if !defined(vtkComponent3Proportional)
        applyLighting(tColor3, normal3);
      #endif
    #endif
    #endif
    #endif
  #endif

// perform final independent blend as needed
#if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2
  tColor.rgb += tColor1;
#if vtkNumComponents >= 3
  tColor.rgb += tColor2;
#if vtkNumComponents >= 4
  tColor.rgb += tColor3;
#endif
#endif
#endif

#endif







return tColor;
}

bool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {
  bool withinRange = false;
  #if vtkNumComponents == 1
    if (val.r >= min.r && val.r <= max.r) {
      withinRange = true;
    }
  #endif
  #if defined(vtkIndependentComponentsOn) && vtkNumComponents == 2
     if (val.r >= min.r && val.r <= max.r &&
        val.g >= min.g && val.g <= max.g) {
      withinRange = true;
    }
  #endif
  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 3
    if (all(greaterThanEqual(val, ipScalarRangeMin)) &&
        all(lessThanEqual(val, ipScalarRangeMax))) {
      withinRange = true;
    }
  #endif
  return withinRange;
}

//=======================================================================
// Apply the specified blend mode operation along the ray's path.
//
void applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)
{
  vec3 tstep = 1.0/tdims;

  // start slightly inside and apply some jitter
  vec3 delta = endIS - posIS;
  vec3 stepIS = normalize(delta)*sampleDistanceIS;
  float raySteps = length(delta)/sampleDistanceIS;

  // avoid 0.0 jitter
  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;
  float stepsTraveled = jitter;

  // local vars for the loop
  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
  vec4 tValue;
  vec4 tColor;

  // if we have less than one step then pick the middle point
  // as our value
  // if (raySteps <= 1.0)
  // {
  //   posIS = (posIS + endIS)*0.5;
  // }

  // Perform initial step at the volume boundary
  // compute the scalar
  tValue = getTextureValue(posIS);

  #if vtkBlendMode == 0 // COMPOSITE_BLEND
    // now map through opacity and color
    tColor = getColorForValue(tValue, posIS, tstep);

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);
      gl_FragData[0] = tColor;
      return;
    }

    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);
    color = vec4(tColor.rgb*tColor.a, tColor.a);
    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);

      float mix = (1.0 - color.a);

      // this line should not be needed but nvidia seems to not handle
      // the break correctly on windows/chrome 58 angle
      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));

      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
      stepsTraveled++;
      posIS += stepIS;
      if (color.a > 0.99) { color.a = 1.0; break; }
    }

    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)
    {
      posIS = endIS;

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);

      float mix = (1.0 - color.a);
      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
    }

    gl_FragData[0] = vec4(color.rgb/color.a, color.a);
  #endif
  #if vtkBlendMode == 1 || vtkBlendMode == 2
    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND
    // Find maximum/minimum intensity along the ray.

    // Define the operation we will use (min or max)
    #if vtkBlendMode == 1
    #define OP max
    #else
    #define OP min
    #endif

    // If the clipping range is shorter than the sample distance
    // we can skip the sampling loop along the ray.
    if (raySteps <= 1.0)
    {
      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);
      return;
    }

    vec4 value = tValue;
    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // Update the maximum value if necessary
      value = OP(tValue, value);

      // Otherwise, continue along the ray
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;
    tValue = getTextureValue(posIS);
    value = OP(tValue, value);

    // Now map through opacity and color
    gl_FragData[0] = getColorForValue(value, posIS, tstep);
  #endif
  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND
    vec4 sum = vec4(0.);

    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;
    }

    if (raySteps <= 1.0) {
      gl_FragData[0] = getColorForValue(sum, posIS, tstep);
      return;
    }

    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.
      // Notes:
      // - We are comparing all values in the texture to see if any of them
      //   are outside of the scalar range. In the future we might want to allow
      //   scalar ranges for each component.
      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
        // Sum the values across each step in the path
        sum += tValue;
      }
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;

    // compute the scalar
    tValue = getTextureValue(posIS);

    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation
    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;

      stepsTraveled++;
    }

    #if vtkBlendMode == 3 // Average
      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);
    #endif

    gl_FragData[0] = getColorForValue(sum, posIS, tstep);
  #endif
}

//=======================================================================
// Compute a new start and end point for a given ray based
// on the provided bounded clipping plane (aka a rectangle)
void getRayPointIntersectionBounds(
  vec3 rayPos, vec3 rayDir,
  vec3 planeDir, float planeDist,
  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,
  float vSize1, float vSize2)
{
  float result = dot(rayDir, planeDir);
  if (abs(result) < 1e-6)
  {
    return;
  }
  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;
  vec3 xposVC = rayPos + rayDir*result;
  vec3 vxpos = xposVC - vOriginVC;
  vec2 vpos = vec2(
    dot(vxpos, vPlaneX),
    dot(vxpos, vPlaneY));

  // on some apple nvidia systems this does not work
  // if (vpos.x < 0.0 || vpos.x > vSize1 ||
  //     vpos.y < 0.0 || vpos.y > vSize2)
  // even just
  // if (vpos.x < 0.0 || vpos.y < 0.0)
  // fails
  // so instead we compute a value that represents in and out
  //and then compute the return using this value
  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds
  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out

  tbounds = mix(
   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value
   tbounds, // out value
   check);  // 0 in 1 out
}

//=======================================================================
// given a
// - ray direction (rayDir)
// - starting point (vertexVCVSOutput)
// - bounding planes of the volume
// - optionally depth buffer values
// - far clipping plane
// compute the start/end distances of the ray we need to cast
vec2 computeRayDistances(vec3 rayDir, vec3 tdims)
{
  vec2 dists = vec2(100.0*camFar, -1.0);

  vec3 vSize = vSpacing*tdims;

  // all this is in View Coordinates
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);

  //VTK::ClipPlane::Impl

  // do not go behind front clipping plane
  dists.x = max(0.0,dists.x);

  // do not go PAST far clipping plane
  float farDist = -camThick/rayDir.z;
  dists.y = min(farDist,dists.y);

  // Do not go past the zbuffer value if set
  // This is used for intermixing opaque geometry
  //VTK::ZBuffer::Impl

  return dists;
}

//=======================================================================
// Compute the index space starting position (pos) and end
// position
//
void computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)
{
  // compute starting and ending values in volume space
  pos = vertexVCVSOutput + dists.x*rayDir;
  pos = pos - vOriginVC;
  // convert to volume basis and origin
  pos = vec3(
    dot(pos, vPlaneNormal0),
    dot(pos, vPlaneNormal2),
    dot(pos, vPlaneNormal4));

  endPos = vertexVCVSOutput + dists.y*rayDir;
  endPos = endPos - vOriginVC;
  endPos = vec3(
    dot(endPos, vPlaneNormal0),
    dot(endPos, vPlaneNormal2),
    dot(endPos, vPlaneNormal4));

  float delta = length(endPos - pos);

  pos *= vVCToIJK;
  endPos *= vVCToIJK;

  float delta2 = length(endPos - pos);
  sampleDistanceIS = sampleDistance*delta2/delta;
  #ifdef VolumeShadowOn
    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;
  #endif
}

void main()
{

  if (cameraParallel == 1)
  {
    // Camera is parallel, so the rayDir is just the direction of the camera.
    rayDirVC = vec3(0.0, 0.0, -1.0);
  } else {
    // camera is at 0,0,0 so rayDir for perspective is just the vc coord
    rayDirVC = normalize(vertexVCVSOutput);
  }

  vec3 tdims = vec3(volumeDimensions);

  // compute the start and end points for the ray
  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);

  // do we need to composite? aka does the ray have any length
  // If not, bail out early
  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)
  {
    discard;
  }

  // IS = Index Space
  vec3 posIS;
  vec3 endIS;
  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);

  // Perform the blending operation along the ray
  applyBlend(posIS, endIS, tdims);
}
`;

// node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var vtkWarningMacro2 = vtkWarningMacro;
var vtkErrorMacro3 = vtkErrorMacro;
function arrayEquals(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function vtkOpenGLVolumeMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVolumeMapper");
  publicAPI.buildPass = function() {
    model.zBufferTexture = null;
  };
  publicAPI.opaqueZBufferPass = function(prepass, renderPass) {
    if (prepass) {
      var zbt = renderPass.getZBufferTexture();
      if (zbt !== model.zBufferTexture) {
        model.zBufferTexture = zbt;
      }
    }
  };
  publicAPI.volumePass = function(prepass, renderPass) {
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.jitterTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLVolume = publicAPI.getFirstAncestorOfType("vtkOpenGLVolume");
      var actor = model.openGLVolume.getRenderable();
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      var ren = model.openGLRenderer.getRenderable();
      model.openGLCamera = model.openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      publicAPI.renderPiece(ren, actor);
    }
  };
  publicAPI.buildShaders = function(shaders, ren, actor) {
    publicAPI.getShaderTemplate(shaders, ren, actor);
    publicAPI.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.getShaderTemplate = function(shaders, ren, actor) {
    shaders.Vertex = vtkVolumeVS;
    shaders.Fragment = vtkVolumeFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = function(shaders, ren, actor) {
    var FSSource = shaders.Fragment;
    var iType = actor.getProperty().getInterpolationType();
    if (iType === InterpolationType.LINEAR) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TrilinearOn", "#define vtkTrilinearOn").result;
    }
    var vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ImageLabelOutlineOn", "#define vtkImageLabelOutlineOn").result;
    }
    var numComp = model.scalarTexture.getComponents();
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::NumComponents", "#define vtkNumComponents ".concat(numComp)).result;
    var iComps = actor.getProperty().getIndependentComponents();
    if (iComps) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::IndependentComponentsOn", "#define vtkIndependentComponentsOn").result;
      var proportionalComponents = [];
      for (var nc = 0; nc < numComp; nc++) {
        if (actor.getProperty().getOpacityMode(nc) === OpacityMode.PROPORTIONAL) {
          proportionalComponents.push("#define vtkComponent".concat(nc, "Proportional"));
        }
      }
      if (proportionalComponents.length > 0) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::vtkProportionalComponents", proportionalComponents.join("\n")).result;
      }
    }
    var ext = model.currentInput.getSpatialExtent();
    var spc = model.currentInput.getSpacing();
    var vsize = new Float64Array(3);
    vec3_exports.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    var maxSamples = vec3_exports.length(vsize) / model.renderable.getSampleDistance();
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::MaximumSamplesValue", "".concat(Math.ceil(maxSamples))).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LightComplexity", "#define vtkLightComplexity ".concat(model.lastLightComplexity)).result;
    if (model.lastLightComplexity > 0) {
      if (model.renderable.getVolumetricScatteringBlending() > 0) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::VolumeShadowOn", "#define VolumeShadowOn").result;
      }
      if (model.renderable.getVolumetricScatteringBlending() < 1) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::SurfaceShadowOn", "#define SurfaceShadowOn").result;
      }
      if (model.renderable.getVolumetricScatteringBlending() === 0 && model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::localAmbientOcclusionOn", "#define localAmbientOcclusionOn").result;
      }
    }
    model.gopacity = actor.getProperty().getUseGradientOpacity(0);
    for (var _nc = 1; iComps && !model.gopacity && _nc < numComp; ++_nc) {
      if (actor.getProperty().getUseGradientOpacity(_nc)) {
        model.gopacity = true;
      }
    }
    if (model.gopacity) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::GradientOpacityOn", "#define vtkGradientOpacityOn").result;
    }
    if (model.renderable.getComputeNormalFromOpacity()) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::vtkComputeNormalFromOpacity", "#define vtkComputeNormalFromOpacity").result;
    }
    if (model.zBufferTexture !== null) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", ["uniform sampler2D zBufferTexture;", "uniform float vpWidth;", "uniform float vpHeight;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpWidth, gl_FragCoord.y/vpHeight));", "float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;", "zdepth = zdepth * 2.0 - 1.0;", "zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;", "zdepth = -zdepth/rayDir.z;", "dists.y = min(zdepth,dists.y);"]).result;
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::BlendMode", "".concat(model.renderable.getBlendMode())).result;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderClippingPlane(shaders, ren, actor);
  };
  publicAPI.replaceShaderLight = function(shaders, ren, actor) {
    if (model.lastLightComplexity === 0) {
      return;
    }
    var FSSource = shaders.Fragment;
    var lightNum = 0;
    ren.getLights().forEach(function(light) {
      if (light.getSwitch()) {
        lightNum += 1;
      }
    });
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", ["uniform int lightNum;", "uniform bool twoSidedLighting;", "uniform vec3 lightColor[".concat(lightNum, "];"), "uniform vec3 lightDirectionVC[".concat(lightNum, "]; // normalized"), "uniform vec3 lightHalfAngleVC[".concat(lightNum, "];"), "//VTK::Light::Dec"], false).result;
    if (model.lastLightComplexity === 3) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", ["uniform vec3 lightPositionVC[".concat(lightNum, "];"), "uniform vec3 lightAttenuation[".concat(lightNum, "];"), "uniform float lightConeAngle[".concat(lightNum, "];"), "uniform float lightExponent[".concat(lightNum, "];"), "uniform int lightPositional[".concat(lightNum, "];")], false).result;
    }
    if (model.renderable.getVolumetricScatteringBlending() > 0) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::VolumeShadow::Dec", ["uniform float volumetricScatteringBlending;", "uniform float giReach;", "uniform float volumeShadowSamplingDistFactor;", "uniform float anisotropy;", "uniform float anisotropy2;"], false).result;
    }
    if (model.renderable.getVolumetricScatteringBlending() === 0 && model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LAO::Dec", ["uniform int kernelRadius;", "uniform vec2 kernelSample[".concat(model.renderable.getLAOKernelRadius(), "];"), "uniform int kernelSize;"], false).result;
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderClippingPlane = function(shaders, ren, actor) {
    var FSSource = shaders.Fragment;
    if (model.renderable.getClippingPlanes().length > 0) {
      var clipPlaneSize = model.renderable.getClippingPlanes().length;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ClipPlane::Dec", ["uniform vec3 vClipPlaneNormals[6];", "uniform float vClipPlaneDistances[6];", "//VTK::ClipPlane::Dec"], false).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ClipPlane::Impl", ["for(int i = 0; i < ".concat(clipPlaneSize, "; i++) {"), "  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);", "  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];", "  if (rayDirRatio == 0.0)", "  {", "    if (equationResult < 0.0) dists.x = dists.y;", "    continue;", "  }", "  float result = -1.0 * equationResult / rayDirRatio;", "  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);", "  else dists.x = max(dists.x, result);", "}", "//VTK::ClipPlane::Impl"], false).result;
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.getNeedToRebuildShaders = function(cellBO, ren, actor) {
    var lightComplexity = 0;
    if (actor.getProperty().getShade() && model.renderable.getBlendMode() === BlendMode.COMPOSITE_BLEND) {
      lightComplexity = 0;
      model.numberOfLights = 0;
      ren.getLights().forEach(function(light) {
        var status = light.getSwitch();
        if (status > 0) {
          model.numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }
        if (lightComplexity === 1 && (model.numberOfLights > 1 || light.getIntensity() !== 1 || !light.lightTypeIsHeadLight())) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      });
    }
    var needRebuild = false;
    if (model.lastLightComplexity !== lightComplexity) {
      model.lastLightComplexity = lightComplexity;
      needRebuild = true;
    }
    var numComp = model.scalarTexture.getComponents();
    var iComps = actor.getProperty().getIndependentComponents();
    var usesProportionalComponents = false;
    var proportionalComponents = [];
    if (iComps) {
      for (var nc = 0; nc < numComp; nc++) {
        proportionalComponents.push(actor.getProperty().getOpacityMode(nc));
      }
      if (proportionalComponents.length > 0) {
        usesProportionalComponents = true;
      }
    }
    var ext = model.currentInput.getSpatialExtent();
    var spc = model.currentInput.getSpacing();
    var vsize = new Float64Array(3);
    vec3_exports.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    var maxSamples = vec3_exports.length(vsize) / model.renderable.getSampleDistance();
    var state = {
      interpolationType: actor.getProperty().getInterpolationType(),
      useLabelOutline: actor.getProperty().getUseLabelOutline(),
      numComp,
      usesProportionalComponents,
      iComps,
      maxSamples,
      useGradientOpacity: actor.getProperty().getUseGradientOpacity(0),
      blendMode: model.renderable.getBlendMode(),
      proportionalComponents
    };
    if (!model.previousState || model.previousState.interpolationType !== state.interpolationType || model.previousState.useLabelOutline !== state.useLabelOutline || model.previousState.numComp !== state.numComp || model.previousState.usesProportionalComponents !== state.usesProportionalComponents || model.previousState.iComps !== state.iComps || model.previousState.maxSamples !== state.maxSamples || model.previousState.useGradientOpacity !== state.useGradientOpacity || model.previousState.blendMode !== state.blendMode || !arrayEquals(model.previousState.proportionalComponents, state.proportionalComponents)) {
      model.previousState = _objectSpread({}, state);
      return true;
    }
    if (cellBO.getProgram() === 0 || needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || !!model.lastZBufferTexture !== !!model.zBufferTexture || cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime()) {
      model.lastZBufferTexture = model.zBufferTexture;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = function(cellBO, ren, actor) {
    model.lastBoundBO = cellBO;
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      var shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      var newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
    publicAPI.getClippingPlaneShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isAttributeUsed("vertexDC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), "vertexDC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro3("Error setting vertexDC in shader VAO.");
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    program.setUniformi("texture1", model.scalarTexture.getTextureUnit());
    program.setUniformf("sampleDistance", model.renderable.getSampleDistance());
    var volInfo = model.scalarTexture.getVolumeInfo();
    var ipScalarRange = model.renderable.getIpScalarRange();
    var minVals = [];
    var maxVals = [];
    for (var i = 0; i < 4; i++) {
      minVals[i] = ipScalarRange[0] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];
      maxVals[i] = ipScalarRange[1] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];
      minVals[i] = (minVals[i] - volInfo.offset[i]) / volInfo.scale[i];
      maxVals[i] = (maxVals[i] - volInfo.offset[i]) / volInfo.scale[i];
    }
    program.setUniform4f("ipScalarRangeMin", minVals[0], minVals[1], minVals[2], minVals[3]);
    program.setUniform4f("ipScalarRangeMax", maxVals[0], maxVals[1], maxVals[2], maxVals[3]);
    if (model.zBufferTexture !== null) {
      program.setUniformi("zBufferTexture", model.zBufferTexture.getTextureUnit());
      var size = model._useSmallViewport ? [model._smallViewportWidth, model._smallViewportHeight] : model._openGLRenderWindow.getFramebufferSize();
      program.setUniformf("vpWidth", size[0]);
      program.setUniformf("vpHeight", size[1]);
    }
  };
  publicAPI.setCameraShaderParameters = function(cellBO, ren, actor) {
    var keyMats = model.openGLCamera.getKeyMatrices(ren);
    var actMats = model.openGLVolume.getKeyMatrices();
    mat4_exports.multiply(model.modelToView, keyMats.wcvc, actMats.mcwc);
    var program = cellBO.getProgram();
    var cam = model.openGLCamera.getRenderable();
    var crange = cam.getClippingRange();
    program.setUniformf("camThick", crange[1] - crange[0]);
    program.setUniformf("camNear", crange[0]);
    program.setUniformf("camFar", crange[1]);
    var bounds = model.currentInput.getBounds();
    var dims = model.currentInput.getDimensions();
    var pos = new Float64Array(3);
    var dir = new Float64Array(3);
    var dcxmin = 1;
    var dcxmax = -1;
    var dcymin = 1;
    var dcymax = -1;
    for (var i = 0; i < 8; ++i) {
      vec3_exports.set(pos, bounds[i % 2], bounds[2 + Math.floor(i / 2) % 2], bounds[4 + Math.floor(i / 4)]);
      vec3_exports.transformMat4(pos, pos, model.modelToView);
      if (!cam.getParallelProjection()) {
        vec3_exports.normalize(dir, pos);
        var t = -crange[0] / pos[2];
        vec3_exports.scale(pos, dir, t);
      }
      vec3_exports.transformMat4(pos, pos, keyMats.vcpc);
      dcxmin = Math.min(pos[0], dcxmin);
      dcxmax = Math.max(pos[0], dcxmax);
      dcymin = Math.min(pos[1], dcymin);
      dcymax = Math.max(pos[1], dcymax);
    }
    program.setUniformf("dcxmin", dcxmin);
    program.setUniformf("dcxmax", dcxmax);
    program.setUniformf("dcymin", dcymin);
    program.setUniformf("dcymax", dcymax);
    if (program.isUniformUsed("cameraParallel")) {
      program.setUniformi("cameraParallel", cam.getParallelProjection());
    }
    var ext = model.currentInput.getSpatialExtent();
    var spc = model.currentInput.getSpacing();
    var vsize = new Float64Array(3);
    vec3_exports.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    program.setUniform3f("vSpacing", spc[0], spc[1], spc[2]);
    vec3_exports.set(pos, ext[0], ext[2], ext[4]);
    model.currentInput.indexToWorldVec3(pos, pos);
    vec3_exports.transformMat4(pos, pos, model.modelToView);
    program.setUniform3f("vOriginVC", pos[0], pos[1], pos[2]);
    var i2wmat4 = model.currentInput.getIndexToWorld();
    mat4_exports.multiply(model.idxToView, model.modelToView, i2wmat4);
    mat3_exports.multiply(model.idxNormalMatrix, keyMats.normalMatrix, actMats.normalMatrix);
    mat3_exports.multiply(model.idxNormalMatrix, model.idxNormalMatrix, model.currentInput.getDirection());
    var maxSamples = vec3_exports.length(vsize) / model.renderable.getSampleDistance();
    if (maxSamples > model.renderable.getMaximumSamplesPerRay()) {
      vtkWarningMacro2("The number of steps required ".concat(Math.ceil(maxSamples), " is larger than the\n        specified maximum number of steps ").concat(model.renderable.getMaximumSamplesPerRay(), ".\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples."));
    }
    var vctoijk = new Float64Array(3);
    vec3_exports.set(vctoijk, 1, 1, 1);
    vec3_exports.divide(vctoijk, vctoijk, vsize);
    program.setUniform3f("vVCToIJK", vctoijk[0], vctoijk[1], vctoijk[2]);
    program.setUniform3i("volumeDimensions", dims[0], dims[1], dims[2]);
    if (!model._openGLRenderWindow.getWebgl2()) {
      var volInfo = model.scalarTexture.getVolumeInfo();
      program.setUniformf("texWidth", model.scalarTexture.getWidth());
      program.setUniformf("texHeight", model.scalarTexture.getHeight());
      program.setUniformi("xreps", volInfo.xreps);
      program.setUniformi("xstride", volInfo.xstride);
      program.setUniformi("ystride", volInfo.ystride);
    }
    var normal = new Float64Array(3);
    var pos2 = new Float64Array(3);
    for (var _i = 0; _i < 6; ++_i) {
      switch (_i) {
        case 1:
          vec3_exports.set(normal, -1, 0, 0);
          vec3_exports.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 2:
          vec3_exports.set(normal, 0, 1, 0);
          vec3_exports.set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 3:
          vec3_exports.set(normal, 0, -1, 0);
          vec3_exports.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 4:
          vec3_exports.set(normal, 0, 0, 1);
          vec3_exports.set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 5:
          vec3_exports.set(normal, 0, 0, -1);
          vec3_exports.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 0:
        default:
          vec3_exports.set(normal, 1, 0, 0);
          vec3_exports.set(pos2, ext[1], ext[3], ext[5]);
          break;
      }
      vec3_exports.transformMat3(normal, normal, model.idxNormalMatrix);
      vec3_exports.transformMat4(pos2, pos2, model.idxToView);
      var dist = -1 * vec3_exports.dot(pos2, normal);
      program.setUniform3f("vPlaneNormal".concat(_i), normal[0], normal[1], normal[2]);
      program.setUniformf("vPlaneDistance".concat(_i), dist);
    }
    if (actor.getProperty().getUseLabelOutline()) {
      var image = model.currentInput;
      var worldToIndex = image.getWorldToIndex();
      program.setUniformMatrix("vWCtoIDX", worldToIndex);
      mat4_exports.invert(model.projectionToWorld, keyMats.wcpc);
      program.setUniformMatrix("PCWCMatrix", model.projectionToWorld);
      var size = publicAPI.getRenderTargetSize();
      program.setUniformf("vpWidth", size[0]);
      program.setUniformf("vpHeight", size[1]);
      var offset = publicAPI.getRenderTargetOffset();
      program.setUniformf("vpOffsetX", offset[0] / size[0]);
      program.setUniformf("vpOffsetY", offset[1] / size[1]);
    }
    mat4_exports.invert(model.projectionToView, keyMats.vcpc);
    program.setUniformMatrix("PCVCMatrix", model.projectionToView);
    if (model.lastLightComplexity === 0) {
      return;
    }
    var lightNum = 0;
    var lightColor = [];
    var lightDir = [];
    var halfAngle = [];
    ren.getLights().forEach(function(light) {
      var status = light.getSwitch();
      if (status > 0) {
        var dColor = light.getColor();
        var intensity = light.getIntensity();
        lightColor[0 + lightNum * 3] = dColor[0] * intensity;
        lightColor[1 + lightNum * 3] = dColor[1] * intensity;
        lightColor[2 + lightNum * 3] = dColor[2] * intensity;
        var ldir = light.getDirection();
        vec3_exports.set(normal, ldir[0], ldir[1], ldir[2]);
        vec3_exports.transformMat3(normal, normal, keyMats.normalMatrix);
        vec3_exports.normalize(normal, normal);
        lightDir[0 + lightNum * 3] = normal[0];
        lightDir[1 + lightNum * 3] = normal[1];
        lightDir[2 + lightNum * 3] = normal[2];
        halfAngle[0 + lightNum * 3] = -0.5 * normal[0];
        halfAngle[1 + lightNum * 3] = -0.5 * normal[1];
        halfAngle[2 + lightNum * 3] = -0.5 * (normal[2] - 1);
        lightNum++;
      }
    });
    program.setUniformi("twoSidedLighting", ren.getTwoSidedLighting());
    program.setUniformi("lightNum", lightNum);
    program.setUniform3fv("lightColor", lightColor);
    program.setUniform3fv("lightDirectionVC", lightDir);
    program.setUniform3fv("lightHalfAngleVC", halfAngle);
    if (model.lastLightComplexity === 3) {
      lightNum = 0;
      var lightPositionVC = [];
      var lightAttenuation = [];
      var lightConeAngle = [];
      var lightExponent = [];
      var lightPositional = [];
      ren.getLights().forEach(function(light) {
        var status = light.getSwitch();
        if (status > 0) {
          var attenuation = light.getAttenuationValues();
          lightAttenuation[0 + lightNum * 3] = attenuation[0];
          lightAttenuation[1 + lightNum * 3] = attenuation[1];
          lightAttenuation[2 + lightNum * 3] = attenuation[2];
          lightExponent[lightNum] = light.getExponent();
          lightConeAngle[lightNum] = light.getConeAngle();
          lightPositional[lightNum] = light.getPositional();
          var lp = light.getTransformedPosition();
          vec3_exports.transformMat4(lp, lp, model.modelToView);
          lightPositionVC[0 + lightNum * 3] = lp[0];
          lightPositionVC[1 + lightNum * 3] = lp[1];
          lightPositionVC[2 + lightNum * 3] = lp[2];
          lightNum += 1;
        }
      });
      program.setUniform3fv("lightPositionVC", lightPositionVC);
      program.setUniform3fv("lightAttenuation", lightAttenuation);
      program.setUniformfv("lightConeAngle", lightConeAngle);
      program.setUniformfv("lightExponent", lightExponent);
      program.setUniformiv("lightPositional", lightPositional);
    }
    if (model.renderable.getVolumetricScatteringBlending() > 0) {
      program.setUniformf("giReach", model.renderable.getGlobalIlluminationReach());
      program.setUniformf("volumetricScatteringBlending", model.renderable.getVolumetricScatteringBlending());
      program.setUniformf("volumeShadowSamplingDistFactor", model.renderable.getVolumeShadowSamplingDistFactor());
      program.setUniformf("anisotropy", model.renderable.getAnisotropy());
      program.setUniformf("anisotropy2", Math.pow(model.renderable.getAnisotropy(), 2));
    }
    if (model.renderable.getVolumetricScatteringBlending() === 0 && model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0) {
      var ks = model.renderable.getLAOKernelSize();
      program.setUniformi("kernelSize", ks);
      var kernelSample = [];
      for (var _i2 = 0; _i2 < ks; _i2++) {
        kernelSample[_i2 * 2] = Math.random() * 0.5;
        kernelSample[_i2 * 2 + 1] = Math.random() * 0.5;
      }
      program.setUniform2fv("kernelSample", kernelSample);
      program.setUniformi("kernelRadius", model.renderable.getLAOKernelRadius());
    }
  };
  publicAPI.setPropertyShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    program.setUniformi("ctexture", model.colorTexture.getTextureUnit());
    program.setUniformi("otexture", model.opacityTexture.getTextureUnit());
    program.setUniformi("jtexture", model.jitterTexture.getTextureUnit());
    var volInfo = model.scalarTexture.getVolumeInfo();
    var vprop = actor.getProperty();
    var numComp = model.scalarTexture.getComponents();
    var iComps = actor.getProperty().getIndependentComponents();
    if (iComps && numComp >= 2) {
      for (var i = 0; i < numComp; i++) {
        program.setUniformf("mix".concat(i), actor.getProperty().getComponentWeight(i));
      }
    }
    for (var _i3 = 0; _i3 < numComp; _i3++) {
      var target = iComps ? _i3 : 0;
      var sscale = volInfo.scale[_i3];
      var ofun = vprop.getScalarOpacity(target);
      var oRange = ofun.getRange();
      var oscale = sscale / (oRange[1] - oRange[0]);
      var oshift = (volInfo.offset[_i3] - oRange[0]) / (oRange[1] - oRange[0]);
      program.setUniformf("oshift".concat(_i3), oshift);
      program.setUniformf("oscale".concat(_i3), oscale);
      var cfun = vprop.getRGBTransferFunction(target);
      var cRange = cfun.getRange();
      program.setUniformf("cshift".concat(_i3), (volInfo.offset[_i3] - cRange[0]) / (cRange[1] - cRange[0]));
      program.setUniformf("cscale".concat(_i3), sscale / (cRange[1] - cRange[0]));
    }
    if (model.gopacity) {
      if (iComps) {
        for (var nc = 0; nc < numComp; ++nc) {
          var _sscale = volInfo.scale[nc];
          var useGO = vprop.getUseGradientOpacity(nc);
          if (useGO) {
            var gomin = vprop.getGradientOpacityMinimumOpacity(nc);
            var gomax = vprop.getGradientOpacityMaximumOpacity(nc);
            program.setUniformf("gomin".concat(nc), gomin);
            program.setUniformf("gomax".concat(nc), gomax);
            var goRange = [vprop.getGradientOpacityMinimumValue(nc), vprop.getGradientOpacityMaximumValue(nc)];
            program.setUniformf("goscale".concat(nc), _sscale * (gomax - gomin) / (goRange[1] - goRange[0]));
            program.setUniformf("goshift".concat(nc), -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);
          } else {
            program.setUniformf("gomin".concat(nc), 1);
            program.setUniformf("gomax".concat(nc), 1);
            program.setUniformf("goscale".concat(nc), 0);
            program.setUniformf("goshift".concat(nc), 1);
          }
        }
      } else {
        var _sscale2 = volInfo.scale[numComp - 1];
        var _gomin = vprop.getGradientOpacityMinimumOpacity(0);
        var _gomax = vprop.getGradientOpacityMaximumOpacity(0);
        program.setUniformf("gomin0", _gomin);
        program.setUniformf("gomax0", _gomax);
        var _goRange = [vprop.getGradientOpacityMinimumValue(0), vprop.getGradientOpacityMaximumValue(0)];
        program.setUniformf("goscale0", _sscale2 * (_gomax - _gomin) / (_goRange[1] - _goRange[0]));
        program.setUniformf("goshift0", -_goRange[0] * (_gomax - _gomin) / (_goRange[1] - _goRange[0]) + _gomin);
      }
    }
    var vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      var labelOutlineThickness = actor.getProperty().getLabelOutlineThickness();
      program.setUniformi("outlineThickness", labelOutlineThickness);
    }
    if (model.lastLightComplexity > 0) {
      program.setUniformf("vAmbient", vprop.getAmbient());
      program.setUniformf("vDiffuse", vprop.getDiffuse());
      program.setUniformf("vSpecular", vprop.getSpecular());
      program.setUniformf("vSpecularPower", vprop.getSpecularPower());
    }
  };
  publicAPI.getClippingPlaneShaderParameters = function(cellBO, ren, actor) {
    if (model.renderable.getClippingPlanes().length > 0) {
      var keyMats = model.openGLCamera.getKeyMatrices(ren);
      var clipPlaneNormals = [];
      var clipPlaneDistances = [];
      var clipPlanes = model.renderable.getClippingPlanes();
      var clipPlaneSize = clipPlanes.length;
      for (var i = 0; i < clipPlaneSize; ++i) {
        var clipPlaneNormal = clipPlanes[i].getNormal();
        var clipPlanePos = clipPlanes[i].getOrigin();
        vec3_exports.transformMat3(clipPlaneNormal, clipPlaneNormal, keyMats.normalMatrix);
        vec3_exports.transformMat4(clipPlanePos, clipPlanePos, keyMats.wcvc);
        var clipPlaneDist = -1 * vec3_exports.dot(clipPlanePos, clipPlaneNormal);
        clipPlaneNormals.push(clipPlaneNormal[0]);
        clipPlaneNormals.push(clipPlaneNormal[1]);
        clipPlaneNormals.push(clipPlaneNormal[2]);
        clipPlaneDistances.push(clipPlaneDist);
      }
      var program = cellBO.getProgram();
      program.setUniform3fv("vClipPlaneNormals", clipPlaneNormals);
      program.setUniformfv("vClipPlaneDistances", clipPlaneDistances);
    }
  };
  publicAPI.delete = chain(function() {
    if (model._animationRateSubscription) {
      model._animationRateSubscription.unsubscribe();
      model._animationRateSubscription = null;
    }
  }, publicAPI.delete);
  publicAPI.getRenderTargetSize = function() {
    if (model._useSmallViewport) {
      return [model._smallViewportWidth, model._smallViewportHeight];
    }
    var _model$openGLRenderer = model.openGLRenderer.getTiledSizeAndOrigin(), usize = _model$openGLRenderer.usize, vsize = _model$openGLRenderer.vsize;
    return [usize, vsize];
  };
  publicAPI.getRenderTargetOffset = function() {
    var _model$openGLRenderer2 = model.openGLRenderer.getTiledSizeAndOrigin(), lowerLeftU = _model$openGLRenderer2.lowerLeftU, lowerLeftV = _model$openGLRenderer2.lowerLeftV;
    return [lowerLeftU, lowerLeftV];
  };
  publicAPI.renderPieceStart = function(ren, actor) {
    var rwi = ren.getVTKWindow().getInteractor();
    model._useSmallViewport = false;
    if (rwi.isAnimating() && model._lastScale > 1.5) {
      model._useSmallViewport = true;
    }
    if (!model._animationRateSubscription) {
      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(function() {
        if (model.renderable.getAutoAdjustSampleDistances()) {
          var frate = rwi.getRecentAnimationFrameRate();
          var adjustment = rwi.getDesiredUpdateRate() / frate;
          if (adjustment > 1.15 || adjustment < 0.85) {
            model._lastScale *= adjustment;
          }
          if (model._lastScale > 400) {
            model._lastScale = 400;
          }
          if (model._lastScale < 1.5) {
            model._lastScale = 1.5;
          }
        } else {
          model._lastScale = model.renderable.getImageSampleDistance() * model.renderable.getImageSampleDistance();
        }
        var size2 = model._openGLRenderWindow.getFramebufferSize();
        model._smallViewportWidth = Math.ceil(size2[0] / Math.sqrt(model._lastScale));
        model._smallViewportHeight = Math.ceil(size2[1] / Math.sqrt(model._lastScale));
      });
    }
    if (model._useSmallViewport) {
      var size = model._openGLRenderWindow.getFramebufferSize();
      if (model._smallViewportHeight > size[1]) {
        model._smallViewportHeight = size[1];
      }
      if (model._smallViewportWidth > size[0]) {
        model._smallViewportWidth = size[0];
      }
      model.framebuffer.saveCurrentBindingsAndBuffers();
      if (model.framebuffer.getGLFramebuffer() === null) {
        model.framebuffer.create(size[0], size[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        var fbSize = model.framebuffer.getSize();
        if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
          model.framebuffer.create(size[0], size[1]);
          model.framebuffer.populateFramebuffer();
        }
      }
      model.framebuffer.bind();
      var gl = model.context;
      gl.clearColor(0, 0, 0, 0);
      gl.colorMask(true, true, true, true);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.viewport(0, 0, model._smallViewportWidth, model._smallViewportHeight);
      model.fvp = [model._smallViewportWidth / size[0], model._smallViewportHeight / size[1]];
    }
    model.context.disable(model.context.DEPTH_TEST);
    publicAPI.updateBufferObjects(ren, actor);
    var iType = actor.getProperty().getInterpolationType();
    if (iType === InterpolationType.NEAREST) {
      model.scalarTexture.setMinificationFilter(Filter.NEAREST);
      model.scalarTexture.setMagnificationFilter(Filter.NEAREST);
    } else {
      model.scalarTexture.setMinificationFilter(Filter.LINEAR);
      model.scalarTexture.setMagnificationFilter(Filter.LINEAR);
    }
    model.lastBoundBO = null;
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.activate();
    }
  };
  publicAPI.renderPieceDraw = function(ren, actor) {
    var gl = model.context;
    model.scalarTexture.activate();
    model.opacityTexture.activate();
    model.colorTexture.activate();
    model.jitterTexture.activate();
    publicAPI.updateShaders(model.tris, ren, actor);
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();
    model.scalarTexture.deactivate();
    model.colorTexture.deactivate();
    model.opacityTexture.deactivate();
    model.jitterTexture.deactivate();
  };
  publicAPI.renderPieceFinish = function(ren, actor) {
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.deactivate();
    }
    if (model._useSmallViewport) {
      model.framebuffer.restorePreviousBindingsAndBuffers();
      if (model.copyShader === null) {
        model.copyShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec", "attribute vec4 vertexDC;", "uniform vec2 tfactor;", "varying vec2 tcoord;", "void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"), ["//VTK::System::Dec", "//VTK::Output::Dec", "uniform sampler2D texture1;", "varying vec2 tcoord;", "void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"), "");
        var program = model.copyShader;
        model.copyVAO = vtkVertexArrayObject.newInstance();
        model.copyVAO.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.tris.getCABO().bind();
        if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "vertexDC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro3("Error setting vertexDC in copy shader VAO.");
        }
      } else {
        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.copyShader);
      }
      var size = model._openGLRenderWindow.getFramebufferSize();
      model.context.viewport(0, 0, size[0], size[1]);
      var tex = model.framebuffer.getColorTexture();
      tex.activate();
      model.copyShader.setUniformi("texture", tex.getTextureUnit());
      model.copyShader.setUniform2f("tfactor", model.fvp[0], model.fvp[1]);
      var gl = model.context;
      gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      tex.deactivate();
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    }
  };
  publicAPI.renderPiece = function(ren, actor) {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (!model.currentInput) {
      vtkErrorMacro3("No input!");
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = function(ren, actor) {
    if (!publicAPI.getInput()) {
      uninitializeBounds(model.Bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = function(ren, actor) {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = function(ren, actor) {
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = function(ren, actor) {
    var image = model.currentInput;
    if (!image) {
      return;
    }
    var scalars = image.getPointData() && image.getPointData().getScalars();
    if (!scalars) {
      return;
    }
    var vprop = actor.getProperty();
    if (!model.jitterTexture.getHandle()) {
      var oTable = new Uint8Array(32 * 32);
      for (var i = 0; i < 32 * 32; ++i) {
        oTable[i] = 255 * Math.random();
      }
      model.jitterTexture.setMinificationFilter(Filter.LINEAR);
      model.jitterTexture.setMagnificationFilter(Filter.LINEAR);
      model.jitterTexture.create2DFromRaw(32, 32, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);
    }
    var numComp = scalars.getNumberOfComponents();
    var iComps = vprop.getIndependentComponents();
    var numIComps = iComps ? numComp : 1;
    var toString = "".concat(vprop.getMTime());
    if (model.opacityTextureString !== toString) {
      var oWidth = 1024;
      var oSize = oWidth * 2 * numIComps;
      var ofTable = new Float32Array(oSize);
      var tmpTable = new Float32Array(oWidth);
      for (var c = 0; c < numIComps; ++c) {
        var ofun = vprop.getScalarOpacity(c);
        var opacityFactor = model.renderable.getSampleDistance() / vprop.getScalarOpacityUnitDistance(c);
        var oRange = ofun.getRange();
        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
        for (var _i4 = 0; _i4 < oWidth; ++_i4) {
          ofTable[c * oWidth * 2 + _i4] = 1 - Math.pow(1 - tmpTable[_i4], opacityFactor);
          ofTable[c * oWidth * 2 + _i4 + oWidth] = ofTable[c * oWidth * 2 + _i4];
        }
      }
      model.opacityTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.opacityTexture.setMinificationFilter(Filter.LINEAR);
      model.opacityTexture.setMagnificationFilter(Filter.LINEAR);
      if (model._openGLRenderWindow.getWebgl2() || model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.FLOAT, ofTable);
      } else {
        var _oTable = new Uint8Array(oSize);
        for (var _i5 = 0; _i5 < oSize; ++_i5) {
          _oTable[_i5] = 255 * ofTable[_i5];
        }
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.UNSIGNED_CHAR, _oTable);
      }
      model.opacityTextureString = toString;
    }
    toString = "".concat(vprop.getMTime());
    if (model.colorTextureString !== toString) {
      var cWidth = 1024;
      var cSize = cWidth * 2 * numIComps * 3;
      var cTable = new Uint8Array(cSize);
      var _tmpTable = new Float32Array(cWidth * 3);
      for (var _c = 0; _c < numIComps; ++_c) {
        var cfun = vprop.getRGBTransferFunction(_c);
        var cRange = cfun.getRange();
        cfun.getTable(cRange[0], cRange[1], cWidth, _tmpTable, 1);
        for (var _i6 = 0; _i6 < cWidth * 3; ++_i6) {
          cTable[_c * cWidth * 6 + _i6] = 255 * _tmpTable[_i6];
          cTable[_c * cWidth * 6 + _i6 + cWidth * 3] = 255 * _tmpTable[_i6];
        }
      }
      model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.colorTexture.setMinificationFilter(Filter.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      model.colorTextureString = toString;
    }
    toString = "".concat(image.getMTime());
    if (model.scalarTextureString !== toString) {
      var dims = image.getDimensions();
      model.scalarTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.scalarTexture.resetFormatAndType();
      model.scalarTexture.create3DFilterableFromRaw(dims[0], dims[1], dims[2], numComp, scalars.getDataType(), scalars.getData(), model.renderable.getPreferSizeOverAccuracy());
      model.scalarTextureString = toString;
    }
    if (!model.tris.getCABO().getElementCount()) {
      var ptsArray = new Float32Array(12);
      for (var _i7 = 0; _i7 < 4; _i7++) {
        ptsArray[_i7 * 3] = _i7 % 2 * 2 - 1;
        ptsArray[_i7 * 3 + 1] = _i7 > 1 ? 1 : -1;
        ptsArray[_i7 * 3 + 2] = -1;
      }
      var cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      var points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      var cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        cellOffset: 0
      });
    }
    model.VBOBuildTime.modified();
  };
}
var DEFAULT_VALUES4 = {
  context: null,
  VBOBuildTime: null,
  scalarTexture: null,
  scalarTextureString: null,
  opacityTexture: null,
  opacityTextureString: null,
  colorTexture: null,
  colorTextureString: null,
  jitterTexture: null,
  tris: null,
  framebuffer: null,
  copyShader: null,
  copyVAO: null,
  lastXYF: 1,
  targetXYF: 1,
  zBufferTexture: null,
  lastZBufferTexture: null,
  lastLightComplexity: 0,
  fullViewportTime: 1,
  idxToView: null,
  idxNormalMatrix: null,
  modelToView: null,
  projectionToView: null,
  avgWindowArea: 0,
  avgFrameTime: 0
};
function extend4(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = vtkHelper.newInstance();
  model.scalarTexture = vtkOpenGLTexture$1.newInstance();
  model.opacityTexture = vtkOpenGLTexture$1.newInstance();
  model.colorTexture = vtkOpenGLTexture$1.newInstance();
  model.jitterTexture = vtkOpenGLTexture$1.newInstance();
  model.jitterTexture.setWrapS(Wrap.REPEAT);
  model.jitterTexture.setWrapT(Wrap.REPEAT);
  model.framebuffer = vtkOpenGLFramebuffer.newInstance();
  model.idxToView = mat4_exports.identity(new Float64Array(16));
  model.idxNormalMatrix = mat3_exports.identity(new Float64Array(9));
  model.modelToView = mat4_exports.identity(new Float64Array(16));
  model.projectionToView = mat4_exports.identity(new Float64Array(16));
  model.projectionToWorld = mat4_exports.identity(new Float64Array(16));
  model._lastScale = 1;
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLVolumeMapper(publicAPI, model);
}
var newInstance5 = newInstance(extend4, "vtkOpenGLVolumeMapper");
registerOverride("vtkVolumeMapper", newInstance5);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageMapper.js
var SlicingMode3 = Constants.SlicingMode;
var imgFragTemplate = "\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Image::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  //VTK::Image::Sample\n\n  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);\n\n//VTK::RenderEncoder::Impl\n\n  return output;\n}\n";
function computeFnToString2(property, fn, numberOfComponents) {
  var pwfun = fn.apply(property);
  if (pwfun) {
    var iComps = property.getIndependentComponents();
    return "".concat(property.getMTime(), "-").concat(iComps, "-").concat(numberOfComponents);
  }
  return "0";
}
var tmpMat4 = new Float64Array(16);
var tmp2Mat4 = new Float64Array(16);
var tmp3Mat4 = new Float64Array(16);
var ptsArray1 = new Float64Array(4);
var ptsArray2 = new Float64Array(4);
function vtkWebGPUImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUImageMapper");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      model.WebGPUImageSlice = publicAPI.getFirstAncestorOfType("vtkWebGPUImageSlice");
      model.WebGPURenderer = model.WebGPUImageSlice.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
      var ren = model.WebGPURenderer.getRenderable();
      if (model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = function(prepass) {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.opaquePass = function(prepass) {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = function() {
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
    model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.computePipelineHash = function() {
    var ext = model.currentInput.getExtent();
    if (ext[0] === ext[1] || ext[2] === ext[3] || ext[4] === ext[5]) {
      model.dimensions = 2;
      model.pipelineHash = "img2";
    } else {
      model.dimensions = 3;
      model.pipelineHash = "img3";
    }
  };
  publicAPI.updateUBO = function() {
    var utime = model.UBO.getSendTime();
    var actor = model.WebGPUImageSlice.getRenderable();
    var volMapr = actor.getMapper();
    if (publicAPI.getMTime() > utime || model.renderable.getMTime() > utime || actor.getProperty().getMTime() > utime) {
      var image = volMapr.getInputData();
      var center = model.WebGPURenderer.getStabilizedCenterByReference();
      mat4_exports.identity(tmpMat4);
      mat4_exports.translate(tmpMat4, tmpMat4, center);
      var mcwcmat = actor.getMatrix();
      mat4_exports.transpose(tmp2Mat4, mcwcmat);
      mat4_exports.invert(tmp2Mat4, tmp2Mat4);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      var modelToIndex = image.getWorldToIndex();
      mat4_exports.multiply(tmpMat4, modelToIndex, tmpMat4);
      mat4_exports.invert(tmp3Mat4, tmpMat4);
      mat4_exports.fromTranslation(tmp2Mat4, [0.5, 0.5, 0.5]);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      var dims = image.getDimensions();
      mat4_exports.identity(tmp2Mat4);
      mat4_exports.scale(tmp2Mat4, tmp2Mat4, [1 / dims[0], 1 / dims[1], 1 / dims[2]]);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      model.UBO.setArray("SCTCMatrix", tmpMat4);
      var ext = model.currentInput.getExtent();
      var _model$renderable$get = model.renderable.getClosestIJKAxis(), ijkMode = _model$renderable$get.ijkMode;
      var nSlice = model.renderable.getSlice();
      if (ijkMode !== model.renderable.getSlicingMode()) {
        nSlice = model.renderable.getSliceAtPosition(nSlice);
      }
      var axis0 = 2;
      var axis1 = 0;
      var axis2 = 1;
      if (ijkMode === SlicingMode3.I) {
        axis0 = 0;
        axis1 = 1;
        axis2 = 2;
      } else if (ijkMode === SlicingMode3.J) {
        axis0 = 1;
        axis1 = 2;
        axis2 = 0;
      }
      ptsArray1[axis0] = nSlice;
      ptsArray1[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray1[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray1[3] = 1;
      vec4_exports.transformMat4(ptsArray1, ptsArray1, tmp3Mat4);
      model.UBO.setArray("Origin", ptsArray1);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2 + 1] + 0.5;
      ptsArray2[axis2] = ext[axis2 * 2] - 0.5;
      ptsArray2[3] = 1;
      vec4_exports.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      vec4_exports.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1;
      model.UBO.setArray("Axis1", ptsArray2);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2] - 0.5;
      ptsArray2[axis2] = ext[axis2 * 2 + 1] + 0.5;
      ptsArray2[3] = 1;
      vec4_exports.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      vec4_exports.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1;
      model.UBO.setArray("Axis2", ptsArray2);
      var cScale = [1, 1, 1, 1];
      var cShift = [0, 0, 0, 0];
      var tView = model.textureViews[0];
      var tScale = tView.getTexture().getScale();
      var numComp = tView.getTexture().getNumberOfComponents();
      var iComps = false;
      for (var i = 0; i < numComp; i++) {
        var cw = actor.getProperty().getColorWindow();
        var cl = actor.getProperty().getColorLevel();
        var target = iComps ? i : 0;
        var cfun = actor.getProperty().getRGBTransferFunction(target);
        if (cfun) {
          var cRange = cfun.getRange();
          cw = cRange[1] - cRange[0];
          cl = 0.5 * (cRange[1] + cRange[0]);
        }
        cScale[i] = tScale / cw;
        cShift[i] = -cl / cw + 0.5;
      }
      model.UBO.setArray("cScale", cScale);
      model.UBO.setArray("cShift", cShift);
      model.UBO.sendIfNeeded(model.device);
    }
  };
  publicAPI.updateLUTImage = function() {
    var actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    var tView = publicAPI.getTextureViews()[0];
    tView.getTexture().getNumberOfComponents();
    var numIComps = 1;
    var cfunToString = computeFnToString2(actorProperty, actorProperty.getRGBTransferFunction, numIComps);
    if (model.colorTextureString !== cfunToString) {
      model.numRows = numIComps;
      var colorArray = new Uint8Array(model.numRows * 2 * model.rowLength * 4);
      var cfun = actorProperty.getRGBTransferFunction();
      if (cfun) {
        var tmpTable = new Float32Array(model.rowLength * 3);
        for (var c = 0; c < numIComps; c++) {
          cfun = actorProperty.getRGBTransferFunction(c);
          var cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], model.rowLength, tmpTable, 1);
          {
            for (var _i = 0; _i < model.rowLength; _i++) {
              var _idx = c * model.rowLength * 8 + _i * 4;
              colorArray[_idx] = 255 * tmpTable[_i * 3];
              colorArray[_idx + 1] = 255 * tmpTable[_i * 3 + 1];
              colorArray[_idx + 2] = 255 * tmpTable[_i * 3 + 2];
              colorArray[_idx + 3] = 255;
              for (var _j = 0; _j < 4; _j++) {
                colorArray[_idx + model.rowLength * 4 + _j] = colorArray[_idx + _j];
              }
            }
          }
        }
      } else {
        for (var _i2 = 0; _i2 < model.rowLength; ++_i2) {
          var grey = 255 * _i2 / (model.rowLength - 1);
          colorArray[_i2 * 4] = grey;
          colorArray[_i2 * 4 + 1] = grey;
          colorArray[_i2 * 4 + 2] = grey;
          colorArray[_i2 * 4 + 3] = 255;
          for (var _j2 = 0; _j2 < 4; _j2++) {
            colorArray[_i2 * 4 + model.rowLength * 4 + _j2] = colorArray[_i2 * 4 + _j2];
          }
        }
      }
      {
        var treq = {
          nativeArray: colorArray,
          width: model.rowLength,
          height: model.numRows * 2,
          depth: 1,
          format: "rgba8unorm"
        };
        var newTex = model.device.getTextureManager().getTexture(treq);
        var tview = newTex.createView("tfunTexture");
        model.textureViews[1] = tview;
      }
      model.colorTextureString = cfunToString;
    }
  };
  var superClassUpdateBuffers = publicAPI.updateBuffers;
  publicAPI.updateBuffers = function() {
    superClassUpdateBuffers();
    var newTex = model.device.getTextureManager().getTextureForImageData(model.currentInput);
    var tViews = model.textureViews;
    if (!tViews[0] || tViews[0].getTexture() !== newTex) {
      var tview = newTex.createView("imgTexture");
      tViews[0] = tview;
    }
    publicAPI.updateLUTImage();
    publicAPI.updateUBO();
    var actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    var iType = actorProperty.getInterpolationType() === InterpolationType2.NEAREST ? "nearest" : "linear";
    if (!model.clampSampler || iType !== model.clampSampler.getOptions().minFilter) {
      model.clampSampler = vtkWebGPUSampler$1.newInstance({
        label: "clampSampler"
      });
      model.clampSampler.create(model.device, {
        minFilter: iType,
        magFilter: iType
      });
      model.additionalBindables = [model.clampSampler];
    }
  };
  var sr = publicAPI.getShaderReplacements();
  publicAPI.replaceShaderPosition = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    var code = vDesc.getCode();
    var lines = ["var pos: vec4<f32> = mapperUBO.Origin +", "   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;", "pos.w = 1.0;"];
    if (model.dimensions === 2) {
      lines.push("var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;");
    } else {
      lines.push("var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;");
    }
    lines.push("output.tcoordVS = tcoord;", "output.Position = rendererUBO.SCPCMatrix * pos;");
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", lines).result;
    vDesc.setCode(code);
  };
  sr.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    if (model.dimensions === 2) {
      vDesc.addOutput("vec2<f32>", "tcoordVS");
    } else {
      vDesc.addOutput("vec3<f32>", "tcoordVS");
    }
  };
  sr.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.replaceShaderImage = function(hash, pipeline, vertexInput) {
    var fDesc = pipeline.getShaderDescription("fragment");
    var code = fDesc.getCode();
    if (model.dimensions === 3) {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", ["    var computedColor: vec4<f32> =", "      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);", "//VTK::Image::Sample"]).result;
    } else {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", ["    var computedColor: vec4<f32> =", "      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);", "//VTK::Image::Sample"]).result;
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", ["    var coord: vec2<f32> =", "      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);", "    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);"]).result;
    fDesc.setCode(code);
  };
  sr.set("replaceShaderImage", publicAPI.replaceShaderImage);
}
var DEFAULT_VALUES5 = {
  rowLength: 1024
};
function extend5(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  vtkWebGPUFullScreenQuad$1.extend(publicAPI, model, initialValues);
  publicAPI.setFragmentShaderTemplate(imgFragTemplate);
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "mapperUBO"
  });
  model.UBO.addEntry("SCTCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("Origin", "vec4<f32>");
  model.UBO.addEntry("Axis2", "vec4<f32>");
  model.UBO.addEntry("Axis1", "vec4<f32>");
  model.UBO.addEntry("cScale", "vec4<f32>");
  model.UBO.addEntry("cShift", "vec4<f32>");
  model.lutBuildTime = {};
  obj(model.lutBuildTime, {
    mtime: 0
  });
  model.imagemat = mat4_exports.identity(new Float64Array(16));
  model.imagematinv = mat4_exports.identity(new Float64Array(16));
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  vtkWebGPUImageMapper(publicAPI, model);
}
var newInstance6 = newInstance(extend5, "vtkWebGPUImageMapper");
registerOverride2("vtkImageMapper", newInstance6);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageSlice.js
function vtkWebGPUImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUImageSlice");
  publicAPI.buildPass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaquePass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(function(child) {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(function(child) {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = function(wgpuRen) {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = function(wgpuRen) {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      var mcwc = model.renderable.getMatrix();
      var center = wgpuRen.getStabilizedCenterByReference();
      model.bufferShift[0] = mcwc[3] - center[0];
      model.bufferShift[1] = mcwc[7] - center[1];
      model.bufferShift[2] = mcwc[11] - center[2];
      mat4_exports.transpose(model.keyMatrices.bcwc, mcwc);
      if (model.renderable.getIsIdentity()) {
        mat4_exports.identity(model.keyMatrices.normalMatrix);
      } else {
        mat4_exports.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
        model.keyMatrices.normalMatrix[3] = 0;
        model.keyMatrices.normalMatrix[7] = 0;
        model.keyMatrices.normalMatrix[11] = 0;
        mat4_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        mat4_exports.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      mat4_exports.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
      mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES6 = {
  bufferShift: void 0,
  keyMatrixTime: null,
  keyMatrices: null,
  propID: void 0
};
function extend6(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  model.bufferShift = [0, 0, 0, 0];
  get(publicAPI, model, ["propID", "keyMatricesTime"]);
  vtkWebGPUImageSlice(publicAPI, model);
}
var newInstance7 = newInstance(extend6, "vtkWebGPUImageSlice");
registerOverride2("vtkImageSlice", newInstance7);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Volume.js
function vtkWebGPUVolume(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVolume");
  publicAPI.buildPass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      model.renderable.getMapper().update();
    }
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      var bds = model.renderable.getMapper().getBounds();
      if (!bds || bds.length !== 6 || bds[0] > bds[1]) {
        return;
      }
      renderPass.addVolume(publicAPI);
    }
  };
  var idx = new Float64Array(3);
  var vout = new Float64Array(3);
  publicAPI.getBoundingCubePoints = function(result, offset) {
    var input = model.renderable.getMapper().getInputData();
    if (!input) {
      return;
    }
    var extent = input.getExtent();
    var m = model.renderable.getMatrix();
    var count = 0;
    for (var iz = 4; iz < 6; iz++) {
      idx[2] = extent[iz];
      for (var iy = 2; iy < 4; iy++) {
        idx[1] = extent[iy];
        for (var ix = 0; ix < 2; ix++) {
          idx[0] = extent[ix];
          input.indexToWorld(idx, vout);
          var poffset = offset + count * 3;
          result[poffset++] = m[0] * vout[0] + m[1] * vout[1] + m[2] * vout[2] + m[3];
          result[poffset++] = m[4] * vout[0] + m[5] * vout[1] + m[6] * vout[2] + m[7];
          result[poffset++] = m[8] * vout[0] + m[9] * vout[1] + m[10] * vout[2] + m[11];
          count++;
        }
      }
    }
  };
  publicAPI.getKeyMatrices = function(wgpuRen) {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      var mcwc = model.renderable.getMatrix();
      var center = wgpuRen.getStabilizedCenterByReference();
      mat4_exports.transpose(model.keyMatrices.bcwc, mcwc);
      mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES7 = {
  propID: void 0,
  keyMatricesTime: null
};
function extend7(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES7, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macro.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
  vtkWebGPUVolume(publicAPI, model);
}
var newInstance8 = macro.newInstance(extend7, "vtkWebGPUVolume");
registerOverride2("vtkVolume", newInstance8);
//# sourceMappingURL=@kitware_vtk__js_Rendering_Profiles_Volume.js.map
