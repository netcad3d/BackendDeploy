{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Rendering/Core/ImageMapper/Constants.js", "../../@kitware/vtk.js/Rendering/Core/ImageProperty/Constants.js", "../../@kitware/vtk.js/Rendering/OpenGL/ImageMapper.js", "../../@kitware/vtk.js/Rendering/OpenGL/ImageSlice.js", "../../@kitware/vtk.js/Rendering/OpenGL/Volume.js", "../../@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeVS.glsl.js", "../../@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeFS.glsl.js", "../../@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js", "../../@kitware/vtk.js/Rendering/WebGPU/ImageMapper.js", "../../@kitware/vtk.js/Rendering/WebGPU/ImageSlice.js", "../../@kitware/vtk.js/Rendering/WebGPU/Volume.js"],
  "sourcesContent": ["var SlicingMode = {\n  NONE: -1,\n  I: 0,\n  J: 1,\n  K: 2,\n  X: 3,\n  Y: 4,\n  Z: 5\n};\nvar Constants = {\n  SlicingMode: SlicingMode\n};\n\nexport { SlicingMode, Constants as default };\n", "var InterpolationType = {\n  NEAREST: 0,\n  LINEAR: 1\n};\nvar Constants = {\n  InterpolationType: InterpolationType\n};\n\nexport { InterpolationType, Constants as default };\n", "import { mat4 } from 'gl-matrix';\nimport Constants from '../Core/ImageMapper/Constants.js';\nimport { newInstance as newInstance$1, setGet, obj, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkHelper from './Helper.js';\nimport { u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { Filter, Wrap } from './Texture/Constants.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nvar vtkErrorMacro = vtkErrorMacro$1;\nvar SlicingMode = Constants.SlicingMode; // ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  var pwfun = fn.apply(property);\n\n  if (pwfun) {\n    var iComps = property.getIndependentComponents();\n    return \"\".concat(property.getMTime(), \"-\").concat(iComps, \"-\").concat(numberOfComponents);\n  }\n\n  return '0';\n} // ----------------------------------------------------------------------------\n// vtkOpenGLImageMapper methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkOpenGLImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageMapper');\n\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLImageSlice = publicAPI.getFirstAncestorOfType('vtkOpenGLImageSlice');\n      model.openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model.openGLRenderer.getParent();\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      var ren = model.openGLRenderer.getRenderable();\n      model.openGLCamera = model.openGLRenderer.getViewNodeFor(ren.getActiveCamera()); // is slice set by the camera\n\n      if (model.renderable.getSliceAtFocalPoint()) {\n        model.renderable.setSliceFromCamera(ren.getActiveCamera());\n      }\n    }\n  };\n\n  publicAPI.translucentPass = function (prepass, renderPass) {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.opaqueZBufferPass = function (prepass) {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n\n  publicAPI.opaquePass = function (prepass) {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.getCoincidentParameters = function (ren, actor) {\n    if (model.renderable.getResolveCoincidentTopology()) {\n      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n    }\n\n    return null;\n  }; // Renders myself\n\n\n  publicAPI.render = function () {\n    var actor = model.openGLImageSlice.getRenderable();\n    var ren = model.openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n\n  publicAPI.buildShaders = function (shaders, ren, actor) {\n    publicAPI.getShaderTemplate(shaders, ren, actor); // apply any renderPassReplacements\n\n    if (model.lastRenderPassShaderReplacement) {\n      model.lastRenderPassShaderReplacement(shaders);\n    }\n\n    publicAPI.replaceShaderValues(shaders, ren, actor);\n  };\n\n  publicAPI.getShaderTemplate = function (shaders, ren, actor) {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n\n  publicAPI.replaceShaderValues = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var FSSource = shaders.Fragment;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;\n    var tNumComp = model.openGLTexture.getComponents();\n    var iComps = actor.getProperty().getIndependentComponents();\n    var tcoordDec = ['varying vec2 tcoordVCVSOutput;', // color shift and scale\n    'uniform float cshift0;', 'uniform float cscale0;', // pwf shift and scale\n    'uniform float pwfshift0;', 'uniform float pwfscale0;', 'uniform sampler2D texture1;', 'uniform sampler2D colorTexture1;', 'uniform sampler2D pwfTexture1;', 'uniform float opacity;'];\n\n    if (iComps) {\n      for (var comp = 1; comp < tNumComp; comp++) {\n        tcoordDec = tcoordDec.concat([// color shift and scale\n        \"uniform float cshift\".concat(comp, \";\"), \"uniform float cscale\".concat(comp, \";\"), // weighting shift and scale\n        \"uniform float pwfshift\".concat(comp, \";\"), \"uniform float pwfscale\".concat(comp, \";\")]);\n      } // the heights defined below are the locations\n      // for the up to four components of the tfuns\n      // the tfuns have a height of 2XnumComps pixels so the\n      // values are computed to hit the middle of the two rows\n      // for that component\n\n\n      switch (tNumComp) {\n        case 1:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', '#define height0 0.5']);\n          break;\n\n        case 2:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', '#define height0 0.25', '#define height1 0.75']);\n          break;\n\n        case 3:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', '#define height0 0.17', '#define height1 0.5', '#define height2 0.83']);\n          break;\n\n        case 4:\n          tcoordDec = tcoordDec.concat(['uniform float mix0;', 'uniform float mix1;', 'uniform float mix2;', 'uniform float mix3;', '#define height0 0.125', '#define height1 0.375', '#define height2 0.625', '#define height3 0.875']);\n          break;\n\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n    }\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', tcoordDec).result;\n\n    if (iComps) {\n      var rgba = ['r', 'g', 'b', 'a'];\n      var tcoordImpl = ['vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);'];\n\n      for (var _comp = 0; _comp < tNumComp; _comp++) {\n        tcoordImpl = tcoordImpl.concat([\"vec3 tcolor\".concat(_comp, \" = mix\").concat(_comp, \" * texture2D(colorTexture1, vec2(tvalue.\").concat(rgba[_comp], \" * cscale\").concat(_comp, \" + cshift\").concat(_comp, \", height\").concat(_comp, \")).rgb;\"), \"float compWeight\".concat(_comp, \" = mix\").concat(_comp, \" * texture2D(pwfTexture1, vec2(tvalue.\").concat(rgba[_comp], \" * pwfscale\").concat(_comp, \" + pwfshift\").concat(_comp, \", height\").concat(_comp, \")).r;\")]);\n      }\n\n      switch (tNumComp) {\n        case 1:\n          tcoordImpl = tcoordImpl.concat(['gl_FragData[0] = vec4(tcolor0.rgb, opacity);']);\n          break;\n\n        case 2:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);']);\n          break;\n\n        case 3:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);']);\n          break;\n\n        case 4:\n          tcoordImpl = tcoordImpl.concat(['float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;', 'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);']);\n          break;\n\n        default:\n          vtkErrorMacro('Unsupported number of independent coordinates.');\n      }\n\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', tcoordImpl).result;\n    } else {\n      // dependent components\n      switch (tNumComp) {\n        case 1:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['float intensity = texture2D(texture1, tcoordVCVSOutput).r;', 'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;', 'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;', 'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);']).result;\n          break;\n\n        case 2:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', 'float intensity = tcolor.r*cscale0 + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);']).result;\n          break;\n\n        case 3:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);']).result;\n          break;\n\n        default:\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;', 'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,', '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);']).result;\n      }\n    }\n\n    if (model.haveSeenDepthRequest) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n    }\n\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n  };\n\n  publicAPI.replaceShaderClip = function (shaders, ren, actor) {\n    var VSSource = shaders.Vertex;\n    var FSSource = shaders.Fragment;\n\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n\n      if (numClipPlanes > 6) {\n        vtkErrorMacro$1('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'uniform vec4 clipPlanes[6];', 'varying float clipDistancesVSOutput[6];']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', 'varying float clipDistancesVSOutput[6];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', ['for (int planeNum = 0; planeNum < 6; planeNum++)', '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.getNeedToRebuildShaders = function (cellBO, ren, actor) {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    var tNumComp = model.openGLTexture.getComponents();\n    var iComp = actor.getProperty().getIndependentComponents(); // has the render pass shader replacement changed? Two options\n\n    var needRebuild = false;\n\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n      model.lastRenderPassShaderReplacement = null;\n    }\n\n    if (model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      model.lastRenderPassShaderReplacement = model.currentRenderPass.getShaderReplacement();\n      needRebuild = true;\n    }\n\n    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      model.lastTextureComponents = tNumComp;\n      model.lastIndependentComponents = iComp;\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.updateShaders = function (cellBO, ren, actor) {\n    model.lastBoundBO = cellBO; // has something changed that would require us to recreate the shader?\n\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      var shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor); // compile and bind the program if needed\n\n      var newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry); // if the shader changed reinitialize the VAO\n\n\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader); // reset the VAO as the shader has changed\n\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n  };\n\n  publicAPI.setMapperShaderParameters = function (cellBO, ren, actor) {\n    // Now to update the VAO too, if necessary.\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      }\n\n      cellBO.getAttributeUpdateTime().modified();\n    }\n\n    var texUnit = model.openGLTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('texture1', texUnit);\n    var numComp = model.openGLTexture.getComponents();\n    var iComps = actor.getProperty().getIndependentComponents();\n\n    if (iComps) {\n      for (var i = 0; i < numComp; i++) {\n        cellBO.getProgram().setUniformf(\"mix\".concat(i), actor.getProperty().getComponentWeight(i));\n      }\n    }\n\n    var oglShiftScale = model.openGLTexture.getShiftAndScale(); // three levels of shift scale combined into one\n    // for performance in the fragment shader\n\n    for (var _i = 0; _i < numComp; _i++) {\n      var cw = actor.getProperty().getColorWindow();\n      var cl = actor.getProperty().getColorLevel();\n      var target = iComps ? _i : 0;\n      var cfun = actor.getProperty().getRGBTransferFunction(target);\n\n      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {\n        var cRange = cfun.getRange();\n        cw = cRange[1] - cRange[0];\n        cl = 0.5 * (cRange[1] + cRange[0]);\n      }\n\n      var scale = oglShiftScale.scale / cw;\n      var shift = (oglShiftScale.shift - cl) / cw + 0.5;\n      cellBO.getProgram().setUniformf(\"cshift\".concat(_i), shift);\n      cellBO.getProgram().setUniformf(\"cscale\".concat(_i), scale);\n    } // pwf shift/scale\n\n\n    for (var _i2 = 0; _i2 < numComp; _i2++) {\n      var pwfScale = 1.0;\n      var pwfShift = 0.0;\n\n      var _target = iComps ? _i2 : 0;\n\n      var pwfun = actor.getProperty().getPiecewiseFunction(_target);\n\n      if (pwfun) {\n        var pwfRange = pwfun.getRange();\n        var length = pwfRange[1] - pwfRange[0];\n        var mid = 0.5 * (pwfRange[0] + pwfRange[1]);\n        pwfScale = oglShiftScale.scale / length;\n        pwfShift = (oglShiftScale.shift - mid) / length + 0.5;\n      }\n\n      cellBO.getProgram().setUniformf(\"pwfshift\".concat(_i2), pwfShift);\n      cellBO.getProgram().setUniformf(\"pwfscale\".concat(_i2), pwfScale);\n    }\n\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    } // handle coincident\n\n\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      var cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset); // cfactor isn't always used when coffset is.\n\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n\n    var texColorUnit = model.colorTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('colorTexture1', texColorUnit);\n    var texOpacityUnit = model.pwfTexture.getTextureUnit();\n    cellBO.getProgram().setUniformi('pwfTexture1', texOpacityUnit);\n\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n\n      if (numClipPlanes > 6) {\n        vtkErrorMacro$1('OpenGL has a limit of 6 clipping planes');\n        numClipPlanes = 6;\n      }\n\n      var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      var mat = inverseShiftScaleMatrix ? mat4.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();\n\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      } // transform crop plane normal with transpose(inverse(worldToIndex))\n\n\n      mat4.transpose(model.imagemat, model.currentInput.getIndexToWorld());\n      mat4.multiply(model.imagematinv, mat, model.imagemat);\n      var planeEquations = [];\n\n      for (var _i3 = 0; _i3 < numClipPlanes; _i3++) {\n        var planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, _i3, planeEquation);\n\n        for (var j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n  };\n\n  publicAPI.setCameraShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var actMats = model.openGLImageSlice.getKeyMatrices();\n    var image = model.currentInput;\n    var i2wmat4 = image.getIndexToWorld();\n    mat4.multiply(model.imagemat, actMats.mcwc, i2wmat4);\n    var keyMats = model.openGLCamera.getKeyMatrices(ren);\n    mat4.multiply(model.imagemat, keyMats.wcpc, model.imagemat);\n\n    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {\n      var inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();\n      mat4.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);\n    }\n\n    program.setUniformMatrix('MCPCMatrix', model.imagemat);\n  };\n\n  publicAPI.setPropertyShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    var ppty = actor.getProperty();\n    var opacity = ppty.getOpacity();\n    program.setUniformf('opacity', opacity);\n  };\n\n  publicAPI.renderPieceStart = function (ren, actor) {\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor); // Bind the OpenGL, this is shared between the different primitive/cell types.\n\n    model.lastBoundBO = null;\n  };\n\n  publicAPI.renderPieceDraw = function (ren, actor) {\n    var gl = model.context; // activate the texture\n\n    model.openGLTexture.activate();\n    model.colorTexture.activate();\n    model.pwfTexture.activate(); // draw polygons\n\n    if (model.tris.getCABO().getElementCount()) {\n      // First we do the triangles, update the shader, set uniforms, etc.\n      publicAPI.updateShaders(model.tris, ren, actor);\n      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      model.tris.getVAO().release();\n    }\n\n    model.openGLTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.pwfTexture.deactivate();\n  };\n\n  publicAPI.renderPieceFinish = function (ren, actor) {};\n\n  publicAPI.renderPiece = function (ren, actor) {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n\n  publicAPI.computeBounds = function (ren, actor) {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.bounds);\n      return;\n    }\n\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n\n  publicAPI.updateBufferObjects = function (ren, actor) {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n\n  publicAPI.getNeedToRebuildBufferObjects = function (ren, actor) {\n    // first do a coarse check\n    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.buildBufferObjects = function (ren, actor) {\n    var image = model.currentInput;\n\n    if (!image) {\n      return;\n    }\n\n    var imgScalars = image.getPointData() && image.getPointData().getScalars();\n\n    if (!imgScalars) {\n      return;\n    }\n\n    var actorProperty = actor.getProperty(); // set interpolation on the texture based on property setting\n\n    var iType = actorProperty.getInterpolationType();\n\n    if (iType === InterpolationType.NEAREST) {\n      model.colorTexture.setMinificationFilter(Filter.NEAREST);\n      model.colorTexture.setMagnificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMinificationFilter(Filter.NEAREST);\n      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMinificationFilter(Filter.LINEAR);\n      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);\n    }\n\n    var numComp = imgScalars.getNumberOfComponents();\n    var iComps = actorProperty.getIndependentComponents();\n    var numIComps = iComps ? numComp : 1;\n    var textureHeight = iComps ? 2 * numIComps : 1;\n    var cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);\n\n    if (model.colorTextureString !== cfunToString) {\n      var cWidth = 1024;\n      var cSize = cWidth * textureHeight * 3;\n      var cTable = new Uint8Array(cSize);\n      var cfun = actorProperty.getRGBTransferFunction();\n\n      if (cfun) {\n        var tmpTable = new Float32Array(cWidth * 3);\n\n        for (var c = 0; c < numIComps; c++) {\n          cfun = actorProperty.getRGBTransferFunction(c);\n          var cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);\n\n          if (iComps) {\n            for (var i = 0; i < cWidth * 3; i++) {\n              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];\n              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];\n            }\n          } else {\n            for (var _i4 = 0; _i4 < cWidth * 3; _i4++) {\n              cTable[c * cWidth * 6 + _i4] = 255.0 * tmpTable[_i4];\n            }\n          }\n        }\n\n        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      } else {\n        for (var _i5 = 0; _i5 < cWidth * 3; ++_i5) {\n          cTable[_i5] = 255.0 * _i5 / ((cWidth - 1) * 3);\n          cTable[_i5 + 1] = 255.0 * _i5 / ((cWidth - 1) * 3);\n          cTable[_i5 + 2] = 255.0 * _i5 / ((cWidth - 1) * 3);\n        }\n\n        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      }\n\n      model.colorTextureString = cfunToString;\n    } // Build piecewise function buffer.  This buffer is used either\n    // for component weighting or opacity, depending on whether we're\n    // rendering components independently or not.\n\n\n    var pwfunToString = computeFnToString(actorProperty, actorProperty.getPiecewiseFunction, numIComps);\n\n    if (model.pwfTextureString !== pwfunToString) {\n      var pwfWidth = 1024;\n      var pwfSize = pwfWidth * textureHeight;\n      var pwfTable = new Uint8Array(pwfSize);\n      var pwfun = actorProperty.getPiecewiseFunction(); // support case where pwfun is added/removed\n\n      model.pwfTexture.resetFormatAndType();\n\n      if (pwfun) {\n        var pwfFloatTable = new Float32Array(pwfSize);\n\n        var _tmpTable = new Float32Array(pwfWidth);\n\n        for (var _c = 0; _c < numIComps; ++_c) {\n          pwfun = actorProperty.getPiecewiseFunction(_c);\n\n          if (pwfun === null) {\n            // Piecewise constant max if no function supplied for this component\n            pwfFloatTable.fill(1.0);\n          } else {\n            var pwfRange = pwfun.getRange();\n            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, _tmpTable, 1); // adjust for sample distance etc\n\n            if (iComps) {\n              for (var _i6 = 0; _i6 < pwfWidth; _i6++) {\n                pwfFloatTable[_c * pwfWidth * 2 + _i6] = _tmpTable[_i6];\n                pwfFloatTable[_c * pwfWidth * 2 + _i6 + pwfWidth] = _tmpTable[_i6];\n              }\n            } else {\n              for (var _i7 = 0; _i7 < pwfWidth; _i7++) {\n                pwfFloatTable[_c * pwfWidth * 2 + _i7] = _tmpTable[_i7];\n              }\n            }\n          }\n        }\n\n        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);\n      } else {\n        // default is opaque\n        pwfTable.fill(255.0);\n        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);\n      }\n\n      model.pwfTextureString = pwfunToString;\n    } // Find what IJK axis and what direction to slice along\n\n\n    var _model$renderable$get = model.renderable.getClosestIJKAxis(),\n        ijkMode = _model$renderable$get.ijkMode; // Find the IJK slice\n\n\n    var slice = model.renderable.getSlice();\n\n    if (ijkMode !== model.renderable.getSlicingMode()) {\n      // If not IJK slicing, get the IJK slice from the XYZ position/slice\n      slice = model.renderable.getSliceAtPosition(slice);\n    }\n\n    var nSlice = Math.round(slice); // Find sliceOffset\n\n    var ext = image.getExtent();\n    var sliceOffset;\n\n    if (ijkMode === SlicingMode.I) {\n      sliceOffset = nSlice - ext[0];\n    }\n\n    if (ijkMode === SlicingMode.J) {\n      sliceOffset = nSlice - ext[2];\n    }\n\n    if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n      sliceOffset = nSlice - ext[4];\n    } // rebuild the VBO if the data has changed\n\n\n    var toString = \"\".concat(slice, \"A\").concat(image.getMTime(), \"A\").concat(imgScalars.getMTime(), \"B\").concat(publicAPI.getMTime(), \"C\").concat(model.renderable.getSlicingMode(), \"D\").concat(actor.getProperty().getMTime());\n\n    if (model.VBOBuildString !== toString) {\n      // Build the VBOs\n      var dims = image.getDimensions();\n\n      if (iType === InterpolationType.NEAREST) {\n        if (numComp === 4) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.NEAREST);\n        }\n\n        model.openGLTexture.setMagnificationFilter(Filter.NEAREST);\n      } else {\n        if (numComp === 4) {\n          model.openGLTexture.setGenerateMipmap(true);\n          model.openGLTexture.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        } else {\n          model.openGLTexture.setMinificationFilter(Filter.LINEAR);\n        }\n\n        model.openGLTexture.setMagnificationFilter(Filter.LINEAR);\n      }\n\n      model.openGLTexture.setWrapS(Wrap.CLAMP_TO_EDGE);\n      model.openGLTexture.setWrapT(Wrap.CLAMP_TO_EDGE);\n      var sliceSize = dims[0] * dims[1] * numComp;\n      var ptsArray = new Float32Array(12);\n      var tcoordArray = new Float32Array(8);\n\n      for (var _i8 = 0; _i8 < 4; _i8++) {\n        tcoordArray[_i8 * 2] = _i8 % 2 ? 1.0 : 0.0;\n        tcoordArray[_i8 * 2 + 1] = _i8 > 1 ? 1.0 : 0.0;\n      } // Determine depth position of the slicing plane in the scene.\n      // Slicing modes X, Y, and Z use a continuous axis position, whereas\n      // slicing modes I, J, and K should use discrete positions.\n\n\n      var sliceDepth = [SlicingMode.X, SlicingMode.Y, SlicingMode.Z].includes(model.renderable.getSlicingMode()) ? slice : nSlice;\n      var spatialExt = image.getSpatialExtent();\n      var basicScalars = imgScalars.getData();\n      var scalars = null; // Get right scalars according to slicing mode\n\n      if (ijkMode === SlicingMode.I) {\n        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);\n        var id = 0;\n\n        for (var k = 0; k < dims[2]; k++) {\n          for (var j = 0; j < dims[1]; j++) {\n            var bsIdx = (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;\n            id = (k * dims[1] + j) * numComp;\n            scalars.set(basicScalars.subarray(bsIdx, bsIdx + numComp), id);\n          }\n        }\n\n        dims[0] = dims[1];\n        dims[1] = dims[2];\n        ptsArray[0] = sliceDepth;\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = sliceDepth;\n        ptsArray[4] = spatialExt[3];\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = sliceDepth;\n        ptsArray[7] = spatialExt[2];\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = sliceDepth;\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.J) {\n        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);\n        var _id = 0;\n\n        for (var _k = 0; _k < dims[2]; _k++) {\n          for (var _i9 = 0; _i9 < dims[0]; _i9++) {\n            var _bsIdx = (_i9 + sliceOffset * dims[0] + _k * dims[0] * dims[1]) * numComp;\n\n            _id = (_k * dims[0] + _i9) * numComp;\n            scalars.set(basicScalars.subarray(_bsIdx, _bsIdx + numComp), _id);\n          }\n        }\n\n        dims[1] = dims[2];\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = sliceDepth;\n        ptsArray[2] = spatialExt[4];\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = sliceDepth;\n        ptsArray[5] = spatialExt[4];\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = sliceDepth;\n        ptsArray[8] = spatialExt[5];\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = sliceDepth;\n        ptsArray[11] = spatialExt[5];\n      } else if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {\n        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);\n        ptsArray[0] = spatialExt[0];\n        ptsArray[1] = spatialExt[2];\n        ptsArray[2] = sliceDepth;\n        ptsArray[3] = spatialExt[1];\n        ptsArray[4] = spatialExt[2];\n        ptsArray[5] = sliceDepth;\n        ptsArray[6] = spatialExt[0];\n        ptsArray[7] = spatialExt[3];\n        ptsArray[8] = sliceDepth;\n        ptsArray[9] = spatialExt[1];\n        ptsArray[10] = spatialExt[3];\n        ptsArray[11] = sliceDepth;\n      } else {\n        vtkErrorMacro('Reformat slicing not yet supported.');\n      }\n\n      model.openGLTexture.create2DFromRaw(dims[0], dims[1], numComp, imgScalars.getDataType(), scalars);\n      model.openGLTexture.activate();\n      model.openGLTexture.sendParameters();\n      model.openGLTexture.deactivate();\n      var points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      var tcoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: tcoordArray\n      });\n      tcoords.setName('tcoords');\n      var cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2;\n      var cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points: points,\n        tcoords: tcoords,\n        cellOffset: 0\n      });\n      model.VBOBuildTime.modified();\n      model.VBOBuildString = toString;\n    }\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  openGLTexture: null,\n  tris: null,\n  imagemat: null,\n  imagematinv: null,\n  colorTexture: null,\n  pwfTexture: null,\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastTextureComponents: 0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  model.tris = vtkHelper.newInstance();\n  model.openGLTexture = vtkOpenGLTexture.newInstance();\n  model.colorTexture = vtkOpenGLTexture.newInstance();\n  model.pwfTexture = vtkOpenGLTexture.newInstance();\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16)); // Build VTK API\n\n  setGet(publicAPI, model, []);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime); // Object methods\n\n  vtkOpenGLImageMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLImageMapper'); // ----------------------------------------------------------------------------\n\nvar vtkImageMapper = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkImageMapper', newInstance);\n\nexport { vtkImageMapper as default, extend, newInstance };\n", "import { mat4 } from 'gl-matrix';\nimport { newInstance as newInstance$1, obj, setGet } from '../../macros.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// vtkOpenGLImageSlice methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLImageSlice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLImageSlice'); // Builds myself.\n\n  publicAPI.buildPass = function (prepass) {\n    if (!model.renderable || !model.renderable.getVisibility()) {\n      return;\n    }\n\n    if (prepass) {\n      if (!model.renderable) {\n        return;\n      }\n\n      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderWindow');\n      model.openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model.context = model._openGLRenderWindow.getContext();\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNode(model.renderable.getMapper());\n      publicAPI.removeUnusedNodes();\n    }\n  };\n\n  publicAPI.traverseOpaqueZBufferPass = function (renderPass) {\n    publicAPI.traverseOpaquePass(renderPass);\n  }; // we draw textures, then mapper, then post pass textures\n\n\n  publicAPI.traverseOpaquePass = function (renderPass) {\n    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n\n    publicAPI.apply(renderPass, true);\n    model.children.forEach(function (child) {\n      child.traverse(renderPass);\n    });\n    publicAPI.apply(renderPass, false);\n  }; // we draw textures, then mapper, then post pass textures\n\n\n  publicAPI.traverseTranslucentPass = function (renderPass) {\n    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n\n    publicAPI.apply(renderPass, true);\n    model.children.forEach(function (child) {\n      child.traverse(renderPass);\n    });\n    publicAPI.apply(renderPass, false);\n  };\n\n  publicAPI.queryPass = function (prepass, renderPass) {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n\n      if (model.renderable.getIsOpaque()) {\n        renderPass.incrementOpaqueActorCount();\n      } else {\n        renderPass.incrementTranslucentActorCount();\n      }\n    }\n  };\n\n  publicAPI.opaqueZBufferPass = function (prepass, renderPass) {\n    return publicAPI.opaquePass(prepass, renderPass);\n  }; // Renders myself\n\n\n  publicAPI.opaquePass = function (prepass, renderPass) {\n    if (prepass) {\n      model.context.depthMask(true);\n    }\n  }; // Renders myself\n\n\n  publicAPI.translucentPass = function (prepass, renderPass) {\n    model.context.depthMask(!prepass);\n  };\n\n  publicAPI.getKeyMatrices = function () {\n    // has the actor changed?\n    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {\n      mat4.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());\n      mat4.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);\n      model.keyMatrixTime.modified();\n    }\n\n    return model.keyMatrices;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  context: null,\n  keyMatrixTime: null,\n  keyMatrices: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.keyMatrixTime = {};\n  obj(model.keyMatrixTime, {\n    mtime: 0\n  });\n  model.keyMatrices = {\n    mcwc: mat4.identity(new Float64Array(16))\n  }; // Build VTK API\n\n  setGet(publicAPI, model, ['context']); // Object methods\n\n  vtkOpenGLImageSlice(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLImageSlice'); // ----------------------------------------------------------------------------\n\nvar vtkImageSlice = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkImageSlice', newInstance);\n\nexport { vtkImageSlice as default, extend, newInstance };\n", "import { mat4, mat3 } from 'gl-matrix';\nimport { newInstance as newInstance$1, obj, setGet } from '../../macros.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// vtkOpenGLVolume methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLVolume(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVolume'); // Builds myself.\n\n  publicAPI.buildPass = function (prepass) {\n    if (!model.renderable || !model.renderable.getVisibility()) {\n      return;\n    }\n\n    if (prepass) {\n      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderWindow');\n      model.openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model.context = model._openGLRenderWindow.getContext();\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNode(model.renderable.getMapper());\n      publicAPI.removeUnusedNodes();\n    }\n  };\n\n  publicAPI.queryPass = function (prepass, renderPass) {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n\n      renderPass.incrementVolumeCount();\n    }\n  };\n\n  publicAPI.traverseVolumePass = function (renderPass) {\n    if (!model.renderable || !model.renderable.getNestedVisibility() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n\n    publicAPI.apply(renderPass, true);\n    model.children[0].traverse(renderPass);\n    publicAPI.apply(renderPass, false);\n  }; // Renders myself\n\n\n  publicAPI.volumePass = function (prepass) {\n    if (!model.renderable || !model.renderable.getVisibility()) {\n      return;\n    }\n\n    model.context.depthMask(!prepass);\n  };\n\n  publicAPI.getKeyMatrices = function () {\n    // has the actor changed?\n    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {\n      model.renderable.computeMatrix();\n      mat4.copy(model.MCWCMatrix, model.renderable.getMatrix());\n      mat4.transpose(model.MCWCMatrix, model.MCWCMatrix);\n\n      if (model.renderable.getIsIdentity()) {\n        mat3.identity(model.normalMatrix);\n      } else {\n        mat3.fromMat4(model.normalMatrix, model.MCWCMatrix);\n        mat3.invert(model.normalMatrix, model.normalMatrix);\n      }\n\n      model.keyMatrixTime.modified();\n    }\n\n    return {\n      mcwc: model.MCWCMatrix,\n      normalMatrix: model.normalMatrix\n    };\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {// context: null,\n  // keyMatrixTime: null,\n  // normalMatrix: null,\n  // MCWCMatrix: null,\n  // _openGLRenderWindow: null,\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.keyMatrixTime = {};\n  obj(model.keyMatrixTime, {\n    mtime: 0\n  }); // always set by getter\n\n  model.normalMatrix = new Float64Array(9);\n  model.MCWCMatrix = new Float64Array(16); // Build VTK API\n\n  setGet(publicAPI, model, ['context']); // Object methods\n\n  vtkOpenGLVolume(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLVolume'); // ----------------------------------------------------------------------------\n\nvar vtkVolume = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkVolume', newInstance);\n\nexport { vtkVolume as default, extend, newInstance };\n", "var vtkVolumeVS = \"//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\n\\nvarying vec3 vertexVCVSOutput;\\nuniform mat4 PCVCMatrix;\\n\\nuniform float dcxmin;\\nuniform float dcxmax;\\nuniform float dcymin;\\nuniform float dcymax;\\n\\nvoid main()\\n{\\n  // dcsmall is the device coords reduced to the\\n  // x y area covered by the volume\\n  vec4 dcsmall = vec4(\\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\\n    vertexDC.z,\\n    vertexDC.w);\\n  vec4 vcpos = PCVCMatrix * dcsmall;\\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\\n  gl_Position = dcsmall;\\n}\\n\";\n\nexport { vtkVolumeVS as v };\n", "var vtkVolumeFS = \"//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkVolumeFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the volume mappers fragment shader\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvarying vec3 vertexVCVSOutput;\\n\\n// first declare the settings from the mapper\\n// that impact the code paths in here\\n\\n// always set vtkNumComponents 1,2,3,4\\n//VTK::NumComponents\\n\\n// possibly define vtkTrilinearOn\\n//VTK::TrilinearOn\\n\\n// possibly define vtkIndependentComponents\\n//VTK::IndependentComponentsOn\\n\\n// possibly define any \\\"proportional\\\" components\\n//VTK::vtkProportionalComponents\\n\\n// Define the blend mode to use\\n#define vtkBlendMode //VTK::BlendMode\\n\\n// Possibly define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n#ifdef vtkImageLabelOutlineOn\\nuniform int outlineThickness;\\nuniform float vpWidth;\\nuniform float vpHeight;\\nuniform float vpOffsetX;\\nuniform float vpOffsetY;\\nuniform mat4 PCWCMatrix;\\nuniform mat4 vWCtoIDX;\\n#endif\\n\\n// define vtkLightComplexity\\n//VTK::LightComplexity\\n#if vtkLightComplexity > 0\\nuniform float vSpecularPower;\\nuniform float vAmbient;\\nuniform float vDiffuse;\\nuniform float vSpecular;\\n//VTK::Light::Dec\\n#endif\\n\\n//VTK::VolumeShadowOn\\n//VTK::SurfaceShadowOn\\n//VTK::localAmbientOcclusionOn\\n//VTK::LAO::Dec\\n//VTK::VolumeShadow::Dec\\n\\n// define vtkComputeNormalFromOpacity\\n//VTK::vtkComputeNormalFromOpacity\\n\\n// possibly define vtkGradientOpacityOn\\n//VTK::GradientOpacityOn\\n#ifdef vtkGradientOpacityOn\\nuniform float goscale0;\\nuniform float goshift0;\\nuniform float gomin0;\\nuniform float gomax0;\\n#if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\nuniform float goscale1;\\nuniform float goshift1;\\nuniform float gomin1;\\nuniform float gomax1;\\n#if vtkNumComponents >= 3\\nuniform float goscale2;\\nuniform float goshift2;\\nuniform float gomin2;\\nuniform float gomax2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float goscale3;\\nuniform float goshift3;\\nuniform float gomin3;\\nuniform float gomax3;\\n#endif\\n#endif\\n#endif\\n\\n// if you want to see the raw tiled\\n// data in webgl1 uncomment the following line\\n// #define debugtile\\n\\n// camera values\\nuniform float camThick;\\nuniform float camNear;\\nuniform float camFar;\\nuniform int cameraParallel;\\n\\n// values describing the volume geometry\\nuniform vec3 vOriginVC;\\nuniform vec3 vSpacing;\\nuniform ivec3 volumeDimensions; // 3d texture dimensions\\nuniform vec3 vPlaneNormal0;\\nuniform float vPlaneDistance0;\\nuniform vec3 vPlaneNormal1;\\nuniform float vPlaneDistance1;\\nuniform vec3 vPlaneNormal2;\\nuniform float vPlaneDistance2;\\nuniform vec3 vPlaneNormal3;\\nuniform float vPlaneDistance3;\\nuniform vec3 vPlaneNormal4;\\nuniform float vPlaneDistance4;\\nuniform vec3 vPlaneNormal5;\\nuniform float vPlaneDistance5;\\n\\n//VTK::ClipPlane::Dec\\n\\n// opacity and color textures\\nuniform sampler2D otexture;\\nuniform float oshift0;\\nuniform float oscale0;\\nuniform sampler2D ctexture;\\nuniform float cshift0;\\nuniform float cscale0;\\n\\n// jitter texture\\nuniform sampler2D jtexture;\\n\\n// some 3D texture values\\nuniform float sampleDistance;\\nuniform vec3 vVCToIJK;\\n\\n// the heights defined below are the locations\\n// for the up to four components of the tfuns\\n// the tfuns have a height of 2XnumComps pixels so the\\n// values are computed to hit the middle of the two rows\\n// for that component\\n#ifdef vtkIndependentComponentsOn\\n#if vtkNumComponents == 2\\nuniform float mix0;\\nuniform float mix1;\\n#define height0 0.25\\n#define height1 0.75\\n#endif\\n#if vtkNumComponents == 3\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\n#define height0 0.17\\n#define height1 0.5\\n#define height2 0.83\\n#endif\\n#if vtkNumComponents == 4\\nuniform float mix0;\\nuniform float mix1;\\nuniform float mix2;\\nuniform float mix3;\\n#define height0 0.125\\n#define height1 0.375\\n#define height2 0.625\\n#define height3 0.875\\n#endif\\n#endif\\n\\n#if vtkNumComponents >= 2\\nuniform float oshift1;\\nuniform float oscale1;\\nuniform float cshift1;\\nuniform float cscale1;\\n#endif\\n#if vtkNumComponents >= 3\\nuniform float oshift2;\\nuniform float oscale2;\\nuniform float cshift2;\\nuniform float cscale2;\\n#endif\\n#if vtkNumComponents >= 4\\nuniform float oshift3;\\nuniform float oscale3;\\nuniform float cshift3;\\nuniform float cscale3;\\n#endif\\n\\nuniform vec4 ipScalarRangeMin;\\nuniform vec4 ipScalarRangeMax;\\n\\n// declaration for intermixed geometry\\n//VTK::ZBuffer::Dec\\n\\n//=======================================================================\\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\\nvec3 rayDirVC;\\nfloat sampleDistanceISVS;\\nfloat sampleDistanceIS;\\n\\n#define SQRT3    1.7321\\n#define INV4PI   0.0796\\n#define EPSILON  0.001\\n#define PI       3.1415\\n#define PI2      9.8696\\n\\n//=======================================================================\\n// Webgl2 specific version of functions\\n#if __VERSION__ == 300\\n\\nuniform highp sampler3D texture1;\\n\\nvec4 getTextureValue(vec3 pos)\\n{\\n  vec4 tmp = texture(texture1, pos);\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.a = tmp.g;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n  return tmp;\\n}\\n\\n//=======================================================================\\n// WebGL1 specific version of functions\\n#else\\n\\nuniform sampler2D texture1;\\n\\nuniform float texWidth;\\nuniform float texHeight;\\nuniform int xreps;\\nuniform int xstride;\\nuniform int ystride;\\n\\n// if computing trilinear values from multiple z slices\\n#ifdef vtkTrilinearOn\\nvec4 getTextureValue(vec3 ijk)\\n{\\n  float zoff = 1.0/float(volumeDimensions.z);\\n  vec4 val1 = getOneTextureValue(ijk);\\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\\n\\n  float indexZ = float(volumeDimensions)*ijk.z;\\n  float zmix =  indexZ - floor(indexZ);\\n\\n  return mix(val1, val2, zmix);\\n}\\n\\nvec4 getOneTextureValue(vec3 ijk)\\n#else // nearest or fast linear\\nvec4 getTextureValue(vec3 ijk)\\n#endif\\n{\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n#ifdef debugtile\\n  vec2 tpos = vec2(ijk.x, ijk.y);\\n  vec4 tmp = texture2D(texture1, tpos);\\n  tmp.a = 1.0;\\n\\n#else\\n  int z = int(ijk.z * tdims.z);\\n  int yz = z / xreps;\\n  int xz = z - yz*xreps;\\n\\n  int tileWidth = volumeDimensions.x/xstride;\\n  int tileHeight = volumeDimensions.y/ystride;\\n\\n  xz *= tileWidth;\\n  yz *= tileHeight;\\n\\n  float ni = float(xz) + (ijk.x*float(tileWidth));\\n  float nj = float(yz) + (ijk.y*float(tileHeight));\\n\\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\\n\\n  vec4 tmp = texture2D(texture1, tpos);\\n\\n#if vtkNumComponents == 1\\n  tmp.a = tmp.r;\\n#endif\\n#if vtkNumComponents == 2\\n  tmp.g = tmp.a;\\n#endif\\n#if vtkNumComponents == 3\\n  tmp.a = length(tmp.rgb);\\n#endif\\n#endif\\n\\n  return tmp;\\n}\\n\\n// End of Webgl1 specific code\\n//=======================================================================\\n#endif\\n\\n//=======================================================================\\n// transformation between VC and IS space\\n\\n// convert vector position from idx to vc\\n#if vtkLightComplexity > 0\\nvec3 IStoVC(vec3 posIS){\\n  vec3 posVC = posIS / vVCToIJK;\\n  return posVC.x * vPlaneNormal0 + \\n         posVC.y * vPlaneNormal2 + \\n         posVC.z * vPlaneNormal4 + \\n         vOriginVC;\\n}\\n\\n// convert vector position from vc to idx\\nvec3 VCtoIS(vec3 posVC){\\n  posVC = posVC - vOriginVC;\\n  posVC = vec3(\\n    dot(posVC, vPlaneNormal0),\\n    dot(posVC, vPlaneNormal2),\\n    dot(posVC, vPlaneNormal4));  \\n  return posVC * vVCToIJK;\\n}\\n#endif\\n\\n//Rotate vector to view coordinate\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\nvoid rotateToViewCoord(inout vec3 dirIS){\\n  dirIS.xyz =\\n    dirIS.x * vPlaneNormal0 +\\n    dirIS.y * vPlaneNormal2 +\\n    dirIS.z * vPlaneNormal4;\\n}\\n\\n//Rotate vector to idx coordinate\\nvec3 rotateToIDX(vec3 dirVC){\\n  vec3 dirIS;\\n  dirIS.xyz = vec3(\\n    dot(dirVC, vPlaneNormal0),\\n    dot(dirVC, vPlaneNormal2),\\n    dot(dirVC, vPlaneNormal4));  \\n  return dirIS;\\n}\\n#endif\\n\\n//=======================================================================\\n// Given a normal compute the gradient opacity factors\\nfloat computeGradientOpacityFactor(\\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\\n{\\n#if defined(vtkGradientOpacityOn)\\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\\n#else\\n  return 1.0;\\n#endif\\n}\\n\\n//=======================================================================\\n// compute the normal and gradient magnitude for a position, uses forward difference\\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\\n  #ifdef vtkComputeNormalFromOpacity\\n    #ifdef vtkGradientOpacityOn\\n      vec4 computeNormalForDensity(vec3 pos, float scalar, vec3 tstep, out mat3 scalarInterp, out vec3 secondaryGradientMag)\\n      {\\n        vec4 result;\\n        scalarInterp[0][0] = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)).a;\\n        scalarInterp[0][1] = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)).a;\\n        scalarInterp[0][2] = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)).a;\\n        // look up scalar values for computing secondary gradient\\n        scalarInterp[1][0] = getTextureValue(pos + vec3(2.0*tstep.x, 0.0, 0.0)).a;\\n        scalarInterp[1][1] = getTextureValue(pos + vec3(0.0, 2.0*tstep.y, 0.0)).a;\\n        scalarInterp[1][2] = getTextureValue(pos + vec3(0.0, 0.0, 2.0*tstep.z)).a;\\n        scalarInterp[2][0] = getTextureValue(pos + vec3(tstep.x, tstep.y, 0.0)).a;\\n        scalarInterp[2][1] = getTextureValue(pos + vec3(tstep.x, 0.0, tstep.z)).a;\\n        scalarInterp[2][2] = getTextureValue(pos + vec3(0.0, tstep.y, tstep.z)).a;\\n        result.x = scalarInterp[0][0] - scalar;\\n        result.y = scalarInterp[0][1] - scalar;\\n        result.z = scalarInterp[0][2] - scalar;\\n        // divide by spacing\\n        result.xyz /= vSpacing;\\n        result.w = length(result.xyz);\\n        rotateToViewCoord(result.xyz);\\n        secondaryGradientMag.x = length(vec3(scalarInterp[1][0] - scalarInterp[0][0],\\n                                             scalarInterp[2][0] - scalarInterp[0][0],\\n                                             scalarInterp[2][1] - scalarInterp[0][0]) / vSpacing);\\n        secondaryGradientMag.y = length(vec3(scalarInterp[2][0] - scalarInterp[0][1],\\n                                             scalarInterp[1][1] - scalarInterp[0][1],\\n                                             scalarInterp[2][2] - scalarInterp[0][1]) / vSpacing);\\n        secondaryGradientMag.z = length(vec3(scalarInterp[2][1] - scalarInterp[0][2],\\n                                             scalarInterp[2][2] - scalarInterp[0][2],\\n                                             scalarInterp[1][2] - scalarInterp[0][2]) / vSpacing);\\n        if (length(result.xyz) > 0.0) {\\n          return vec4(normalize(result.xyz),result.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      }\\n\\n      vec4 computeDensityNormal(float scalar, float gradientMag, mat3 scalarInterp, vec3 secondaryGradientMag)\\n      {\\n        vec4 opacityG;\\n        vec3 opacityInterp = vec3(0.0);\\n        float opacity = texture2D(otexture, vec2(scalar * oscale0 + oshift0, 0.5)).r;\\n        if (gradientMag >= 0.0){\\n          opacity *= computeGradientOpacityFactor(gradientMag, goscale0, goshift0, gomin0, gomax0);\\n        }\\n        opacityInterp.x = texture2D(otexture, vec2(scalarInterp[0][0] * oscale0 + oshift0, 0.5)).r; \\n        if (secondaryGradientMag.x >= 0.0){\\n          opacityInterp.x *= computeGradientOpacityFactor(secondaryGradientMag.x, goscale0, goshift0, gomin0, gomax0);\\n        }\\n    \\n        opacityInterp.y = texture2D(otexture, vec2(scalarInterp[0][1] * oscale0 + oshift0, 0.5)).r;\\n        if (secondaryGradientMag.y >= 0.0){\\n          opacityInterp.y *= computeGradientOpacityFactor(secondaryGradientMag.y, goscale0, goshift0, gomin0, gomax0);\\n        }\\n\\n        opacityInterp.z = texture2D(otexture, vec2(scalarInterp[0][2] * oscale0 + oshift0, 0.5)).r;\\n        if (secondaryGradientMag.z >= 0.0){\\n          opacityInterp.z *= computeGradientOpacityFactor(secondaryGradientMag.z, goscale0, goshift0, gomin0, gomax0);\\n        }\\n\\n        opacityG.xyz = opacityInterp - vec3(opacity,opacity,opacity);\\n        // divide by spacing\\n        opacityG.xyz /= vSpacing;\\n        opacityG.w = length(opacityG.xyz);\\n        rotateToViewCoord(opacityG.xyz);\\n        if (length(opacityG.xyz) > 0.0) {  \\n          return vec4(normalize(opacityG.xyz),opacityG.w);\\n        } else {\\n          return vec4(0.0);\\n        }\\n      } \\n\\n    #else\\n    //if gradient opacity not on but using density gradient\\n      vec4 computeDensityNormal(float scalar, vec3 scalarInterp) \\n      { \\n        vec4 opacityG; \\n        float opacity = texture2D(otexture, vec2(scalar * oscale0 + oshift0, 0.5)).r; \\n        opacityG.x = texture2D(otexture, vec2(scalarInterp.x * oscale0 + oshift0, 0.5)).r - opacity; \\n        opacityG.y = texture2D(otexture, vec2(scalarInterp.y * oscale0 + oshift0, 0.5)).r - opacity; \\n        opacityG.z = texture2D(otexture, vec2(scalarInterp.z * oscale0 + oshift0, 0.5)).r - opacity; \\n        // divide by spacing \\n        opacityG.xyz /= vSpacing; \\n        opacityG.w = length(opacityG.xyz); \\n        // rotate to View Coords \\n        rotateToViewCoord(opacityG.xyz);\\n        if (length(opacityG.xyz) > 0.0) {     \\n          return vec4(normalize(opacityG.xyz),opacityG.w); \\n        } else { \\n          return vec4(0.0); \\n        } \\n      } \\n      vec4 computeNormalForDensity(vec3 pos, float scalar, vec3 tstep, out vec3 scalarInterp) \\n      { \\n        vec4 result; \\n        scalarInterp.x = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)).a; \\n        scalarInterp.y = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)).a; \\n        scalarInterp.z = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)).a; \\n        result.x = scalarInterp.x - scalar; \\n        result.y = scalarInterp.y - scalar; \\n        result.z = scalarInterp.z - scalar;   \\n        // divide by spacing\\n        result.xyz /= vSpacing;\\n        result.w = length(result.xyz); \\n        // rotate to View Coords \\n        rotateToViewCoord(result.xyz);      \\n        if (length(result.xyz) > 0.0) {     \\n          return vec4(normalize(result.xyz),result.w); \\n        } else { \\n          return vec4(0.0); \\n        } \\n      }           \\n    #endif\\n  #endif\\n  // compute scalar density\\n  vec4 computeNormal(vec3 pos, float scalar, vec3 tstep)  \\n  {  \\n    vec4 result;  \\n    result.x = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)).a - scalar;  \\n    result.y = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)).a - scalar;  \\n    result.z = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)).a - scalar;  \\n    // divide by spacing  \\n    result.xyz /= vSpacing;  \\n    result.w = length(result.xyz);\\n    if (result.w > 0.0){\\n      // rotate to View Coords  \\n      rotateToViewCoord(result.xyz);\\n      return vec4(normalize(result.xyz),result.w);  \\n    } else {\\n      return vec4(0.0);\\n    }\\n  }  \\n#endif\\n\\n#ifdef vtkImageLabelOutlineOn\\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\\n  vec4 pcPos = vec4(\\n    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\\n    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\\n    (fragCoord.z - 0.5) * 2.0,\\n    1.0);\\n\\n  vec4 worldCoord = PCWCMatrix * pcPos;\\n  vec4 vertex = (worldCoord/worldCoord.w);\\n\\n  vec3 index = (vWCtoIDX * vertex).xyz;\\n\\n  // half voxel fix for labelmapOutline \\n  return (index + vec3(0.5)) / vec3(volumeDimensions);\\n}\\n#endif\\n\\n//=======================================================================\\n// compute the normals and gradient magnitudes for a position\\n// for independent components\\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\\n{\\n  mat4 result;\\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\\n\\n  // divide by spacing\\n  distX /= vSpacing.x;\\n  distY /= vSpacing.y;\\n  distZ /= vSpacing.z;\\n\\n  mat3 rot;\\n  rot[0] = vPlaneNormal0;\\n  rot[1] = vPlaneNormal2;\\n  rot[2] = vPlaneNormal4;\\n\\n#if !defined(vtkComponent0Proportional)\\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\\n  result[0].a = length(result[0].xyz);\\n  result[0].xyz *= rot;\\n  if (result[0].w > 0.0)\\n  {\\n    result[0].xyz /= result[0].w;\\n  }\\n#endif\\n\\n// optionally compute the 2nd component\\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\\n  result[1].a = length(result[1].xyz);\\n  result[1].xyz *= rot;\\n  if (result[1].w > 0.0)\\n  {\\n    result[1].xyz /= result[1].w;\\n  }\\n#endif\\n\\n// optionally compute the 3rd component\\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\\n  result[2].a = length(result[2].xyz);\\n  result[2].xyz *= rot;\\n  if (result[2].w > 0.0)\\n  {\\n    result[2].xyz /= result[2].w;\\n  }\\n#endif\\n\\n// optionally compute the 4th component\\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\\n  result[3].a = length(result[3].xyz);\\n  result[3].xyz *= rot;\\n  if (result[3].w > 0.0)\\n  {\\n    result[3].xyz /= result[3].w;\\n  }\\n#endif\\n\\n  return result;\\n}\\n\\n//=======================================================================\\n// global shadow - secondary ray\\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\\nfloat random()\\n{ \\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\\n  uint pcg_state = floatBitsToUint(jitter);\\n  uint state = pcg_state;\\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\\n}\\n#endif\\n\\n#ifdef VolumeShadowOn\\n// henyey greenstein phase function\\nfloat phase_function(float cos_angle)\\n{\\n  // divide by 2.0 instead of 4pi to increase intensity\\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\\n}\\n\\n// Computes the intersection between a ray and a box\\nstruct Hit\\n{\\n  float tmin;\\n  float tmax;\\n};\\n\\nstruct Ray\\n{\\n  vec3 origin;\\n  vec3 dir;\\n  vec3 invDir;\\n};\\n\\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\\n{\\n  vec3 tbot = r.invDir * (boundMin - r.origin);\\n  vec3 ttop = r.invDir * (boundMax - r.origin);\\n  vec3 tmin = min(ttop, tbot);\\n  vec3 tmax = max(ttop, tbot);\\n  vec2 t = max(tmin.xx, tmin.yz);\\n  float t0 = max(t.x, t.y);\\n  t = min(tmax.xx, tmax.yz);\\n  float t1 = min(t.x, t.y);\\n  hit.tmin = t0;\\n  hit.tmax = t1;\\n  return t1 > max(t0,0.0);\\n}\\n\\n// As BBoxIntersect requires the inverse of the ray coords,\\n// this function is used to avoid numerical issues\\nvoid safe_0_vector(inout Ray ray)\\n{\\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\\n}\\n\\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\\n{\\n  float shadow = 1.0;\\n  float opacity = 0.0;\\n\\n  // modify sample distance with a random number between 0.8 and 1.0\\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(0.8, 1.0, random());\\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\\n  \\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position \\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;  \\n\\n  // compute the start and end points for the ray\\n  Ray ray;\\n  Hit hit;  \\n  ray.origin = posIS;\\n  ray.dir = lightDirNormIS;\\n  safe_0_vector(ray);\\n  ray.invDir = 1.0/ray.dir;\\n  \\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\\n  {\\n    return 1.0;\\n  }\\n  vec4 scalar = vec4(0.0);\\n  float maxdist = hit.tmax;\\n  if(maxdist < EPSILON) {\\n    return 1.0;\\n  }\\n\\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\\n  maxdist = min(maxdist,maxgi);\\n\\n  // support gradient opacity\\n  #ifdef vtkGradientOpacityOn\\n    vec4 normal;\\n  #endif\\n\\n  vec3 current_step = sampleDistanceISVS_jitter * lightDirNormIS;\\n  float maxSteps = ceil(maxdist/sampleDistanceISVS_jitter);\\n  float opacityDelta = 0.0;\\n\\n  for (float i = 0.0; i < maxSteps; i++)\\n  {\\n    scalar = getTextureValue(posIS);\\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\\n    #ifdef vtkGradientOpacityOn \\n      normal = computeNormal(posIS, scalar.a, vec3(1.0/vec3(volumeDimensions))); \\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n    #endif    \\n    shadow *= 1.0 - opacity;\\n\\n    // optimization: early termination\\n    if (shadow < EPSILON){\\n      return 0.0;\\n    }\\n\\n    // optimization: increase/decrease sample distance based on changed in opacity value\\n    opacityDelta = opacityPrev - opacity;\\n    opacityPrev = opacity;\\n    if (opacityDelta > 0.0){\\n      current_step *= 0.9;\\n    } else if (opacityDelta < 0.0){\\n      current_step *= 1.1;\\n    }\\n    posIS += current_step;\\n  }\\n\\n  return shadow;  \\n}\\n\\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\\n{\\n  vec3 vertLight = vec3(0.0);\\n  vec3 secondary_contrib = vec3(0.0);\\n  // here we assume only positional light, no effect of cones\\n  for (int i = 0; i < lightNum; i++)\\n  {\\n    #if(vtkLightComplexity==3)\\n      if (lightPositional[i] == 1){\\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\\n      }else{\\n        vertLight = - lightDirectionVC[i];\\n      }\\n    #else\\n      vertLight = - lightDirectionVC[i];\\n    #endif\\n    // here we assume achromatic light, only intensity\\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\\n    float phase_attenuation = 0.5;\\n    if (abs(anisotropy) > EPSILON){\\n      phase_attenuation = phase_function(dDotL);\\n    }\\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;     \\n    secondary_contrib += tColor * vAmbient;\\n  } \\n  return secondary_contrib;\\n}\\n#endif\\n\\n//=======================================================================\\n// local ambient occlusion\\n#ifdef localAmbientOcclusionOn\\nvec3 sample_direction_uniform(int i)\\n{\\n  float rand = random() * 0.5;\\n  float theta = PI2 * (kernelSample[i][0] + rand);\\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\\n}\\n\\n// return a matrix that transform startDir into z axis; startDir should be normalized\\nmat3 zBaseRotationalMatrix(vec3 startDir){\\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\\n  float cosA = startDir.z;\\n  float k = 1.0 / (1.0 + cosA);\\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\\n  return matrix;\\n}\\n\\nfloat computeLAO(vec3 posIS, float opacity, vec3 lightDir, vec4 normal){\\n  // apply LAO only at selected locations, otherwise return full brightness\\n  if (normal.w > 0.0 && opacity > 0.05){\\n    float total_transmittance = 0.0;\\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\\n    vec3 currPos, randomDirStep;\\n    float weight, transmittance, opacity;\\n    for (int i = 0; i < kernelSize; i++)\\n    {\\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\\n      currPos = posIS;\\n      transmittance = 1.0;\\n      for (int j = 0; j < kernelRadius ; j++){\\n        currPos += randomDirStep;\\n        // check if it's at clipping plane, if so return full brightness\\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\\n          #ifdef vtkGradientOpacityOn\\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\\n          #endif\\n          transmittance *= 1.0 - opacity;\\n        }\\n        else{\\n          break;\\n        }\\n      }\\n      total_transmittance += transmittance / float(kernelRadius) * weight;\\n\\n      // early termination if fully translucent\\n      if (total_transmittance > 1.0 - EPSILON){\\n        return 1.0;\\n      }\\n    }\\n    // average transmittance and reduce variance\\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0); \\n  } else {\\n    return 1.0;\\n  }\\n}\\n#endif\\n\\n//=======================================================================\\n// surface light contribution\\n#if vtkLightComplexity > 0\\n  void applyLighting(inout vec3 tColor, vec4 normal)\\n  {\\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\\n    vec3 specular = vec3(0.0, 0.0, 0.0);\\n    float df, sf = 0.0;\\n    for (int i = 0; i < lightNum; i++){\\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\\n        diffuse += df * lightColor[i];\\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\\n        specular += sf * lightColor[i];\\n    }\\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\\n  }\\n  #ifdef SurfaceShadowOn\\n  #if vtkLightComplexity < 3\\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif        \\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float ndotL,vdotR;\\n        vertLightDirection = lightDirectionVC[i];\\n        ndotL = dot(normal.xyz, vertLightDirection);\\n        if (ndotL < 0.0 && twoSidedLighting)\\n        {\\n          ndotL = -ndotL;\\n        }\\n        if (ndotL > 0.0)\\n        {\\n          diffuse += ndotL * lightColor[i];\\n          //specular\\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n          if (vdotR > 0.0)\\n          {\\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n          }\\n        }\\n        #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n        #endif\\n      }  \\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else \\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif    \\n    }\\n  #else\\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\\n    {\\n      // everything in VC\\n      vec3 diffuse = vec3(0.0);\\n      vec3 specular = vec3(0.0);\\n      #ifdef localAmbientOcclusionOn\\n        vec3 ambient = vec3(0.0);\\n      #endif      \\n      vec3 vertLightDirection;\\n      for (int i = 0; i < lightNum; i++){\\n        float distance,attenuation,ndotL,vdotR;\\n        vec3 lightDir;\\n        if (lightPositional[i] == 1){\\n          lightDir = lightDirectionVC[i];\\n          vertLightDirection = posVC - lightPositionVC[i]; \\n          distance = length(vertLightDirection);\\n          vertLightDirection = normalize(vertLightDirection);\\n          attenuation = 1.0 / (lightAttenuation[i].x\\n                              + lightAttenuation[i].y * distance\\n                              + lightAttenuation[i].z * distance * distance);\\n          // per OpenGL standard cone angle is 90 or less for a spot light\\n          if (lightConeAngle[i] <= 90.0){\\n            float coneDot = dot(vertLightDirection, lightDir);\\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\\n            }\\n            else {\\n              attenuation = 0.0;\\n            }\\n          }\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * attenuation * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif          \\n        } else {\\n          vertLightDirection = lightDirectionVC[i];\\n          ndotL = dot(normal.xyz, vertLightDirection);\\n          if (ndotL < 0.0 && twoSidedLighting)\\n          {\\n            ndotL = -ndotL;\\n          }\\n          if (ndotL > 0.0)\\n          {\\n            diffuse += ndotL * lightColor[i];\\n            //specular\\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\\n            if (vdotR > 0.0)\\n            {\\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\\n            }\\n          }\\n          #ifdef localAmbientOcclusionOn\\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\\n          #endif          \\n        }\\n      }\\n      #ifdef localAmbientOcclusionOn\\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\\n      #else \\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\\n      #endif\\n    }\\n  #endif \\n  #endif\\n#endif\\n\\n//=======================================================================\\n// Given a texture value compute the color and opacity\\n//\\nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\\n{\\n#ifdef vtkImageLabelOutlineOn\\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\\n  vec4 centerValue = getTextureValue(centerPosIS);\\n  bool pixelOnBorder = false;\\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\\n\\n  // Get alpha of segment from opacity function.\\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\\n\\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\\n  // Saves a bunch of needless checks on the background.\\n  // TODO define epsilon when building shader?\\n  if (float(tColor.a) > 0.01) {\\n    for (int i = -outlineThickness; i <= outlineThickness; i++) {\\n      for (int j = -outlineThickness; j <= outlineThickness; j++) {\\n        if (i == 0 || j == 0) {\\n          continue;\\n        }\\n\\n        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n          gl_FragCoord.y + float(j),\\n          gl_FragCoord.z, gl_FragCoord.w);\\n\\n        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n        vec4 value = getTextureValue(neighborPosIS);\\n\\n        // If any of my neighbours are not the same value as I\\n        // am, this means I am on the border of the segment.\\n        // We can break the loops\\n        if (any(notEqual(value, centerValue))) {\\n          pixelOnBorder = true;\\n          break;\\n        }\\n      }\\n\\n      if (pixelOnBorder == true) {\\n        break;\\n      }\\n    }\\n\\n    // If I am on the border, I am displayed at full opacity\\n    if (pixelOnBorder == true) {\\n      tColor.a = 1.0;\\n    }\\n  }\\n\\n#else\\n  // compute the normal and gradient magnitude if needed\\n  // We compute it as a vec4 if possible otherwise a mat4\\n  //\\n  vec4 goFactor = vec4(1.0,1.0,1.0,1.0);\\n\\n  // compute the normal vectors as needed\\n  #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\\n      #if !defined(vtkComponent0Proportional)\\n        vec4 normal0 = normalMat[0];\\n      #endif\\n      #if !defined(vtkComponent1Proportional)\\n        vec4 normal1 = normalMat[1];\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          vec4 normal2 = normalMat[2];\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            vec4 normal3 = normalMat[3];\\n          #endif\\n        #endif\\n      #endif\\n    #else\\n      vec4 normalLight;\\n      #ifdef vtkComputeNormalFromOpacity\\n        #ifdef vtkGradientOpacityOn\\n          mat3 scalarInterp;  \\n          vec3 secondaryGradientMag;  \\n          vec4 normal0 = computeNormalForDensity(posIS, tValue.a, tstep, scalarInterp, secondaryGradientMag);  \\n          normalLight = computeDensityNormal(tValue.a, normal0.w, scalarInterp,secondaryGradientMag);       \\n          if (length(normalLight) == 0.0){  \\n            normalLight = normal0;   \\n          }                      \\n        #else\\n          vec3 scalarInterp;  \\n          vec4 normal0 = computeNormalForDensity(posIS, tValue.a, tstep, scalarInterp);  \\n          if (length(normal0)>0.0){  \\n            normalLight = computeDensityNormal(tValue.a,scalarInterp);  \\n            if (length(normalLight)==0.0){  \\n              normalLight = normal0;  \\n            }  \\n          }                \\n        #endif\\n      #else \\n        vec4 normal0 = computeNormal(posIS, tValue.a, tstep);  \\n        normalLight = normal0;             \\n      #endif\\n    #endif\\n  #endif\\n\\n  // compute gradient opacity factors as needed\\n  #if defined(vtkGradientOpacityOn)\\n    #if !defined(vtkComponent0Proportional)\\n      goFactor.x =\\n        computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\\n    #endif\\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\\n      #if !defined(vtkComponent1Proportional)\\n        goFactor.y =\\n          computeGradientOpacityFactor(normal1.a, goscale1, goshift1, gomin1, gomax1);\\n      #endif\\n      #if vtkNumComponents > 2\\n        #if !defined(vtkComponent2Proportional)\\n          goFactor.z =\\n            computeGradientOpacityFactor(normal2.a, goscale2, goshift2, gomin2, gomax2);\\n        #endif\\n        #if vtkNumComponents > 3\\n          #if !defined(vtkComponent3Proportional)\\n            goFactor.w =\\n              computeGradientOpacityFactor(normal3.a, goscale3, goshift3, gomin3, gomax3);\\n          #endif\\n        #endif\\n      #endif\\n    #endif\\n  #endif\\n\\n  // single component is always independent\\n  #if vtkNumComponents == 1\\n    vec4 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5));\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\\n    if (tColor.a < EPSILON){\\n      return vec4(0.0);\\n    }    \\n  #endif\\n\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n    vec4 tColor = mix0*texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0));\\n    #if !defined(vtkComponent0Proportional)\\n      tColor.a = goFactor.x*mix0*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\\n      tColor *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix0));\\n    #endif\\n\\n    vec3 tColor1 = mix1*texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\\n    #if !defined(vtkComponent1Proportional)\\n      tColor.a += goFactor.y*mix1*texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n    #else\\n      float pwfValue = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\\n      tColor1 *= pwfValue;\\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix1));\\n    #endif\\n\\n    #if vtkNumComponents >= 3\\n      vec3 tColor2 = mix2*texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\\n      #if !defined(vtkComponent2Proportional)\\n        tColor.a += goFactor.z*mix2*texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n      #else\\n        float pwfValue = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\\n        tColor2 *= pwfValue;\\n        tColor.a *= mix(pwfValue, 1.0, (1.0 - mix2));\\n      #endif\\n\\n      #if vtkNumComponents >= 4\\n        vec3 tColor3 = mix3*texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\\n        #if !defined(vtkComponent3Proportional)\\n          tColor.a += goFactor.w*mix3*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n        #else\\n          float pwfValue = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\\n          tColor3 *= pwfValue;\\n          tColor.a *= mix(pwfValue, 1.0, (1.0 - mix3));\\n        #endif\\n      #endif\\n    #endif\\n  #else // then not independent\\n\\n  #if vtkNumComponents == 2\\n    float lum = tValue.r * cscale0 + cshift0;\\n    float alpha = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\\n    vec4 tColor = vec4(lum, lum, lum, alpha);\\n  #endif\\n  #if vtkNumComponents == 3\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\\n  #endif\\n  #if vtkNumComponents == 4\\n    vec4 tColor;\\n    tColor.r = tValue.r * cscale0 + cshift0;\\n    tColor.g = tValue.g * cscale1 + cshift1;\\n    tColor.b = tValue.b * cscale2 + cshift2;\\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\\n  #endif\\n  #endif // dependent\\n\\n  // apply lighting if requested as appropriate\\n  #if vtkLightComplexity > 0\\n    #if !defined(vtkComponent0Proportional) \\n      #if vtkNumComponents == 1\\n    \\n        #ifdef SurfaceShadowOn\\n            #if vtkLightComplexity < 3\\n                vec3 tColorS = applyLightingDirectional(posIS, tColor, normalLight);\\n            #else\\n                vec3 tColorS = applyLightingPositional(posIS, tColor, normalLight, IStoVC(posIS));\\n            #endif\\n        #endif\\n\\n        #ifdef VolumeShadowOn\\n          vec3 tColorVS = applyShadowRay(tColor.rgb, posIS, rayDirVC);\\n          #ifdef SurfaceShadowOn\\n            float vol_coef = volumetricScatteringBlending * (1.0 - tColor.a / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\\n            tColor.rgb = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\\n          #else\\n            tColor.rgb = tColorVS;\\n          #endif\\n        #else\\n            tColor.rgb = tColorS;\\n        #endif\\n        \\n      #else\\n        applyLighting(tColor.rgb, normal0);\\n      #endif\\n    #endif\\n\\n    #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n      #if !defined(vtkComponent1Proportional)\\n        applyLighting(tColor1, normal1);\\n      #endif\\n    #if vtkNumComponents >= 3\\n      #if !defined(vtkComponent2Proportional)\\n        applyLighting(tColor2, normal2);\\n      #endif\\n    #if vtkNumComponents >= 4\\n      #if !defined(vtkComponent3Proportional)\\n        applyLighting(tColor3, normal3);\\n      #endif\\n    #endif\\n    #endif\\n    #endif\\n  #endif\\n\\n// perform final independent blend as needed\\n#if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\\n  tColor.rgb += tColor1;\\n#if vtkNumComponents >= 3\\n  tColor.rgb += tColor2;\\n#if vtkNumComponents >= 4\\n  tColor.rgb += tColor3;\\n#endif\\n#endif\\n#endif\\n\\n#endif\\n\\n\\n\\n\\n\\n\\n\\nreturn tColor;\\n}\\n\\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\\n  bool withinRange = false;\\n  #if vtkNumComponents == 1\\n    if (val.r >= min.r && val.r <= max.r) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents == 2\\n     if (val.r >= min.r && val.r <= max.r &&\\n        val.g >= min.g && val.g <= max.g) {\\n      withinRange = true;\\n    }\\n  #endif\\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 3\\n    if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\\n        all(lessThanEqual(val, ipScalarRangeMax))) {\\n      withinRange = true;\\n    }\\n  #endif\\n  return withinRange;\\n}\\n\\n//=======================================================================\\n// Apply the specified blend mode operation along the ray's path.\\n//\\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\\n{\\n  vec3 tstep = 1.0/tdims;\\n\\n  // start slightly inside and apply some jitter\\n  vec3 delta = endIS - posIS;\\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\\n  float raySteps = length(delta)/sampleDistanceIS;\\n\\n  // avoid 0.0 jitter\\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\\n  float stepsTraveled = jitter;\\n\\n  // local vars for the loop\\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\\n  vec4 tValue;\\n  vec4 tColor;\\n\\n  // if we have less than one step then pick the middle point\\n  // as our value\\n  // if (raySteps <= 1.0)\\n  // {\\n  //   posIS = (posIS + endIS)*0.5;\\n  // }\\n\\n  // Perform initial step at the volume boundary\\n  // compute the scalar\\n  tValue = getTextureValue(posIS);\\n\\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\\n    // now map through opacity and color\\n    tColor = getColorForValue(tValue, posIS, tstep);\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0)\\n    {\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\\n      gl_FragData[0] = tColor;\\n      return;\\n    }\\n\\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\\n    posIS += (jitter*stepIS);\\n\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n\\n      float mix = (1.0 - color.a);\\n\\n      // this line should not be needed but nvidia seems to not handle\\n      // the break correctly on windows/chrome 58 angle\\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\\n\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n      stepsTraveled++;\\n      posIS += stepIS;\\n      if (color.a > 0.99) { color.a = 1.0; break; }\\n    }\\n\\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\\n    {\\n      posIS = endIS;\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // now map through opacity and color\\n      tColor = getColorForValue(tValue, posIS, tstep);\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\\n\\n      float mix = (1.0 - color.a);\\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\\n    }\\n\\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\\n  #endif\\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\\n    // Find maximum/minimum intensity along the ray.\\n\\n    // Define the operation we will use (min or max)\\n    #if vtkBlendMode == 1\\n    #define OP max\\n    #else\\n    #define OP min\\n    #endif\\n\\n    // If the clipping range is shorter than the sample distance\\n    // we can skip the sampling loop along the ray.\\n    if (raySteps <= 1.0)\\n    {\\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\\n      return;\\n    }\\n\\n    vec4 value = tValue;\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // Update the maximum value if necessary\\n      value = OP(tValue, value);\\n\\n      // Otherwise, continue along the ray\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n    tValue = getTextureValue(posIS);\\n    value = OP(tValue, value);\\n\\n    // Now map through opacity and color\\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\\n  #endif\\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\\n    vec4 sum = vec4(0.);\\n\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n    }\\n\\n    if (raySteps <= 1.0) {\\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n      return;\\n    }\\n\\n    posIS += (jitter*stepIS);\\n\\n    // Sample along the ray until MaximumSamplesValue,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\\n    {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n\\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\\n      // Notes:\\n      // - We are comparing all values in the texture to see if any of them\\n      //   are outside of the scalar range. In the future we might want to allow\\n      //   scalar ranges for each component.\\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n        // Sum the values across each step in the path\\n        sum += tValue;\\n      }\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = endIS;\\n\\n    // compute the scalar\\n    tValue = getTextureValue(posIS);\\n\\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\\n      sum += tValue;\\n\\n      stepsTraveled++;\\n    }\\n\\n    #if vtkBlendMode == 3 // Average\\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\\n    #endif\\n\\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\\n  #endif\\n}\\n\\n//=======================================================================\\n// Compute a new start and end point for a given ray based\\n// on the provided bounded clipping plane (aka a rectangle)\\nvoid getRayPointIntersectionBounds(\\n  vec3 rayPos, vec3 rayDir,\\n  vec3 planeDir, float planeDist,\\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\\n  float vSize1, float vSize2)\\n{\\n  float result = dot(rayDir, planeDir);\\n  if (abs(result) < 1e-6)\\n  {\\n    return;\\n  }\\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\\n  vec3 xposVC = rayPos + rayDir*result;\\n  vec3 vxpos = xposVC - vOriginVC;\\n  vec2 vpos = vec2(\\n    dot(vxpos, vPlaneX),\\n    dot(vxpos, vPlaneY));\\n\\n  // on some apple nvidia systems this does not work\\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\\n  //     vpos.y < 0.0 || vpos.y > vSize2)\\n  // even just\\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\\n  // fails\\n  // so instead we compute a value that represents in and out\\n  //and then compute the return using this value\\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\\n\\n  tbounds = mix(\\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\\n   tbounds, // out value\\n   check);  // 0 in 1 out\\n}\\n\\n//=======================================================================\\n// given a\\n// - ray direction (rayDir)\\n// - starting point (vertexVCVSOutput)\\n// - bounding planes of the volume\\n// - optionally depth buffer values\\n// - far clipping plane\\n// compute the start/end distances of the ray we need to cast\\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\\n{\\n  vec2 dists = vec2(100.0*camFar, -1.0);\\n\\n  vec3 vSize = vSpacing*tdims;\\n\\n  // all this is in View Coordinates\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\\n    vSize.y, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\\n    vSize.x, vSize.z);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\\n    vSize.x, vSize.y);\\n\\n  //VTK::ClipPlane::Impl\\n\\n  // do not go behind front clipping plane\\n  dists.x = max(0.0,dists.x);\\n\\n  // do not go PAST far clipping plane\\n  float farDist = -camThick/rayDir.z;\\n  dists.y = min(farDist,dists.y);\\n\\n  // Do not go past the zbuffer value if set\\n  // This is used for intermixing opaque geometry\\n  //VTK::ZBuffer::Impl\\n\\n  return dists;\\n}\\n\\n//=======================================================================\\n// Compute the index space starting position (pos) and end\\n// position\\n//\\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\\n{\\n  // compute starting and ending values in volume space\\n  pos = vertexVCVSOutput + dists.x*rayDir;\\n  pos = pos - vOriginVC;\\n  // convert to volume basis and origin\\n  pos = vec3(\\n    dot(pos, vPlaneNormal0),\\n    dot(pos, vPlaneNormal2),\\n    dot(pos, vPlaneNormal4));\\n\\n  endPos = vertexVCVSOutput + dists.y*rayDir;\\n  endPos = endPos - vOriginVC;\\n  endPos = vec3(\\n    dot(endPos, vPlaneNormal0),\\n    dot(endPos, vPlaneNormal2),\\n    dot(endPos, vPlaneNormal4));\\n\\n  float delta = length(endPos - pos);\\n\\n  pos *= vVCToIJK;\\n  endPos *= vVCToIJK;\\n\\n  float delta2 = length(endPos - pos);\\n  sampleDistanceIS = sampleDistance*delta2/delta;\\n  #ifdef VolumeShadowOn\\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\\n  #endif\\n}\\n\\nvoid main()\\n{\\n\\n  if (cameraParallel == 1)\\n  {\\n    // Camera is parallel, so the rayDir is just the direction of the camera.\\n    rayDirVC = vec3(0.0, 0.0, -1.0);\\n  } else {\\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\\n    rayDirVC = normalize(vertexVCVSOutput);\\n  }\\n\\n  vec3 tdims = vec3(volumeDimensions);\\n\\n  // compute the start and end points for the ray\\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\\n\\n  // do we need to composite? aka does the ray have any length\\n  // If not, bail out early\\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\\n  {\\n    discard;\\n  }\\n\\n  // IS = Index Space\\n  vec3 posIS;\\n  vec3 endIS;\\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\\n\\n  // Perform the blending operation along the ray\\n  applyBlend(posIS, endIS, tdims);\\n}\\n\";\n\nexport { vtkVolumeFS as v };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { newInstance as newInstance$1, obj, setGet, chain, vtkWarningMacro as vtkWarningMacro$1, vtkErrorMacro as vtkErrorMacro$1 } from '../../macros.js';\nimport { mat4, mat3, vec3 } from 'gl-matrix';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\nimport vtkHelper from './Helper.js';\nimport { u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLFramebuffer from './Framebuffer.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkVertexArrayObject from './VertexArrayObject.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { Wrap, Filter } from './Texture/Constants.js';\nimport { InterpolationType, OpacityMode } from '../Core/VolumeProperty/Constants.js';\nimport { BlendMode } from '../Core/VolumeMapper/Constants.js';\nimport { v as vtkVolumeVS } from './glsl/vtkVolumeVS.glsl.js';\nimport { v as vtkVolumeFS } from './glsl/vtkVolumeFS.glsl.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar vtkWarningMacro = vtkWarningMacro$1,\n    vtkErrorMacro = vtkErrorMacro$1; // TODO: Do we want this in some shared utility? Shouldwe just use lodash.isEqual\n\nfunction arrayEquals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n} // ----------------------------------------------------------------------------\n// vtkOpenGLVolumeMapper methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkOpenGLVolumeMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVolumeMapper');\n\n  publicAPI.buildPass = function () {\n    model.zBufferTexture = null;\n  }; // ohh someone is doing a zbuffer pass, use that for\n  // intermixed volume rendering\n\n\n  publicAPI.opaqueZBufferPass = function (prepass, renderPass) {\n    if (prepass) {\n      var zbt = renderPass.getZBufferTexture();\n\n      if (zbt !== model.zBufferTexture) {\n        model.zBufferTexture = zbt;\n      }\n    }\n  }; // Renders myself\n\n\n  publicAPI.volumePass = function (prepass, renderPass) {\n    if (prepass) {\n      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderWindow');\n      model.context = model._openGLRenderWindow.getContext();\n      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.jitterTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow); // Per Component?\n\n      model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);\n      model.openGLVolume = publicAPI.getFirstAncestorOfType('vtkOpenGLVolume');\n      var actor = model.openGLVolume.getRenderable();\n      model.openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      var ren = model.openGLRenderer.getRenderable();\n      model.openGLCamera = model.openGLRenderer.getViewNodeFor(ren.getActiveCamera());\n      publicAPI.renderPiece(ren, actor);\n    }\n  };\n\n  publicAPI.buildShaders = function (shaders, ren, actor) {\n    publicAPI.getShaderTemplate(shaders, ren, actor);\n    publicAPI.replaceShaderValues(shaders, ren, actor);\n  };\n\n  publicAPI.getShaderTemplate = function (shaders, ren, actor) {\n    shaders.Vertex = vtkVolumeVS;\n    shaders.Fragment = vtkVolumeFS;\n    shaders.Geometry = '';\n  };\n\n  publicAPI.replaceShaderValues = function (shaders, ren, actor) {\n    var FSSource = shaders.Fragment; // define some values in the shader\n\n    var iType = actor.getProperty().getInterpolationType();\n\n    if (iType === InterpolationType.LINEAR) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TrilinearOn', '#define vtkTrilinearOn').result;\n    }\n\n    var vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n\n    if (vtkImageLabelOutline === true) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ImageLabelOutlineOn', '#define vtkImageLabelOutlineOn').result;\n    }\n\n    var numComp = model.scalarTexture.getComponents();\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::NumComponents', \"#define vtkNumComponents \".concat(numComp)).result;\n    var iComps = actor.getProperty().getIndependentComponents();\n\n    if (iComps) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::IndependentComponentsOn', '#define vtkIndependentComponentsOn').result; // Define any proportional components\n\n      var proportionalComponents = [];\n\n      for (var nc = 0; nc < numComp; nc++) {\n        if (actor.getProperty().getOpacityMode(nc) === OpacityMode.PROPORTIONAL) {\n          proportionalComponents.push(\"#define vtkComponent\".concat(nc, \"Proportional\"));\n        }\n      }\n\n      if (proportionalComponents.length > 0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::vtkProportionalComponents', proportionalComponents.join('\\n')).result;\n      }\n    } // WebGL only supports loops over constants\n    // and does not support while loops so we\n    // have to hard code how many steps/samples to take\n    // We do a break so most systems will gracefully\n    // early terminate, but it is always possible\n    // a system will execute every step regardless\n\n\n    var ext = model.currentInput.getSpatialExtent();\n    var spc = model.currentInput.getSpacing();\n    var vsize = new Float64Array(3);\n    vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);\n    var maxSamples = vec3.length(vsize) / model.renderable.getSampleDistance();\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::MaximumSamplesValue', \"\".concat(Math.ceil(maxSamples))).result; // set light complexity\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::LightComplexity', \"#define vtkLightComplexity \".concat(model.lastLightComplexity)).result; // set shadow blending flag\n\n    if (model.lastLightComplexity > 0) {\n      if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::VolumeShadowOn', \"#define VolumeShadowOn\").result;\n      }\n\n      if (model.renderable.getVolumetricScatteringBlending() < 1.0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::SurfaceShadowOn', \"#define SurfaceShadowOn\").result;\n      }\n\n      if (model.renderable.getVolumetricScatteringBlending() === 0.0 && model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::localAmbientOcclusionOn', \"#define localAmbientOcclusionOn\").result;\n      }\n    } // if using gradient opacity define that\n\n\n    model.gopacity = actor.getProperty().getUseGradientOpacity(0);\n\n    for (var _nc = 1; iComps && !model.gopacity && _nc < numComp; ++_nc) {\n      if (actor.getProperty().getUseGradientOpacity(_nc)) {\n        model.gopacity = true;\n      }\n    }\n\n    if (model.gopacity) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::GradientOpacityOn', '#define vtkGradientOpacityOn').result;\n    } // set normal from density\n\n\n    if (model.renderable.getComputeNormalFromOpacity()) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::vtkComputeNormalFromOpacity', \"#define vtkComputeNormalFromOpacity\").result;\n    } // if we have a ztexture then declare it and use it\n\n\n    if (model.zBufferTexture !== null) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', ['uniform sampler2D zBufferTexture;', 'uniform float vpWidth;', 'uniform float vpHeight;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpWidth, gl_FragCoord.y/vpHeight));', 'float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;', 'zdepth = zdepth * 2.0 - 1.0;', 'zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;', 'zdepth = -zdepth/rayDir.z;', 'dists.y = min(zdepth,dists.y);']).result;\n    } // Set the BlendMode approach\n\n\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::BlendMode', \"\".concat(model.renderable.getBlendMode())).result;\n    shaders.Fragment = FSSource;\n    publicAPI.replaceShaderLight(shaders, ren, actor);\n    publicAPI.replaceShaderClippingPlane(shaders, ren, actor);\n  };\n\n  publicAPI.replaceShaderLight = function (shaders, ren, actor) {\n    if (model.lastLightComplexity === 0) {\n      return;\n    }\n\n    var FSSource = shaders.Fragment; // check for shadow maps - not implemented yet, skip\n    // const shadowFactor = '';\n    // to-do: single out the case when complexity = 1\n    // only account for lights that are switched on\n\n    var lightNum = 0;\n    ren.getLights().forEach(function (light) {\n      if (light.getSwitch()) {\n        lightNum += 1;\n      }\n    });\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', [\"uniform int lightNum;\", \"uniform bool twoSidedLighting;\", \"uniform vec3 lightColor[\".concat(lightNum, \"];\"), \"uniform vec3 lightDirectionVC[\".concat(lightNum, \"]; // normalized\"), \"uniform vec3 lightHalfAngleVC[\".concat(lightNum, \"];\"), '//VTK::Light::Dec'], false).result; // support any number of lights\n\n    if (model.lastLightComplexity === 3) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', [\"uniform vec3 lightPositionVC[\".concat(lightNum, \"];\"), \"uniform vec3 lightAttenuation[\".concat(lightNum, \"];\"), \"uniform float lightConeAngle[\".concat(lightNum, \"];\"), \"uniform float lightExponent[\".concat(lightNum, \"];\"), \"uniform int lightPositional[\".concat(lightNum, \"];\")], false).result;\n    }\n\n    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::VolumeShadow::Dec', [\"uniform float volumetricScatteringBlending;\", \"uniform float giReach;\", \"uniform float volumeShadowSamplingDistFactor;\", \"uniform float anisotropy;\", \"uniform float anisotropy2;\"], false).result;\n    }\n\n    if (model.renderable.getVolumetricScatteringBlending() === 0.0 && model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::LAO::Dec', [\"uniform int kernelRadius;\", \"uniform vec2 kernelSample[\".concat(model.renderable.getLAOKernelRadius(), \"];\"), \"uniform int kernelSize;\"], false).result;\n    }\n\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.replaceShaderClippingPlane = function (shaders, ren, actor) {\n    var FSSource = shaders.Fragment;\n\n    if (model.renderable.getClippingPlanes().length > 0) {\n      var clipPlaneSize = model.renderable.getClippingPlanes().length;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ClipPlane::Dec', [\"uniform vec3 vClipPlaneNormals[6];\", \"uniform float vClipPlaneDistances[6];\", '//VTK::ClipPlane::Dec'], false).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ClipPlane::Impl', [\"for(int i = 0; i < \".concat(clipPlaneSize, \"; i++) {\"), '  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);', '  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];', '  if (rayDirRatio == 0.0)', '  {', '    if (equationResult < 0.0) dists.x = dists.y;', '    continue;', '  }', '  float result = -1.0 * equationResult / rayDirRatio;', '  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);', '  else dists.x = max(dists.x, result);', '}', '//VTK::ClipPlane::Impl'], false).result;\n    }\n\n    shaders.Fragment = FSSource;\n  };\n\n  publicAPI.getNeedToRebuildShaders = function (cellBO, ren, actor) {\n    // do we need lighting?\n    var lightComplexity = 0;\n\n    if (actor.getProperty().getShade() && model.renderable.getBlendMode() === BlendMode.COMPOSITE_BLEND) {\n      // consider the lighting complexity to determine which case applies\n      // simple headlight, Light Kit, the whole feature set of VTK\n      lightComplexity = 0;\n      model.numberOfLights = 0;\n      ren.getLights().forEach(function (light) {\n        var status = light.getSwitch();\n\n        if (status > 0) {\n          model.numberOfLights++;\n\n          if (lightComplexity === 0) {\n            lightComplexity = 1;\n          }\n        }\n\n        if (lightComplexity === 1 && (model.numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {\n          lightComplexity = 2;\n        }\n\n        if (lightComplexity < 3 && light.getPositional()) {\n          lightComplexity = 3;\n        }\n      });\n    }\n\n    var needRebuild = false;\n\n    if (model.lastLightComplexity !== lightComplexity) {\n      model.lastLightComplexity = lightComplexity;\n      needRebuild = true;\n    }\n\n    var numComp = model.scalarTexture.getComponents();\n    var iComps = actor.getProperty().getIndependentComponents();\n    var usesProportionalComponents = false;\n    var proportionalComponents = [];\n\n    if (iComps) {\n      // Define any proportional components\n      for (var nc = 0; nc < numComp; nc++) {\n        proportionalComponents.push(actor.getProperty().getOpacityMode(nc));\n      }\n\n      if (proportionalComponents.length > 0) {\n        usesProportionalComponents = true;\n      }\n    }\n\n    var ext = model.currentInput.getSpatialExtent();\n    var spc = model.currentInput.getSpacing();\n    var vsize = new Float64Array(3);\n    vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);\n    var maxSamples = vec3.length(vsize) / model.renderable.getSampleDistance();\n    var state = {\n      interpolationType: actor.getProperty().getInterpolationType(),\n      useLabelOutline: actor.getProperty().getUseLabelOutline(),\n      numComp: numComp,\n      usesProportionalComponents: usesProportionalComponents,\n      iComps: iComps,\n      maxSamples: maxSamples,\n      useGradientOpacity: actor.getProperty().getUseGradientOpacity(0),\n      blendMode: model.renderable.getBlendMode(),\n      proportionalComponents: proportionalComponents\n    }; // We only need to rebuild the shader if one of these variables has changed,\n    // since they are used in the shader template replacement step.\n\n    if (!model.previousState || model.previousState.interpolationType !== state.interpolationType || model.previousState.useLabelOutline !== state.useLabelOutline || model.previousState.numComp !== state.numComp || model.previousState.usesProportionalComponents !== state.usesProportionalComponents || model.previousState.iComps !== state.iComps || model.previousState.maxSamples !== state.maxSamples || model.previousState.useGradientOpacity !== state.useGradientOpacity || model.previousState.blendMode !== state.blendMode || !arrayEquals(model.previousState.proportionalComponents, state.proportionalComponents)) {\n      model.previousState = _objectSpread({}, state);\n      return true;\n    } // has something changed that would require us to recreate the shader?\n\n\n    if (cellBO.getProgram() === 0 || needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || !!model.lastZBufferTexture !== !!model.zBufferTexture || cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime()) {\n      model.lastZBufferTexture = model.zBufferTexture;\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.updateShaders = function (cellBO, ren, actor) {\n    model.lastBoundBO = cellBO; // has something changed that would require us to recreate the shader?\n\n    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {\n      var shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      publicAPI.buildShaders(shaders, ren, actor); // compile and bind the program if needed\n\n      var newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry); // if the shader changed reinitialize the VAO\n\n\n      if (newShader !== cellBO.getProgram()) {\n        cellBO.setProgram(newShader); // reset the VAO as the shader has changed\n\n        cellBO.getVAO().releaseGraphicsResources();\n      }\n\n      cellBO.getShaderSourceTime().modified();\n    } else {\n      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());\n    }\n\n    cellBO.getVAO().bind();\n    publicAPI.setMapperShaderParameters(cellBO, ren, actor);\n    publicAPI.setCameraShaderParameters(cellBO, ren, actor);\n    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);\n    publicAPI.getClippingPlaneShaderParameters(cellBO, ren, actor);\n  };\n\n  publicAPI.setMapperShaderParameters = function (cellBO, ren, actor) {\n    // Now to update the VAO too, if necessary.\n    var program = cellBO.getProgram();\n\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      if (program.isAttributeUsed('vertexDC')) {\n        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), 'vertexDC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexDC in shader VAO.');\n        }\n      }\n\n      cellBO.getAttributeUpdateTime().modified();\n    }\n\n    program.setUniformi('texture1', model.scalarTexture.getTextureUnit());\n    program.setUniformf('sampleDistance', model.renderable.getSampleDistance());\n    var volInfo = model.scalarTexture.getVolumeInfo();\n    var ipScalarRange = model.renderable.getIpScalarRange();\n    var minVals = [];\n    var maxVals = [];\n\n    for (var i = 0; i < 4; i++) {\n      // convert iprange from 0-1 into data range values\n      minVals[i] = ipScalarRange[0] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];\n      maxVals[i] = ipScalarRange[1] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i]; // convert data ranges into texture values\n\n      minVals[i] = (minVals[i] - volInfo.offset[i]) / volInfo.scale[i];\n      maxVals[i] = (maxVals[i] - volInfo.offset[i]) / volInfo.scale[i];\n    }\n\n    program.setUniform4f('ipScalarRangeMin', minVals[0], minVals[1], minVals[2], minVals[3]);\n    program.setUniform4f('ipScalarRangeMax', maxVals[0], maxVals[1], maxVals[2], maxVals[3]); // if we have a zbuffer texture then set it\n\n    if (model.zBufferTexture !== null) {\n      program.setUniformi('zBufferTexture', model.zBufferTexture.getTextureUnit());\n      var size = model._useSmallViewport ? [model._smallViewportWidth, model._smallViewportHeight] : model._openGLRenderWindow.getFramebufferSize();\n      program.setUniformf('vpWidth', size[0]);\n      program.setUniformf('vpHeight', size[1]);\n    }\n  };\n\n  publicAPI.setCameraShaderParameters = function (cellBO, ren, actor) {\n    // // [WMVP]C == {world, model, view, projection} coordinates\n    // // E.g., WCPC == world to projection coordinate transformation\n    var keyMats = model.openGLCamera.getKeyMatrices(ren);\n    var actMats = model.openGLVolume.getKeyMatrices();\n    mat4.multiply(model.modelToView, keyMats.wcvc, actMats.mcwc);\n    var program = cellBO.getProgram();\n    var cam = model.openGLCamera.getRenderable();\n    var crange = cam.getClippingRange();\n    program.setUniformf('camThick', crange[1] - crange[0]);\n    program.setUniformf('camNear', crange[0]);\n    program.setUniformf('camFar', crange[1]);\n    var bounds = model.currentInput.getBounds();\n    var dims = model.currentInput.getDimensions(); // compute the viewport bounds of the volume\n    // we will only render those fragments.\n\n    var pos = new Float64Array(3);\n    var dir = new Float64Array(3);\n    var dcxmin = 1.0;\n    var dcxmax = -1.0;\n    var dcymin = 1.0;\n    var dcymax = -1.0;\n\n    for (var i = 0; i < 8; ++i) {\n      vec3.set(pos, bounds[i % 2], bounds[2 + Math.floor(i / 2) % 2], bounds[4 + Math.floor(i / 4)]);\n      vec3.transformMat4(pos, pos, model.modelToView);\n\n      if (!cam.getParallelProjection()) {\n        vec3.normalize(dir, pos); // now find the projection of this point onto a\n        // nearZ distance plane. Since the camera is at 0,0,0\n        // in VC the ray is just t*pos and\n        // t is -nearZ/dir.z\n        // intersection becomes pos.x/pos.z\n\n        var t = -crange[0] / pos[2];\n        vec3.scale(pos, dir, t);\n      } // now convert to DC\n\n\n      vec3.transformMat4(pos, pos, keyMats.vcpc);\n      dcxmin = Math.min(pos[0], dcxmin);\n      dcxmax = Math.max(pos[0], dcxmax);\n      dcymin = Math.min(pos[1], dcymin);\n      dcymax = Math.max(pos[1], dcymax);\n    }\n\n    program.setUniformf('dcxmin', dcxmin);\n    program.setUniformf('dcxmax', dcxmax);\n    program.setUniformf('dcymin', dcymin);\n    program.setUniformf('dcymax', dcymax);\n\n    if (program.isUniformUsed('cameraParallel')) {\n      program.setUniformi('cameraParallel', cam.getParallelProjection());\n    }\n\n    var ext = model.currentInput.getSpatialExtent();\n    var spc = model.currentInput.getSpacing();\n    var vsize = new Float64Array(3);\n    vec3.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);\n    program.setUniform3f('vSpacing', spc[0], spc[1], spc[2]);\n    vec3.set(pos, ext[0], ext[2], ext[4]);\n    model.currentInput.indexToWorldVec3(pos, pos);\n    vec3.transformMat4(pos, pos, model.modelToView);\n    program.setUniform3f('vOriginVC', pos[0], pos[1], pos[2]); // apply the image directions\n\n    var i2wmat4 = model.currentInput.getIndexToWorld();\n    mat4.multiply(model.idxToView, model.modelToView, i2wmat4);\n    mat3.multiply(model.idxNormalMatrix, keyMats.normalMatrix, actMats.normalMatrix);\n    mat3.multiply(model.idxNormalMatrix, model.idxNormalMatrix, model.currentInput.getDirection());\n    var maxSamples = vec3.length(vsize) / model.renderable.getSampleDistance();\n\n    if (maxSamples > model.renderable.getMaximumSamplesPerRay()) {\n      vtkWarningMacro(\"The number of steps required \".concat(Math.ceil(maxSamples), \" is larger than the\\n        specified maximum number of steps \").concat(model.renderable.getMaximumSamplesPerRay(), \".\\n        Please either change the\\n        volumeMapper sampleDistance or its maximum number of samples.\"));\n    }\n\n    var vctoijk = new Float64Array(3);\n    vec3.set(vctoijk, 1.0, 1.0, 1.0);\n    vec3.divide(vctoijk, vctoijk, vsize);\n    program.setUniform3f('vVCToIJK', vctoijk[0], vctoijk[1], vctoijk[2]);\n    program.setUniform3i('volumeDimensions', dims[0], dims[1], dims[2]);\n\n    if (!model._openGLRenderWindow.getWebgl2()) {\n      var volInfo = model.scalarTexture.getVolumeInfo();\n      program.setUniformf('texWidth', model.scalarTexture.getWidth());\n      program.setUniformf('texHeight', model.scalarTexture.getHeight());\n      program.setUniformi('xreps', volInfo.xreps);\n      program.setUniformi('xstride', volInfo.xstride);\n      program.setUniformi('ystride', volInfo.ystride);\n    } // map normals through normal matrix\n    // then use a point on the plane to compute the distance\n\n\n    var normal = new Float64Array(3);\n    var pos2 = new Float64Array(3);\n\n    for (var _i = 0; _i < 6; ++_i) {\n      switch (_i) {\n        case 1:\n          vec3.set(normal, -1.0, 0.0, 0.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n\n        case 2:\n          vec3.set(normal, 0.0, 1.0, 0.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n\n        case 3:\n          vec3.set(normal, 0.0, -1.0, 0.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n\n        case 4:\n          vec3.set(normal, 0.0, 0.0, 1.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n\n        case 5:\n          vec3.set(normal, 0.0, 0.0, -1.0);\n          vec3.set(pos2, ext[0], ext[2], ext[4]);\n          break;\n\n        case 0:\n        default:\n          vec3.set(normal, 1.0, 0.0, 0.0);\n          vec3.set(pos2, ext[1], ext[3], ext[5]);\n          break;\n      }\n\n      vec3.transformMat3(normal, normal, model.idxNormalMatrix);\n      vec3.transformMat4(pos2, pos2, model.idxToView);\n      var dist = -1.0 * vec3.dot(pos2, normal); // we have the plane in view coordinates\n      // specify the planes in view coordinates\n\n      program.setUniform3f(\"vPlaneNormal\".concat(_i), normal[0], normal[1], normal[2]);\n      program.setUniformf(\"vPlaneDistance\".concat(_i), dist);\n    }\n\n    if (actor.getProperty().getUseLabelOutline()) {\n      var image = model.currentInput;\n      var worldToIndex = image.getWorldToIndex();\n      program.setUniformMatrix('vWCtoIDX', worldToIndex); // Get the projection coordinate to world coordinate transformation matrix.\n\n      mat4.invert(model.projectionToWorld, keyMats.wcpc);\n      program.setUniformMatrix('PCWCMatrix', model.projectionToWorld);\n      var size = publicAPI.getRenderTargetSize();\n      program.setUniformf('vpWidth', size[0]);\n      program.setUniformf('vpHeight', size[1]);\n      var offset = publicAPI.getRenderTargetOffset();\n      program.setUniformf('vpOffsetX', offset[0] / size[0]);\n      program.setUniformf('vpOffsetY', offset[1] / size[1]);\n    }\n\n    mat4.invert(model.projectionToView, keyMats.vcpc);\n    program.setUniformMatrix('PCVCMatrix', model.projectionToView); // handle lighting values\n\n    if (model.lastLightComplexity === 0) {\n      return;\n    }\n\n    var lightNum = 0;\n    var lightColor = [];\n    var lightDir = [];\n    var halfAngle = [];\n    ren.getLights().forEach(function (light) {\n      var status = light.getSwitch();\n\n      if (status > 0) {\n        var dColor = light.getColor();\n        var intensity = light.getIntensity();\n        lightColor[0 + lightNum * 3] = dColor[0] * intensity;\n        lightColor[1 + lightNum * 3] = dColor[1] * intensity;\n        lightColor[2 + lightNum * 3] = dColor[2] * intensity;\n        var ldir = light.getDirection();\n        vec3.set(normal, ldir[0], ldir[1], ldir[2]);\n        vec3.transformMat3(normal, normal, keyMats.normalMatrix); // in view coordinat\n\n        vec3.normalize(normal, normal);\n        lightDir[0 + lightNum * 3] = normal[0];\n        lightDir[1 + lightNum * 3] = normal[1];\n        lightDir[2 + lightNum * 3] = normal[2]; // camera DOP is 0,0,-1.0 in VC\n\n        halfAngle[0 + lightNum * 3] = -0.5 * normal[0];\n        halfAngle[1 + lightNum * 3] = -0.5 * normal[1];\n        halfAngle[2 + lightNum * 3] = -0.5 * (normal[2] - 1.0);\n        lightNum++;\n      }\n    });\n    program.setUniformi('twoSidedLighting', ren.getTwoSidedLighting());\n    program.setUniformi('lightNum', lightNum);\n    program.setUniform3fv('lightColor', lightColor);\n    program.setUniform3fv('lightDirectionVC', lightDir);\n    program.setUniform3fv('lightHalfAngleVC', halfAngle);\n\n    if (model.lastLightComplexity === 3) {\n      lightNum = 0;\n      var lightPositionVC = [];\n      var lightAttenuation = [];\n      var lightConeAngle = [];\n      var lightExponent = [];\n      var lightPositional = [];\n      ren.getLights().forEach(function (light) {\n        var status = light.getSwitch();\n\n        if (status > 0) {\n          var attenuation = light.getAttenuationValues();\n          lightAttenuation[0 + lightNum * 3] = attenuation[0];\n          lightAttenuation[1 + lightNum * 3] = attenuation[1];\n          lightAttenuation[2 + lightNum * 3] = attenuation[2];\n          lightExponent[lightNum] = light.getExponent();\n          lightConeAngle[lightNum] = light.getConeAngle();\n          lightPositional[lightNum] = light.getPositional();\n          var lp = light.getTransformedPosition();\n          vec3.transformMat4(lp, lp, model.modelToView);\n          lightPositionVC[0 + lightNum * 3] = lp[0];\n          lightPositionVC[1 + lightNum * 3] = lp[1];\n          lightPositionVC[2 + lightNum * 3] = lp[2];\n          lightNum += 1;\n        }\n      });\n      program.setUniform3fv('lightPositionVC', lightPositionVC);\n      program.setUniform3fv('lightAttenuation', lightAttenuation);\n      program.setUniformfv('lightConeAngle', lightConeAngle);\n      program.setUniformfv('lightExponent', lightExponent);\n      program.setUniformiv('lightPositional', lightPositional);\n    }\n\n    if (model.renderable.getVolumetricScatteringBlending() > 0.0) {\n      program.setUniformf('giReach', model.renderable.getGlobalIlluminationReach());\n      program.setUniformf('volumetricScatteringBlending', model.renderable.getVolumetricScatteringBlending());\n      program.setUniformf('volumeShadowSamplingDistFactor', model.renderable.getVolumeShadowSamplingDistFactor());\n      program.setUniformf('anisotropy', model.renderable.getAnisotropy());\n      program.setUniformf('anisotropy2', Math.pow(model.renderable.getAnisotropy(), 2.0));\n    }\n\n    if (model.renderable.getVolumetricScatteringBlending() === 0.0 && model.renderable.getLocalAmbientOcclusion() && actor.getProperty().getAmbient() > 0.0) {\n      var ks = model.renderable.getLAOKernelSize();\n      program.setUniformi('kernelSize', ks);\n      var kernelSample = [];\n\n      for (var _i2 = 0; _i2 < ks; _i2++) {\n        kernelSample[_i2 * 2] = Math.random() * 0.5;\n        kernelSample[_i2 * 2 + 1] = Math.random() * 0.5;\n      }\n\n      program.setUniform2fv('kernelSample', kernelSample);\n      program.setUniformi('kernelRadius', model.renderable.getLAOKernelRadius());\n    }\n  };\n\n  publicAPI.setPropertyShaderParameters = function (cellBO, ren, actor) {\n    var program = cellBO.getProgram();\n    program.setUniformi('ctexture', model.colorTexture.getTextureUnit());\n    program.setUniformi('otexture', model.opacityTexture.getTextureUnit());\n    program.setUniformi('jtexture', model.jitterTexture.getTextureUnit());\n    var volInfo = model.scalarTexture.getVolumeInfo();\n    var vprop = actor.getProperty(); // set the component mix when independent\n\n    var numComp = model.scalarTexture.getComponents();\n    var iComps = actor.getProperty().getIndependentComponents();\n\n    if (iComps && numComp >= 2) {\n      for (var i = 0; i < numComp; i++) {\n        program.setUniformf(\"mix\".concat(i), actor.getProperty().getComponentWeight(i));\n      }\n    } // three levels of shift scale combined into one\n    // for performance in the fragment shader\n\n\n    for (var _i3 = 0; _i3 < numComp; _i3++) {\n      var target = iComps ? _i3 : 0;\n      var sscale = volInfo.scale[_i3];\n      var ofun = vprop.getScalarOpacity(target);\n      var oRange = ofun.getRange();\n      var oscale = sscale / (oRange[1] - oRange[0]);\n      var oshift = (volInfo.offset[_i3] - oRange[0]) / (oRange[1] - oRange[0]);\n      program.setUniformf(\"oshift\".concat(_i3), oshift);\n      program.setUniformf(\"oscale\".concat(_i3), oscale);\n      var cfun = vprop.getRGBTransferFunction(target);\n      var cRange = cfun.getRange();\n      program.setUniformf(\"cshift\".concat(_i3), (volInfo.offset[_i3] - cRange[0]) / (cRange[1] - cRange[0]));\n      program.setUniformf(\"cscale\".concat(_i3), sscale / (cRange[1] - cRange[0]));\n    }\n\n    if (model.gopacity) {\n      if (iComps) {\n        for (var nc = 0; nc < numComp; ++nc) {\n          var _sscale = volInfo.scale[nc];\n          var useGO = vprop.getUseGradientOpacity(nc);\n\n          if (useGO) {\n            var gomin = vprop.getGradientOpacityMinimumOpacity(nc);\n            var gomax = vprop.getGradientOpacityMaximumOpacity(nc);\n            program.setUniformf(\"gomin\".concat(nc), gomin);\n            program.setUniformf(\"gomax\".concat(nc), gomax);\n            var goRange = [vprop.getGradientOpacityMinimumValue(nc), vprop.getGradientOpacityMaximumValue(nc)];\n            program.setUniformf(\"goscale\".concat(nc), _sscale * (gomax - gomin) / (goRange[1] - goRange[0]));\n            program.setUniformf(\"goshift\".concat(nc), -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);\n          } else {\n            program.setUniformf(\"gomin\".concat(nc), 1.0);\n            program.setUniformf(\"gomax\".concat(nc), 1.0);\n            program.setUniformf(\"goscale\".concat(nc), 0.0);\n            program.setUniformf(\"goshift\".concat(nc), 1.0);\n          }\n        }\n      } else {\n        var _sscale2 = volInfo.scale[numComp - 1];\n\n        var _gomin = vprop.getGradientOpacityMinimumOpacity(0);\n\n        var _gomax = vprop.getGradientOpacityMaximumOpacity(0);\n\n        program.setUniformf('gomin0', _gomin);\n        program.setUniformf('gomax0', _gomax);\n        var _goRange = [vprop.getGradientOpacityMinimumValue(0), vprop.getGradientOpacityMaximumValue(0)];\n        program.setUniformf('goscale0', _sscale2 * (_gomax - _gomin) / (_goRange[1] - _goRange[0]));\n        program.setUniformf('goshift0', -_goRange[0] * (_gomax - _gomin) / (_goRange[1] - _goRange[0]) + _gomin);\n      }\n    }\n\n    var vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();\n\n    if (vtkImageLabelOutline === true) {\n      var labelOutlineThickness = actor.getProperty().getLabelOutlineThickness();\n      program.setUniformi('outlineThickness', labelOutlineThickness);\n    }\n\n    if (model.lastLightComplexity > 0) {\n      program.setUniformf('vAmbient', vprop.getAmbient());\n      program.setUniformf('vDiffuse', vprop.getDiffuse());\n      program.setUniformf('vSpecular', vprop.getSpecular());\n      program.setUniformf('vSpecularPower', vprop.getSpecularPower());\n    }\n  };\n\n  publicAPI.getClippingPlaneShaderParameters = function (cellBO, ren, actor) {\n    if (model.renderable.getClippingPlanes().length > 0) {\n      var keyMats = model.openGLCamera.getKeyMatrices(ren);\n      var clipPlaneNormals = [];\n      var clipPlaneDistances = [];\n      var clipPlanes = model.renderable.getClippingPlanes();\n      var clipPlaneSize = clipPlanes.length;\n\n      for (var i = 0; i < clipPlaneSize; ++i) {\n        var clipPlaneNormal = clipPlanes[i].getNormal();\n        var clipPlanePos = clipPlanes[i].getOrigin();\n        vec3.transformMat3(clipPlaneNormal, clipPlaneNormal, keyMats.normalMatrix);\n        vec3.transformMat4(clipPlanePos, clipPlanePos, keyMats.wcvc);\n        var clipPlaneDist = -1.0 * vec3.dot(clipPlanePos, clipPlaneNormal);\n        clipPlaneNormals.push(clipPlaneNormal[0]);\n        clipPlaneNormals.push(clipPlaneNormal[1]);\n        clipPlaneNormals.push(clipPlaneNormal[2]);\n        clipPlaneDistances.push(clipPlaneDist);\n      }\n\n      var program = cellBO.getProgram();\n      program.setUniform3fv(\"vClipPlaneNormals\", clipPlaneNormals);\n      program.setUniformfv(\"vClipPlaneDistances\", clipPlaneDistances);\n    }\n  }; // unsubscribe from our listeners\n\n\n  publicAPI.delete = chain(function () {\n    if (model._animationRateSubscription) {\n      model._animationRateSubscription.unsubscribe();\n\n      model._animationRateSubscription = null;\n    }\n  }, publicAPI.delete);\n\n  publicAPI.getRenderTargetSize = function () {\n    if (model._useSmallViewport) {\n      return [model._smallViewportWidth, model._smallViewportHeight];\n    }\n\n    var _model$openGLRenderer = model.openGLRenderer.getTiledSizeAndOrigin(),\n        usize = _model$openGLRenderer.usize,\n        vsize = _model$openGLRenderer.vsize;\n\n    return [usize, vsize];\n  };\n\n  publicAPI.getRenderTargetOffset = function () {\n    var _model$openGLRenderer2 = model.openGLRenderer.getTiledSizeAndOrigin(),\n        lowerLeftU = _model$openGLRenderer2.lowerLeftU,\n        lowerLeftV = _model$openGLRenderer2.lowerLeftV;\n\n    return [lowerLeftU, lowerLeftV];\n  };\n\n  publicAPI.renderPieceStart = function (ren, actor) {\n    var rwi = ren.getVTKWindow().getInteractor();\n    model._useSmallViewport = false;\n\n    if (rwi.isAnimating() && model._lastScale > 1.5) {\n      model._useSmallViewport = true;\n    }\n\n    if (!model._animationRateSubscription) {\n      // when the animation frame rate changes recompute the scale factor\n      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(function () {\n        if (model.renderable.getAutoAdjustSampleDistances()) {\n          var frate = rwi.getRecentAnimationFrameRate();\n          var adjustment = rwi.getDesiredUpdateRate() / frate; // only change if we are off by 15%\n\n          if (adjustment > 1.15 || adjustment < 0.85) {\n            model._lastScale *= adjustment;\n          } // clamp scale to some reasonable values.\n          // Below 1.5 we will just be using full resolution as that is close enough\n          // Above 400 seems like a lot so we limit to that 1/20th per axis\n\n\n          if (model._lastScale > 400) {\n            model._lastScale = 400;\n          }\n\n          if (model._lastScale < 1.5) {\n            model._lastScale = 1.5;\n          }\n        } else {\n          model._lastScale = model.renderable.getImageSampleDistance() * model.renderable.getImageSampleDistance();\n        }\n\n        var size = model._openGLRenderWindow.getFramebufferSize();\n\n        model._smallViewportWidth = Math.ceil(size[0] / Math.sqrt(model._lastScale));\n        model._smallViewportHeight = Math.ceil(size[1] / Math.sqrt(model._lastScale));\n      });\n    } // use/create/resize framebuffer if needed\n\n\n    if (model._useSmallViewport) {\n      var size = model._openGLRenderWindow.getFramebufferSize(); // adjust viewportSize to always be at most the dest fo size\n\n\n      if (model._smallViewportHeight > size[1]) {\n        model._smallViewportHeight = size[1];\n      }\n\n      if (model._smallViewportWidth > size[0]) {\n        model._smallViewportWidth = size[0];\n      }\n\n      model.framebuffer.saveCurrentBindingsAndBuffers();\n\n      if (model.framebuffer.getGLFramebuffer() === null) {\n        model.framebuffer.create(size[0], size[1]);\n        model.framebuffer.populateFramebuffer();\n      } else {\n        var fbSize = model.framebuffer.getSize();\n\n        if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {\n          model.framebuffer.create(size[0], size[1]);\n          model.framebuffer.populateFramebuffer();\n        }\n      }\n\n      model.framebuffer.bind();\n      var gl = model.context;\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      gl.colorMask(true, true, true, true);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      gl.viewport(0, 0, model._smallViewportWidth, model._smallViewportHeight);\n      model.fvp = [model._smallViewportWidth / size[0], model._smallViewportHeight / size[1]];\n    }\n\n    model.context.disable(model.context.DEPTH_TEST); // make sure the BOs are up to date\n\n    publicAPI.updateBufferObjects(ren, actor); // set interpolation on the texture based on property setting\n\n    var iType = actor.getProperty().getInterpolationType();\n\n    if (iType === InterpolationType.NEAREST) {\n      model.scalarTexture.setMinificationFilter(Filter.NEAREST);\n      model.scalarTexture.setMagnificationFilter(Filter.NEAREST);\n    } else {\n      model.scalarTexture.setMinificationFilter(Filter.LINEAR);\n      model.scalarTexture.setMagnificationFilter(Filter.LINEAR);\n    } // Bind the OpenGL, this is shared between the different primitive/cell types.\n\n\n    model.lastBoundBO = null; // if we have a zbuffer texture then activate it\n\n    if (model.zBufferTexture !== null) {\n      model.zBufferTexture.activate();\n    }\n  };\n\n  publicAPI.renderPieceDraw = function (ren, actor) {\n    var gl = model.context; // render the texture\n\n    model.scalarTexture.activate();\n    model.opacityTexture.activate();\n    model.colorTexture.activate();\n    model.jitterTexture.activate();\n    publicAPI.updateShaders(model.tris, ren, actor); // First we do the triangles, update the shader, set uniforms, etc.\n    // for (let i = 0; i < 11; ++i) {\n    //   gl.drawArrays(gl.TRIANGLES, 66 * i, 66);\n    // }\n\n    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n    model.tris.getVAO().release();\n    model.scalarTexture.deactivate();\n    model.colorTexture.deactivate();\n    model.opacityTexture.deactivate();\n    model.jitterTexture.deactivate();\n  };\n\n  publicAPI.renderPieceFinish = function (ren, actor) {\n    // if we have a zbuffer texture then deactivate it\n    if (model.zBufferTexture !== null) {\n      model.zBufferTexture.deactivate();\n    }\n\n    if (model._useSmallViewport) {\n      // now copy the framebuffer with the volume into the\n      // regular buffer\n      model.framebuffer.restorePreviousBindingsAndBuffers();\n\n      if (model.copyShader === null) {\n        model.copyShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(['//VTK::System::Dec', 'attribute vec4 vertexDC;', 'uniform vec2 tfactor;', 'varying vec2 tcoord;', 'void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }'].join('\\n'), ['//VTK::System::Dec', '//VTK::Output::Dec', 'uniform sampler2D texture1;', 'varying vec2 tcoord;', 'void main() { gl_FragData[0] = texture2D(texture1,tcoord); }'].join('\\n'), '');\n        var program = model.copyShader;\n        model.copyVAO = vtkVertexArrayObject.newInstance();\n        model.copyVAO.setOpenGLRenderWindow(model._openGLRenderWindow);\n        model.tris.getCABO().bind();\n\n        if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'vertexDC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {\n          vtkErrorMacro('Error setting vertexDC in copy shader VAO.');\n        }\n      } else {\n        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.copyShader);\n      }\n\n      var size = model._openGLRenderWindow.getFramebufferSize();\n\n      model.context.viewport(0, 0, size[0], size[1]); // activate texture\n\n      var tex = model.framebuffer.getColorTexture();\n      tex.activate();\n      model.copyShader.setUniformi('texture', tex.getTextureUnit());\n      model.copyShader.setUniform2f('tfactor', model.fvp[0], model.fvp[1]);\n      var gl = model.context;\n      gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // render quad\n\n      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());\n      tex.deactivate();\n      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    }\n  };\n\n  publicAPI.renderPiece = function (ren, actor) {\n    publicAPI.invokeEvent({\n      type: 'StartEvent'\n    });\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent({\n      type: 'EndEvent'\n    });\n\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n\n  publicAPI.computeBounds = function (ren, actor) {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.Bounds);\n      return;\n    }\n\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n\n  publicAPI.updateBufferObjects = function (ren, actor) {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n  };\n\n  publicAPI.getNeedToRebuildBufferObjects = function (ren, actor) {\n    // first do a coarse check\n    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {\n      return true;\n    }\n\n    return false;\n  };\n\n  publicAPI.buildBufferObjects = function (ren, actor) {\n    var image = model.currentInput;\n\n    if (!image) {\n      return;\n    }\n\n    var scalars = image.getPointData() && image.getPointData().getScalars();\n\n    if (!scalars) {\n      return;\n    }\n\n    var vprop = actor.getProperty();\n\n    if (!model.jitterTexture.getHandle()) {\n      var oTable = new Uint8Array(32 * 32);\n\n      for (var i = 0; i < 32 * 32; ++i) {\n        oTable[i] = 255.0 * Math.random();\n      }\n\n      model.jitterTexture.setMinificationFilter(Filter.LINEAR);\n      model.jitterTexture.setMagnificationFilter(Filter.LINEAR);\n      model.jitterTexture.create2DFromRaw(32, 32, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);\n    }\n\n    var numComp = scalars.getNumberOfComponents();\n    var iComps = vprop.getIndependentComponents();\n    var numIComps = iComps ? numComp : 1; // rebuild opacity tfun?\n\n    var toString = \"\".concat(vprop.getMTime());\n\n    if (model.opacityTextureString !== toString) {\n      var oWidth = 1024;\n      var oSize = oWidth * 2 * numIComps;\n      var ofTable = new Float32Array(oSize);\n      var tmpTable = new Float32Array(oWidth);\n\n      for (var c = 0; c < numIComps; ++c) {\n        var ofun = vprop.getScalarOpacity(c);\n        var opacityFactor = model.renderable.getSampleDistance() / vprop.getScalarOpacityUnitDistance(c);\n        var oRange = ofun.getRange();\n        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1); // adjust for sample distance etc\n\n        for (var _i4 = 0; _i4 < oWidth; ++_i4) {\n          ofTable[c * oWidth * 2 + _i4] = 1.0 - Math.pow(1.0 - tmpTable[_i4], opacityFactor);\n          ofTable[c * oWidth * 2 + _i4 + oWidth] = ofTable[c * oWidth * 2 + _i4];\n        }\n      }\n\n      model.opacityTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.opacityTexture.setMinificationFilter(Filter.LINEAR);\n      model.opacityTexture.setMagnificationFilter(Filter.LINEAR); // use float texture where possible because we really need the resolution\n      // for this table. Errors in low values of opacity accumulate to\n      // visible artifacts. High values of opacity quickly terminate without\n      // artifacts.\n\n      if (model._openGLRenderWindow.getWebgl2() || model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.FLOAT, ofTable);\n      } else {\n        var _oTable = new Uint8Array(oSize);\n\n        for (var _i5 = 0; _i5 < oSize; ++_i5) {\n          _oTable[_i5] = 255.0 * ofTable[_i5];\n        }\n\n        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.UNSIGNED_CHAR, _oTable);\n      }\n\n      model.opacityTextureString = toString;\n    } // rebuild color tfun?\n\n\n    toString = \"\".concat(vprop.getMTime());\n\n    if (model.colorTextureString !== toString) {\n      var cWidth = 1024;\n      var cSize = cWidth * 2 * numIComps * 3;\n      var cTable = new Uint8Array(cSize);\n\n      var _tmpTable = new Float32Array(cWidth * 3);\n\n      for (var _c = 0; _c < numIComps; ++_c) {\n        var cfun = vprop.getRGBTransferFunction(_c);\n        var cRange = cfun.getRange();\n        cfun.getTable(cRange[0], cRange[1], cWidth, _tmpTable, 1);\n\n        for (var _i6 = 0; _i6 < cWidth * 3; ++_i6) {\n          cTable[_c * cWidth * 6 + _i6] = 255.0 * _tmpTable[_i6];\n          cTable[_c * cWidth * 6 + _i6 + cWidth * 3] = 255.0 * _tmpTable[_i6];\n        }\n      }\n\n      model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.colorTexture.setMinificationFilter(Filter.LINEAR);\n      model.colorTexture.setMagnificationFilter(Filter.LINEAR);\n      model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);\n      model.colorTextureString = toString;\n    } // rebuild the scalarTexture if the data has changed\n\n\n    toString = \"\".concat(image.getMTime());\n\n    if (model.scalarTextureString !== toString) {\n      // Build the textures\n      var dims = image.getDimensions();\n      model.scalarTexture.releaseGraphicsResources(model._openGLRenderWindow);\n      model.scalarTexture.resetFormatAndType();\n      model.scalarTexture.create3DFilterableFromRaw(dims[0], dims[1], dims[2], numComp, scalars.getDataType(), scalars.getData(), model.renderable.getPreferSizeOverAccuracy());\n      model.scalarTextureString = toString;\n    }\n\n    if (!model.tris.getCABO().getElementCount()) {\n      // build the CABO\n      var ptsArray = new Float32Array(12);\n\n      for (var _i7 = 0; _i7 < 4; _i7++) {\n        ptsArray[_i7 * 3] = _i7 % 2 * 2 - 1.0;\n        ptsArray[_i7 * 3 + 1] = _i7 > 1 ? 1.0 : -1.0;\n        ptsArray[_i7 * 3 + 2] = -1.0;\n      }\n\n      var cellArray = new Uint16Array(8);\n      cellArray[0] = 3;\n      cellArray[1] = 0;\n      cellArray[2] = 1;\n      cellArray[3] = 3;\n      cellArray[4] = 3;\n      cellArray[5] = 0;\n      cellArray[6] = 3;\n      cellArray[7] = 2; // const dim = 12.0;\n      // const ptsArray = new Float32Array(3 * dim * dim);\n      // for (let i = 0; i < dim; i++) {\n      //   for (let j = 0; j < dim; j++) {\n      //     const offset = ((i * dim) + j) * 3;\n      //     ptsArray[offset] = (2.0 * (i / (dim - 1.0))) - 1.0;\n      //     ptsArray[offset + 1] = (2.0 * (j / (dim - 1.0))) - 1.0;\n      //     ptsArray[offset + 2] = -1.0;\n      //   }\n      // }\n      // const cellArray = new Uint16Array(8 * (dim - 1) * (dim - 1));\n      // for (let i = 0; i < dim - 1; i++) {\n      //   for (let j = 0; j < dim - 1; j++) {\n      //     const offset = 8 * ((i * (dim - 1)) + j);\n      //     cellArray[offset] = 3;\n      //     cellArray[offset + 1] = (i * dim) + j;\n      //     cellArray[offset + 2] = (i * dim) + 1 + j;\n      //     cellArray[offset + 3] = ((i + 1) * dim) + 1 + j;\n      //     cellArray[offset + 4] = 3;\n      //     cellArray[offset + 5] = (i * dim) + j;\n      //     cellArray[offset + 6] = ((i + 1) * dim) + 1 + j;\n      //     cellArray[offset + 7] = ((i + 1) * dim) + j;\n      //   }\n      // }\n\n      var points = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: ptsArray\n      });\n      points.setName('points');\n      var cells = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: cellArray\n      });\n      model.tris.getCABO().createVBO(cells, 'polys', Representation.SURFACE, {\n        points: points,\n        cellOffset: 0\n      });\n    }\n\n    model.VBOBuildTime.modified();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  context: null,\n  VBOBuildTime: null,\n  scalarTexture: null,\n  scalarTextureString: null,\n  opacityTexture: null,\n  opacityTextureString: null,\n  colorTexture: null,\n  colorTextureString: null,\n  jitterTexture: null,\n  tris: null,\n  framebuffer: null,\n  copyShader: null,\n  copyVAO: null,\n  lastXYF: 1.0,\n  targetXYF: 1.0,\n  zBufferTexture: null,\n  lastZBufferTexture: null,\n  lastLightComplexity: 0,\n  fullViewportTime: 1.0,\n  idxToView: null,\n  idxNormalMatrix: null,\n  modelToView: null,\n  projectionToView: null,\n  avgWindowArea: 0.0,\n  avgFrameTime: 0.0\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n  model.tris = vtkHelper.newInstance();\n  model.scalarTexture = vtkOpenGLTexture.newInstance();\n  model.opacityTexture = vtkOpenGLTexture.newInstance();\n  model.colorTexture = vtkOpenGLTexture.newInstance();\n  model.jitterTexture = vtkOpenGLTexture.newInstance();\n  model.jitterTexture.setWrapS(Wrap.REPEAT);\n  model.jitterTexture.setWrapT(Wrap.REPEAT);\n  model.framebuffer = vtkOpenGLFramebuffer.newInstance();\n  model.idxToView = mat4.identity(new Float64Array(16));\n  model.idxNormalMatrix = mat3.identity(new Float64Array(9));\n  model.modelToView = mat4.identity(new Float64Array(16));\n  model.projectionToView = mat4.identity(new Float64Array(16));\n  model.projectionToWorld = mat4.identity(new Float64Array(16));\n  model._lastScale = 1.0; // Build VTK API\n\n  setGet(publicAPI, model, ['context']); // Object methods\n\n  vtkOpenGLVolumeMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkOpenGLVolumeMapper'); // ----------------------------------------------------------------------------\n\nvar vtkVolumeMapper = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to OpenGL backend if imported\n\nregisterOverride('vtkVolumeMapper', newInstance);\n\nexport { vtkVolumeMapper as default, extend, newInstance };\n", "import { mat4, vec4 } from 'gl-matrix';\nimport Constants from '../Core/ImageMapper/Constants.js';\nimport { newInstance as newInstance$1, obj } from '../../macros.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUFullScreenQuad from './FullScreenQuad.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUSampler from './Sampler.js';\nimport { InterpolationType } from '../Core/ImageProperty/Constants.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nvar SlicingMode = Constants.SlicingMode;\nvar imgFragTemplate = \"\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Image::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  //VTK::Image::Sample\\n\\n  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);\\n\\n//VTK::RenderEncoder::Impl\\n\\n  return output;\\n}\\n\"; // ----------------------------------------------------------------------------\n// helper methods\n// ----------------------------------------------------------------------------\n\nfunction computeFnToString(property, fn, numberOfComponents) {\n  var pwfun = fn.apply(property);\n\n  if (pwfun) {\n    var iComps = property.getIndependentComponents();\n    return \"\".concat(property.getMTime(), \"-\").concat(iComps, \"-\").concat(numberOfComponents);\n  }\n\n  return '0';\n} // ----------------------------------------------------------------------------\n// vtkWebGPUImageMapper methods\n// ----------------------------------------------------------------------------\n\n\nvar tmpMat4 = new Float64Array(16);\nvar tmp2Mat4 = new Float64Array(16);\nvar tmp3Mat4 = new Float64Array(16);\nvar ptsArray1 = new Float64Array(4);\nvar ptsArray2 = new Float64Array(4);\n\nfunction vtkWebGPUImageMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUImageMapper');\n\n  publicAPI.buildPass = function (prepass) {\n    if (prepass) {\n      model.WebGPUImageSlice = publicAPI.getFirstAncestorOfType('vtkWebGPUImageSlice');\n      model.WebGPURenderer = model.WebGPUImageSlice.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getParent();\n      model.device = model.WebGPURenderWindow.getDevice();\n      var ren = model.WebGPURenderer.getRenderable(); // is slice set by the camera\n\n      if (model.renderable.getSliceAtFocalPoint()) {\n        model.renderable.setSliceFromCamera(ren.getActiveCamera());\n      }\n    }\n  }; // Renders myself\n\n\n  publicAPI.translucentPass = function (prepass) {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.opaquePass = function (prepass) {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n\n  publicAPI.render = function () {\n    model.renderable.update();\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());\n    model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);\n  };\n\n  publicAPI.computePipelineHash = function () {\n    var ext = model.currentInput.getExtent();\n\n    if (ext[0] === ext[1] || ext[2] === ext[3] || ext[4] === ext[5]) {\n      model.dimensions = 2;\n      model.pipelineHash = 'img2';\n    } else {\n      model.dimensions = 3;\n      model.pipelineHash = 'img3';\n    }\n  };\n\n  publicAPI.updateUBO = function () {\n    var utime = model.UBO.getSendTime();\n    var actor = model.WebGPUImageSlice.getRenderable();\n    var volMapr = actor.getMapper();\n\n    if (publicAPI.getMTime() > utime || model.renderable.getMTime() > utime || actor.getProperty().getMTime() > utime) {\n      // compute the SCTCMatrix\n      var image = volMapr.getInputData();\n      var center = model.WebGPURenderer.getStabilizedCenterByReference();\n      mat4.identity(tmpMat4);\n      mat4.translate(tmpMat4, tmpMat4, center); // tmpMat4 is now SC->World\n\n      var mcwcmat = actor.getMatrix();\n      mat4.transpose(tmp2Mat4, mcwcmat);\n      mat4.invert(tmp2Mat4, tmp2Mat4); // tmp2Mat4 is now world to model\n\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4); // tmp4Mat is now SC->Model\n      // the method on the data is world to index but the volume is in\n      // model coordinates so really in this context it is model to index\n\n      var modelToIndex = image.getWorldToIndex();\n      mat4.multiply(tmpMat4, modelToIndex, tmpMat4); // tmpMat4 is now SC -> Index, save this as we need it later\n\n      mat4.invert(tmp3Mat4, tmpMat4); // need translation and scale\n\n      mat4.fromTranslation(tmp2Mat4, [0.5, 0.5, 0.5]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      var dims = image.getDimensions();\n      mat4.identity(tmp2Mat4);\n      mat4.scale(tmp2Mat4, tmp2Mat4, [1.0 / dims[0], 1.0 / dims[1], 1.0 / dims[2]]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4); // tmpMat4 is now SC -> Tcoord\n\n      model.UBO.setArray('SCTCMatrix', tmpMat4); // need to compute the plane here in world coordinates\n      // then pass that down in the UBO\n\n      var ext = model.currentInput.getExtent(); // Find what IJK axis and what direction to slice along\n\n      var _model$renderable$get = model.renderable.getClosestIJKAxis(),\n          ijkMode = _model$renderable$get.ijkMode; // Find the IJK slice\n\n\n      var nSlice = model.renderable.getSlice();\n\n      if (ijkMode !== model.renderable.getSlicingMode()) {\n        // If not IJK slicing, get the IJK slice from the XYZ position/slice\n        nSlice = model.renderable.getSliceAtPosition(nSlice);\n      }\n\n      var axis0 = 2;\n      var axis1 = 0;\n      var axis2 = 1;\n\n      if (ijkMode === SlicingMode.I) {\n        axis0 = 0;\n        axis1 = 1;\n        axis2 = 2;\n      } else if (ijkMode === SlicingMode.J) {\n        axis0 = 1;\n        axis1 = 2;\n        axis2 = 0;\n      }\n\n      ptsArray1[axis0] = nSlice;\n      ptsArray1[axis1] = ext[axis1 * 2] - 0.5;\n      ptsArray1[axis2] = ext[axis2 * 2] - 0.5;\n      ptsArray1[3] = 1.0;\n      vec4.transformMat4(ptsArray1, ptsArray1, tmp3Mat4);\n      model.UBO.setArray('Origin', ptsArray1);\n      ptsArray2[axis0] = nSlice;\n      ptsArray2[axis1] = ext[axis1 * 2 + 1] + 0.5;\n      ptsArray2[axis2] = ext[axis2 * 2] - 0.5;\n      ptsArray2[3] = 1.0;\n      vec4.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);\n      vec4.subtract(ptsArray2, ptsArray2, ptsArray1);\n      ptsArray2[3] = 1.0;\n      model.UBO.setArray('Axis1', ptsArray2);\n      ptsArray2[axis0] = nSlice;\n      ptsArray2[axis1] = ext[axis1 * 2] - 0.5;\n      ptsArray2[axis2] = ext[axis2 * 2 + 1] + 0.5;\n      ptsArray2[3] = 1.0;\n      vec4.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);\n      vec4.subtract(ptsArray2, ptsArray2, ptsArray1);\n      ptsArray2[3] = 1.0;\n      model.UBO.setArray('Axis2', ptsArray2); // three levels of shift scale combined into one\n      // for performance in the fragment shader\n\n      var cScale = [1, 1, 1, 1];\n      var cShift = [0, 0, 0, 0];\n      var tView = model.textureViews[0];\n      var tScale = tView.getTexture().getScale();\n      var numComp = tView.getTexture().getNumberOfComponents();\n      var iComps = false; // todo handle independent?\n\n      for (var i = 0; i < numComp; i++) {\n        var cw = actor.getProperty().getColorWindow();\n        var cl = actor.getProperty().getColorLevel();\n        var target = iComps ? i : 0;\n        var cfun = actor.getProperty().getRGBTransferFunction(target);\n\n        if (cfun) {\n          var cRange = cfun.getRange();\n          cw = cRange[1] - cRange[0];\n          cl = 0.5 * (cRange[1] + cRange[0]);\n        }\n\n        cScale[i] = tScale / cw;\n        cShift[i] = -cl / cw + 0.5;\n      }\n\n      model.UBO.setArray('cScale', cScale);\n      model.UBO.setArray('cShift', cShift);\n      model.UBO.sendIfNeeded(model.device);\n    }\n  };\n\n  publicAPI.updateLUTImage = function () {\n    var actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();\n    var tView = publicAPI.getTextureViews()[0];\n    tView.getTexture().getNumberOfComponents();\n\n    var numIComps = 1;\n    var cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);\n\n    if (model.colorTextureString !== cfunToString) {\n      model.numRows = numIComps;\n      var colorArray = new Uint8Array(model.numRows * 2 * model.rowLength * 4);\n      var cfun = actorProperty.getRGBTransferFunction();\n\n      if (cfun) {\n        var tmpTable = new Float32Array(model.rowLength * 3);\n\n        for (var c = 0; c < numIComps; c++) {\n          cfun = actorProperty.getRGBTransferFunction(c);\n          var cRange = cfun.getRange();\n          cfun.getTable(cRange[0], cRange[1], model.rowLength, tmpTable, 1);\n\n          {\n            for (var _i = 0; _i < model.rowLength; _i++) {\n              var _idx = c * model.rowLength * 8 + _i * 4;\n\n              colorArray[_idx] = 255.0 * tmpTable[_i * 3];\n              colorArray[_idx + 1] = 255.0 * tmpTable[_i * 3 + 1];\n              colorArray[_idx + 2] = 255.0 * tmpTable[_i * 3 + 2];\n              colorArray[_idx + 3] = 255.0;\n\n              for (var _j = 0; _j < 4; _j++) {\n                colorArray[_idx + model.rowLength * 4 + _j] = colorArray[_idx + _j];\n              }\n            }\n          }\n        }\n      } else {\n        for (var _i2 = 0; _i2 < model.rowLength; ++_i2) {\n          var grey = 255.0 * _i2 / (model.rowLength - 1);\n          colorArray[_i2 * 4] = grey;\n          colorArray[_i2 * 4 + 1] = grey;\n          colorArray[_i2 * 4 + 2] = grey;\n          colorArray[_i2 * 4 + 3] = 255.0;\n\n          for (var _j2 = 0; _j2 < 4; _j2++) {\n            colorArray[_i2 * 4 + model.rowLength * 4 + _j2] = colorArray[_i2 * 4 + _j2];\n          }\n        }\n      }\n\n      {\n        var treq = {\n          nativeArray: colorArray,\n          width: model.rowLength,\n          height: model.numRows * 2,\n          depth: 1,\n          format: 'rgba8unorm'\n        };\n        var newTex = model.device.getTextureManager().getTexture(treq);\n        var tview = newTex.createView('tfunTexture');\n        model.textureViews[1] = tview;\n      }\n      model.colorTextureString = cfunToString;\n    }\n  };\n\n  var superClassUpdateBuffers = publicAPI.updateBuffers;\n\n  publicAPI.updateBuffers = function () {\n    superClassUpdateBuffers();\n    var newTex = model.device.getTextureManager().getTextureForImageData(model.currentInput);\n    var tViews = model.textureViews;\n\n    if (!tViews[0] || tViews[0].getTexture() !== newTex) {\n      var tview = newTex.createView('imgTexture');\n      tViews[0] = tview;\n    }\n\n    publicAPI.updateLUTImage();\n    publicAPI.updateUBO(); // set interpolation on the texture based on property setting\n\n    var actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();\n    var iType = actorProperty.getInterpolationType() === InterpolationType.NEAREST ? 'nearest' : 'linear';\n\n    if (!model.clampSampler || iType !== model.clampSampler.getOptions().minFilter) {\n      model.clampSampler = vtkWebGPUSampler.newInstance({\n        label: 'clampSampler'\n      });\n      model.clampSampler.create(model.device, {\n        minFilter: iType,\n        magFilter: iType\n      });\n      model.additionalBindables = [model.clampSampler];\n    }\n  };\n\n  var sr = publicAPI.getShaderReplacements();\n\n  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    var code = vDesc.getCode();\n    var lines = ['var pos: vec4<f32> = mapperUBO.Origin +', '   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;', 'pos.w = 1.0;'];\n\n    if (model.dimensions === 2) {\n      lines.push('var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;');\n    } else {\n      lines.push('var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;');\n    }\n\n    lines.push('output.tcoordVS = tcoord;', 'output.Position = rendererUBO.SCPCMatrix * pos;');\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', lines).result;\n    vDesc.setCode(code);\n  };\n\n  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n\n  publicAPI.replaceShaderTCoord = function (hash, pipeline, vertexInput) {\n    var vDesc = pipeline.getShaderDescription('vertex');\n\n    if (model.dimensions === 2) {\n      vDesc.addOutput('vec2<f32>', 'tcoordVS');\n    } else {\n      vDesc.addOutput('vec3<f32>', 'tcoordVS');\n    }\n  };\n\n  sr.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);\n\n  publicAPI.replaceShaderImage = function (hash, pipeline, vertexInput) {\n    var fDesc = pipeline.getShaderDescription('fragment');\n    var code = fDesc.getCode();\n\n    if (model.dimensions === 3) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [\"    var computedColor: vec4<f32> =\", \"      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);\", \"//VTK::Image::Sample\"]).result;\n    } else {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [\"    var computedColor: vec4<f32> =\", \"      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);\", \"//VTK::Image::Sample\"]).result;\n    }\n\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Image::Sample', [\"    var coord: vec2<f32> =\", \"      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);\", \"    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\"]).result;\n    fDesc.setCode(code);\n  };\n\n  sr.set('replaceShaderImage', publicAPI.replaceShaderImage);\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  rowLength: 1024\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkWebGPUFullScreenQuad.extend(publicAPI, model, initialValues);\n  publicAPI.setFragmentShaderTemplate(imgFragTemplate);\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('SCTCMatrix', 'mat4x4<f32>');\n  model.UBO.addEntry('Origin', 'vec4<f32>');\n  model.UBO.addEntry('Axis2', 'vec4<f32>');\n  model.UBO.addEntry('Axis1', 'vec4<f32>');\n  model.UBO.addEntry('cScale', 'vec4<f32>');\n  model.UBO.addEntry('cShift', 'vec4<f32>');\n  model.lutBuildTime = {};\n  obj(model.lutBuildTime, {\n    mtime: 0\n  });\n  model.imagemat = mat4.identity(new Float64Array(16));\n  model.imagematinv = mat4.identity(new Float64Array(16));\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime); // Object methods\n\n  vtkWebGPUImageMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUImageMapper'); // ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to WebGPU backend if imported\n\nregisterOverride('vtkImageMapper', newInstance);\n\nexport { index as default, extend, newInstance };\n", "import { mat4 } from 'gl-matrix';\nimport { newInstance as newInstance$1, obj, get } from '../../macros.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// vtkWebGPUImageSlice methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUImageSlice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUImageSlice'); // Builds myself.\n\n  publicAPI.buildPass = function (prepass) {\n    if (!model.renderable || !model.renderable.getVisibility()) {\n      return;\n    }\n\n    if (prepass) {\n      if (!model.renderable) {\n        return;\n      }\n\n      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow');\n\n      if (model.propID === undefined) {\n        model.propID = model.WebGPURenderWindow.getUniquePropID();\n      }\n\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNode(model.renderable.getMapper());\n      publicAPI.removeUnusedNodes();\n    }\n  }; // we draw textures, then mapper, then post pass textures\n\n\n  publicAPI.traverseOpaquePass = function (renderPass) {\n    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n\n    publicAPI.apply(renderPass, true);\n    model.children.forEach(function (child) {\n      child.traverse(renderPass);\n    });\n    publicAPI.apply(renderPass, false);\n  };\n\n  publicAPI.traverseTranslucentPass = function (renderPass) {\n    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n\n    publicAPI.apply(renderPass, true);\n    model.children.forEach(function (child) {\n      child.traverse(renderPass);\n    });\n    publicAPI.apply(renderPass, false);\n  };\n\n  publicAPI.queryPass = function (prepass, renderPass) {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n\n      if (model.renderable.getIsOpaque()) {\n        renderPass.incrementOpaqueActorCount();\n      } else {\n        renderPass.incrementTranslucentActorCount();\n      }\n    }\n  };\n\n  publicAPI.getBufferShift = function (wgpuRen) {\n    publicAPI.getKeyMatrices(wgpuRen);\n    return model.bufferShift;\n  };\n\n  publicAPI.getKeyMatrices = function (wgpuRen) {\n    // has the actor or stabilization center changed?\n    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {\n      model.renderable.computeMatrix();\n      var mcwc = model.renderable.getMatrix(); // compute the net shift\n\n      var center = wgpuRen.getStabilizedCenterByReference();\n      model.bufferShift[0] = mcwc[3] - center[0];\n      model.bufferShift[1] = mcwc[7] - center[1];\n      model.bufferShift[2] = mcwc[11] - center[2];\n      mat4.transpose(model.keyMatrices.bcwc, mcwc);\n\n      if (model.renderable.getIsIdentity()) {\n        mat4.identity(model.keyMatrices.normalMatrix);\n      } else {\n        // we use bcwc BEFORE the translate below (just to get transposed mcvc)\n        mat4.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc); // zero out translation\n\n        model.keyMatrices.normalMatrix[3] = 0.0;\n        model.keyMatrices.normalMatrix[7] = 0.0;\n        model.keyMatrices.normalMatrix[11] = 0.0;\n        mat4.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);\n        mat4.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);\n      } // only meed the buffer shift to get to world\n\n\n      mat4.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]); // to get to stabilized we also need the center\n\n      mat4.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);\n      model.keyMatricesTime.modified();\n    }\n\n    return model.keyMatrices;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  bufferShift: undefined,\n  keyMatrixTime: null,\n  keyMatrices: null,\n  propID: undefined\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.keyMatricesTime = {};\n  obj(model.keyMatricesTime, {\n    mtime: 0\n  });\n  model.keyMatrices = {\n    normalMatrix: new Float64Array(16),\n    bcwc: new Float64Array(16),\n    bcsc: new Float64Array(16)\n  };\n  model.keyMatrixTime = {};\n  obj(model.keyMatrixTime, {\n    mtime: 0\n  });\n  model.keyMatrices = {\n    mcwc: mat4.identity(new Float64Array(16))\n  };\n  model.bufferShift = [0, 0, 0, 0];\n  get(publicAPI, model, ['propID', 'keyMatricesTime']); // Object methods\n\n  vtkWebGPUImageSlice(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = newInstance$1(extend, 'vtkWebGPUImageSlice'); // ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to WebGPU backend if imported\n\nregisterOverride('vtkImageSlice', newInstance);\n\nexport { index as default, extend, newInstance };\n", "import { mat4 } from 'gl-matrix';\nimport macro from '../../macros.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// vtkWebGPUVolume methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUVolume(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVolume'); // Builds myself.\n\n  publicAPI.buildPass = function (prepass) {\n    if (!model.renderable || !model.renderable.getVisibility()) {\n      return;\n    }\n\n    if (prepass) {\n      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');\n      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow'); // for the future if we support hardware selection of volumes\n\n      if (model.propID === undefined) {\n        model.propID = model.WebGPURenderWindow.getUniquePropID();\n      }\n\n      model.renderable.getMapper().update();\n    }\n  };\n\n  publicAPI.queryPass = function (prepass, renderPass) {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      } // Check for the special case when the mapper's bounds are unknown\n\n\n      var bds = model.renderable.getMapper().getBounds();\n\n      if (!bds || bds.length !== 6 || bds[0] > bds[1]) {\n        return;\n      }\n\n      renderPass.addVolume(publicAPI);\n    }\n  }; // used in the method below\n\n\n  var idx = new Float64Array(3);\n  var vout = new Float64Array(3);\n\n  publicAPI.getBoundingCubePoints = function (result, offset) {\n    var input = model.renderable.getMapper().getInputData();\n\n    if (!input) {\n      return;\n    }\n\n    var extent = input.getExtent();\n    var m = model.renderable.getMatrix();\n    var count = 0;\n\n    for (var iz = 4; iz < 6; iz++) {\n      idx[2] = extent[iz];\n\n      for (var iy = 2; iy < 4; iy++) {\n        idx[1] = extent[iy];\n\n        for (var ix = 0; ix < 2; ix++) {\n          idx[0] = extent[ix];\n          input.indexToWorld(idx, vout);\n          var poffset = offset + count * 3;\n          result[poffset++] = m[0] * vout[0] + m[1] * vout[1] + m[2] * vout[2] + m[3];\n          result[poffset++] = m[4] * vout[0] + m[5] * vout[1] + m[6] * vout[2] + m[7];\n          result[poffset++] = m[8] * vout[0] + m[9] * vout[1] + m[10] * vout[2] + m[11];\n          count++;\n        }\n      }\n    }\n  };\n\n  publicAPI.getKeyMatrices = function (wgpuRen) {\n    // has the actor or stabilization center changed?\n    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {\n      model.renderable.computeMatrix();\n      var mcwc = model.renderable.getMatrix(); // compute the net shift\n\n      var center = wgpuRen.getStabilizedCenterByReference();\n      mat4.transpose(model.keyMatrices.bcwc, mcwc); // to get to stabilized we also need the center\n\n      mat4.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);\n      model.keyMatricesTime.modified();\n    }\n\n    return model.keyMatrices;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  propID: undefined,\n  keyMatricesTime: null\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.keyMatricesTime = {};\n  macro.obj(model.keyMatricesTime, {\n    mtime: 0\n  });\n  model.keyMatrices = {\n    bcwc: new Float64Array(16),\n    bcsc: new Float64Array(16)\n  };\n  macro.get(publicAPI, model, ['propID', 'keyMatricesTime']); // Object methods\n\n  vtkWebGPUVolume(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkWebGPUVolume'); // ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance: newInstance,\n  extend: extend\n}; // Register ourself to WebGPU backend if imported\n\nregisterOverride('vtkVolume', newInstance);\n\nexport { index as default, extend, newInstance };\n"],
  "mappings": "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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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",
  "names": ["InterpolationType", "vtkErrorMacro", "SlicingMode", "InterpolationType", "newInstance", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "newInstance", "vtkWarningMacro", "vtkErrorMacro", "size", "DEFAULT_VALUES", "extend", "newInstance", "newInstance", "SlicingMode", "computeFnToString", "InterpolationType", "DEFAULT_VALUES", "extend", "newInstance", "registerOverride", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "registerOverride", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "registerOverride", "newInstance"]
}
