import {
  _toConsumableArray,
  macro
} from "./chunk-OTTIIP4A.js";
import {
  _defineProperty
} from "./chunk-HKWV5KNA.js";

// node_modules/@kitware/vtk.js/Rendering/Core/Texture.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtkTexture(publicAPI, model) {
  model.classHierarchy.push("vtkTexture");
  publicAPI.imageLoaded = function() {
    model.image.removeEventListener("load", publicAPI.imageLoaded);
    model.imageLoaded = true;
    publicAPI.modified();
  };
  publicAPI.setJsImageData = function(imageData) {
    if (model.jsImageData === imageData) {
      return;
    }
    if (imageData !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.image = null;
      model.canvas = null;
    }
    model.jsImageData = imageData;
    model.imageLoaded = true;
    publicAPI.modified();
  };
  publicAPI.setCanvas = function(canvas) {
    if (model.canvas === canvas) {
      return;
    }
    if (canvas !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.image = null;
      model.jsImageData = null;
    }
    model.canvas = canvas;
    publicAPI.modified();
  };
  publicAPI.setImage = function(image) {
    if (model.image === image) {
      return;
    }
    if (image !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.canvas = null;
      model.jsImageData = null;
    }
    model.image = image;
    model.imageLoaded = false;
    if (image.complete) {
      publicAPI.imageLoaded();
    } else {
      image.addEventListener("load", publicAPI.imageLoaded);
    }
    publicAPI.modified();
  };
  publicAPI.getDimensionality = function() {
    var width = 0;
    var height = 0;
    var depth = 1;
    if (publicAPI.getInputData()) {
      var data = publicAPI.getInputData();
      width = data.getDimensions()[0];
      height = data.getDimensions()[1];
      depth = data.getDimensions()[2];
    }
    if (model.jsImageData) {
      width = model.jsImageData.width;
      height = model.jsImageData.height;
    }
    if (model.canvas) {
      width = model.canvas.width;
      height = model.canvas.height;
    }
    if (model.image) {
      width = model.image.width;
      height = model.image.height;
    }
    var dimensionality = (width > 1) + (height > 1) + (depth > 1);
    return dimensionality;
  };
  publicAPI.getInputAsJsImageData = function() {
    if (!model.imageLoaded || publicAPI.getInputData())
      return null;
    if (model.jsImageData) {
      return model.jsImageData();
    }
    if (model.canvas) {
      var context = model.canvas.getContext("2d");
      var imageData = context.getImageData(0, 0, model.canvas.width, model.canvas.height);
      return imageData;
    }
    if (model.image) {
      var canvas = document.createElement("canvas");
      canvas.width = model.image.width;
      canvas.height = model.image.height;
      var _context = canvas.getContext("2d");
      _context.translate(0, canvas.height);
      _context.scale(1, -1);
      _context.drawImage(model.image, 0, 0, model.image.width, model.image.height);
      var _imageData = _context.getImageData(0, 0, canvas.width, canvas.height);
      return _imageData;
    }
    return null;
  };
}
var generateMipmaps = function generateMipmaps2(nativeArray, width, height, level) {
  var g3m = [1, 2, 1];
  var g3w = 4;
  var kernel = g3m;
  var kernelWeight = g3w;
  var hs = nativeArray.length / (width * height);
  var currentWidth = width;
  var currentHeight = height;
  var imageData = nativeArray;
  var maps = [imageData];
  for (var i = 0; i < level; i++) {
    var oldData = _toConsumableArray(imageData);
    currentWidth /= 2;
    currentHeight /= 2;
    imageData = new Uint8ClampedArray(currentWidth * currentHeight * hs);
    var vs = hs * currentWidth;
    var shift = 0;
    for (var p = 0; p < imageData.length; p += hs) {
      if (p % vs === 0) {
        shift += 2 * hs * currentWidth;
      }
      for (var c = 0; c < hs; c++) {
        var sample = oldData[shift + c];
        sample += oldData[shift + hs + c];
        sample += oldData[shift - 2 * vs + c];
        sample += oldData[shift - 2 * vs + hs + c];
        sample /= 4;
        imageData[p + c] = sample;
      }
      shift += 2 * hs;
    }
    var dataCopy = _toConsumableArray(imageData);
    for (var _p = 0; _p < imageData.length; _p += hs) {
      for (var _c = 0; _c < hs; _c++) {
        var x = -(kernel.length - 1) / 2;
        var kw = kernelWeight;
        var value = 0;
        for (var k = 0; k < kernel.length; k++) {
          var index = _p + _c + x * hs;
          var lineShift = index % vs - (_p + _c) % vs;
          if (lineShift > hs)
            index += vs;
          if (lineShift < -hs)
            index -= vs;
          if (dataCopy[index]) {
            value += dataCopy[index] * kernel[k];
          } else {
            kw -= kernel[k];
          }
          x += 1;
        }
        imageData[_p + _c] = value / kw;
      }
    }
    dataCopy = _toConsumableArray(imageData);
    for (var _p2 = 0; _p2 < imageData.length; _p2 += hs) {
      for (var _c2 = 0; _c2 < hs; _c2++) {
        var _x = -(kernel.length - 1) / 2;
        var _kw = kernelWeight;
        var _value = 0;
        for (var _k = 0; _k < kernel.length; _k++) {
          var _index = _p2 + _c2 + _x * vs;
          if (dataCopy[_index]) {
            _value += dataCopy[_index] * kernel[_k];
          } else {
            _kw -= kernel[_k];
          }
          _x += 1;
        }
        imageData[_p2 + _c2] = _value / _kw;
      }
    }
    maps.push(imageData);
  }
  return maps;
};
var DEFAULT_VALUES = {
  image: null,
  canvas: null,
  jsImageData: null,
  imageLoaded: false,
  repeat: false,
  interpolate: false,
  edgeClamp: false,
  mipLevel: 0
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 6, 0);
  macro.get(publicAPI, model, ["canvas", "image", "jsImageData", "imageLoaded"]);
  macro.setGet(publicAPI, model, ["repeat", "edgeClamp", "interpolate", "mipLevel"]);
  vtkTexture(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkTexture");
var STATIC = {
  generateMipmaps
};
var vtkTexture$1 = _objectSpread({
  newInstance,
  extend
}, STATIC);

export {
  vtkTexture$1
};
//# sourceMappingURL=chunk-BVZBITDV.js.map
