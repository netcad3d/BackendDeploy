{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Common/Core/Points.js", "../../@kitware/vtk.js/Common/Core/CellArray.js", "../../@kitware/vtk.js/Common/DataModel/Cell.js", "../../@kitware/vtk.js/Common/DataModel/CellLinks.js", "../../@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js", "../../@kitware/vtk.js/Common/DataModel/CellTypes.js", "../../@kitware/vtk.js/Common/DataModel/Line/Constants.js", "../../@kitware/vtk.js/Common/DataModel/Line.js", "../../@kitware/vtk.js/Common/DataModel/PointSet.js", "../../@kitware/vtk.js/Common/DataModel/Triangle.js", "../../@kitware/vtk.js/Common/DataModel/PolyData/Constants.js", "../../@kitware/vtk.js/Common/DataModel/PolyData.js"],
  "sourcesContent": ["import macro from '../../macros.js';\nimport vtkDataArray from './DataArray.js';\nimport { VtkDataTypes } from './DataArray/Constants.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro;\nvar INVALID_BOUNDS = [1, -1, 1, -1, 1, -1]; // ----------------------------------------------------------------------------\n// vtkPoints methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPoints(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPoints'); // Forwarding methods\n\n  publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;\n\n  publicAPI.setNumberOfPoints = function (nbPoints) {\n    var dimension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n\n    if (publicAPI.getNumberOfPoints() !== nbPoints) {\n      model.size = nbPoints * dimension;\n      model.values = macro.newTypedArray(model.dataType, model.size);\n      publicAPI.setNumberOfComponents(dimension);\n      publicAPI.modified();\n    }\n  };\n\n  publicAPI.setPoint = function (idx) {\n    for (var _len = arguments.length, xyz = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      xyz[_key - 1] = arguments[_key];\n    }\n\n    publicAPI.setTuple(idx, xyz);\n  };\n\n  publicAPI.getPoint = publicAPI.getTuple;\n\n  publicAPI.insertNextPoint = function (x, y, z) {\n    return publicAPI.insertNextTuple([x, y, z]);\n  };\n\n  publicAPI.getBounds = function () {\n    if (publicAPI.getNumberOfComponents() === 3) {\n      var _xRange = publicAPI.getRange(0);\n\n      model.bounds[0] = _xRange[0];\n      model.bounds[1] = _xRange[1];\n\n      var _yRange = publicAPI.getRange(1);\n\n      model.bounds[2] = _yRange[0];\n      model.bounds[3] = _yRange[1];\n      var zRange = publicAPI.getRange(2);\n      model.bounds[4] = zRange[0];\n      model.bounds[5] = zRange[1];\n      return model.bounds;\n    }\n\n    if (publicAPI.getNumberOfComponents() !== 2) {\n      vtkErrorMacro(\"getBounds called on an array with components of\\n        \".concat(publicAPI.getNumberOfComponents()));\n      return INVALID_BOUNDS;\n    }\n\n    var xRange = publicAPI.getRange(0);\n    model.bounds[0] = xRange[0];\n    model.bounds[1] = xRange[1];\n    var yRange = publicAPI.getRange(1);\n    model.bounds[2] = yRange[0];\n    model.bounds[3] = yRange[1];\n    model.bounds[4] = 0;\n    model.bounds[5] = 0;\n    return model.bounds;\n  }; // Trigger the computation of bounds\n\n\n  publicAPI.computeBounds = publicAPI.getBounds; // Initialize\n\n  publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  empty: true,\n  numberOfComponents: 3,\n  dataType: VtkDataTypes.FLOAT,\n  bounds: [1, -1, 1, -1, 1, -1]\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkDataArray.extend(publicAPI, model, initialValues);\n  vtkPoints(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkPoints'); // ----------------------------------------------------------------------------\n\nvar vtkPoints$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkPoints$1 as default, extend, newInstance };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkDataArray from './DataArray.js';\nimport { VtkDataTypes } from './DataArray/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction extractCellSizes(cellArray) {\n  var currentIdx = 0;\n  return cellArray.filter(function (value, index) {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return true;\n    }\n\n    return false;\n  });\n}\n\nfunction getNumberOfCells(cellArray) {\n  var cellId = 0;\n\n  for (var cellArrayIndex = 0; cellArrayIndex < cellArray.length;) {\n    cellArrayIndex += cellArray[cellArrayIndex] + 1;\n    cellId++;\n  }\n\n  return cellId;\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\n\nvar STATIC = {\n  extractCellSizes: extractCellSizes,\n  getNumberOfCells: getNumberOfCells\n}; // ----------------------------------------------------------------------------\n// vtkCellArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellArray');\n\n  publicAPI.getNumberOfCells = function (recompute) {\n    if (model.numberOfCells !== undefined && !recompute) {\n      return model.numberOfCells;\n    }\n\n    if (model.cellSizes) {\n      model.numberOfCells = model.cellSizes.length;\n    } else {\n      model.numberOfCells = getNumberOfCells(publicAPI.getData());\n    }\n\n    return model.numberOfCells;\n  };\n\n  publicAPI.getCellSizes = function (recompute) {\n    if (model.cellSizes !== undefined && !recompute) {\n      return model.cellSizes;\n    }\n\n    model.cellSizes = extractCellSizes(publicAPI.getData());\n    return model.cellSizes;\n  };\n\n  var superSetData = publicAPI.setData;\n\n  publicAPI.setData = function (typedArray) {\n    superSetData(typedArray, 1);\n    model.numberOfCells = undefined;\n    model.cellSizes = undefined;\n  };\n\n  publicAPI.getCell = function (loc) {\n    var cellLoc = loc;\n    var numberOfPoints = model.values[cellLoc++];\n    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);\n  };\n\n  var superInitialize = publicAPI.initialize;\n\n  publicAPI.initialize = function () {\n    superInitialize(); // Set to undefined to ensure insertNextCell works correctly\n\n    model.numberOfCells = undefined;\n    model.cellSizes = undefined;\n  };\n\n  publicAPI.insertNextCell = function (cellPointIds) {\n    var cellId = publicAPI.getNumberOfCells();\n    publicAPI.insertNextTuples([cellPointIds.length].concat(_toConsumableArray(cellPointIds))); // By computing the number of cells earlier, we made sure that numberOfCells is defined\n\n    ++model.numberOfCells;\n\n    if (model.cellSizes != null) {\n      model.cellSizes.push(cellPointIds.length);\n    }\n\n    return cellId;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nfunction defaultValues(initialValues) {\n  return _objectSpread({\n    empty: true,\n    numberOfComponents: 1,\n    dataType: VtkDataTypes.UNSIGNED_INT\n  }, initialValues);\n} // ----------------------------------------------------------------------------\n\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkDataArray.extend(publicAPI, model, defaultValues(initialValues));\n  vtkCellArray(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkCellArray'); // ----------------------------------------------------------------------------\n\nvar vtkCellArray$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC);\n\nexport { STATIC, vtkCellArray$1 as default, extend, newInstance };\n", "import macro from '../../macros.js';\nimport { u as uninitializeBounds } from '../Core/Math/index.js';\nimport vtkPoints from '../Core/Points.js';\n\n// vtkCell methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCell(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCell');\n\n  publicAPI.initialize = function (points) {\n    var pointIdsList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (!pointIdsList) {\n      model.points = points;\n      model.pointsIds = new Array(points.getNumberOfPoints());\n\n      for (var i = points.getNumberOfPoints() - 1; i >= 0; --i) {\n        model.pointsIds[i] = i;\n      }\n    } else {\n      model.pointsIds = pointIdsList;\n      var triangleData = model.points.getData();\n\n      if (triangleData.length !== 3 * model.pointsIds.length) {\n        triangleData = macro.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);\n      }\n\n      var pointsData = points.getData();\n      model.pointsIds.forEach(function (pointId, index) {\n        // const start = 3 * pointId;\n        // pointsData.set(p.subarray(start, start + 3), 3 * index);\n        var pointOffset = 3 * pointId;\n        var trianglePointOffset = 3 * index;\n        triangleData[trianglePointOffset] = pointsData[pointOffset];\n        triangleData[++trianglePointOffset] = pointsData[++pointOffset];\n        triangleData[++trianglePointOffset] = pointsData[++pointOffset];\n      });\n      model.points.setData(triangleData);\n    }\n  };\n\n  publicAPI.getBounds = function () {\n    var nbPoints = model.points.getNumberOfPoints();\n    var x = [];\n\n    if (nbPoints) {\n      model.points.getPoint(0, x);\n      model.bounds[0] = x[0];\n      model.bounds[1] = x[0];\n      model.bounds[2] = x[1];\n      model.bounds[3] = x[1];\n      model.bounds[4] = x[2];\n      model.bounds[5] = x[2];\n\n      for (var i = 1; i < nbPoints; i++) {\n        model.points.getPoint(i, x);\n        model.bounds[0] = x[0] < model.bounds[0] ? x[0] : model.bounds[0];\n        model.bounds[1] = x[0] > model.bounds[1] ? x[0] : model.bounds[1];\n        model.bounds[2] = x[1] < model.bounds[2] ? x[1] : model.bounds[2];\n        model.bounds[3] = x[1] > model.bounds[3] ? x[1] : model.bounds[3];\n        model.bounds[4] = x[2] < model.bounds[4] ? x[2] : model.bounds[4];\n        model.bounds[5] = x[2] > model.bounds[5] ? x[2] : model.bounds[5];\n      }\n    } else {\n      uninitializeBounds(model.bounds);\n    }\n\n    return model.bounds;\n  };\n\n  publicAPI.getLength2 = function () {\n    publicAPI.getBounds();\n    var length = 0.0;\n    var diff = 0;\n\n    for (var i = 0; i < 3; i++) {\n      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];\n      length += diff * diff;\n    }\n\n    return length;\n  };\n\n  publicAPI.getParametricDistance = function (pcoords) {\n    var pDist;\n    var pDistMax = 0.0;\n\n    for (var i = 0; i < 3; i++) {\n      if (pcoords[i] < 0.0) {\n        pDist = -pcoords[i];\n      } else if (pcoords[i] > 1.0) {\n        pDist = pcoords[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n\n    return pDistMax;\n  };\n\n  publicAPI.getNumberOfPoints = function () {\n    return model.points.getNumberOfPoints();\n  };\n\n  publicAPI.deepCopy = function (cell) {\n    cell.initialize(model.points, model.pointsIds);\n  };\n\n  publicAPI.getCellDimension = function () {}; // virtual\n\n\n  publicAPI.intersectWithLine = function (p1, p2, tol, t, x, pcoords, subId) {}; // virtual\n\n\n  publicAPI.evaluatePosition = function (x, closestPoint, subId, pcoords, dist2, weights) {\n    macro.vtkErrorMacro('vtkCell.evaluatePosition is not implemented.');\n  }; // virtual\n\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  bounds: [-1, -1, -1, -1, -1, -1],\n  pointsIds: []\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n\n  if (!model.points) {\n    model.points = vtkPoints.newInstance();\n  }\n\n  macro.get(publicAPI, model, ['points', 'pointsIds']);\n  vtkCell(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkCell'); // ----------------------------------------------------------------------------\n\nvar vtkCell$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkCell$1 as default, extend, newInstance };\n", "import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport macro from '../../macros.js';\nimport vtkCell from './Cell.js';\n\n// Global methods\n// ----------------------------------------------------------------------------\n\nvar InitLink = {\n  ncells: 0,\n  cells: null\n};\n\nfunction resize(model, sz) {\n  var newSize = sz;\n\n  if (sz >= model.array.length) {\n    newSize += model.array.length;\n  }\n\n  while (newSize > model.array.length) {\n    model.array.push({\n      ncells: 0,\n      cells: null\n    });\n  }\n\n  model.array.length = newSize;\n} // ----------------------------------------------------------------------------\n// vtkCellLinks methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkCellLinks(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellLinks');\n  /**\n   * Build the link list array. All subclasses of vtkAbstractCellLinks\n   * must support this method.\n   */\n\n  publicAPI.buildLinks = function (data) {\n    var numPts = data.getPoints().getNumberOfPoints();\n    var numCells = data.getNumberOfCells(); // fill out lists with number of references to cells\n\n    var linkLoc = new Uint32Array(numPts); // Use fast path if polydata\n\n    if (data.isA('vtkPolyData')) {\n      // traverse data to determine number of uses of each point\n      for (var cellId = 0; cellId < numCells; ++cellId) {\n        var _data$getCellPoints = data.getCellPoints(cellId),\n            cellPointIds = _data$getCellPoints.cellPointIds;\n\n        cellPointIds.forEach(function (cellPointId) {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      } // now allocate storage for the links\n\n\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n\n      var _loop = function _loop(_cellId) {\n        var _data$getCellPoints2 = data.getCellPoints(_cellId),\n            cellPointIds = _data$getCellPoints2.cellPointIds;\n\n        cellPointIds.forEach(function (cellPointId) {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, _cellId);\n        });\n      };\n\n      for (var _cellId = 0; _cellId < numCells; ++_cellId) {\n        _loop(_cellId);\n      }\n    } // any other type of dataset\n    else {\n      // traverse data to determine number of uses of each point\n      for (var _cellId2 = 0; _cellId2 < numCells; _cellId2++) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        var cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(function (cellPointId) {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      } // now allocate storage for the links\n\n\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n\n      var _loop2 = function _loop2(_cellId3) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        var cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(function (cellPointId) {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, _cellId3);\n        });\n      };\n\n      for (var _cellId3 = 0; _cellId3 < numCells; ++_cellId3) {\n        _loop2(_cellId3);\n      }\n    } // end else\n\n  };\n  /**\n   * Build the link list array with a provided connectivity array.\n   */\n  // publicAPI.buildLinks = (data, connectivity) => {};\n\n  /**\n   * Allocate the specified number of links (i.e., number of points) that\n   * will be built.\n   */\n\n\n  publicAPI.allocate = function (numLinks) {\n    var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.array = Array(numLinks).fill().map(function () {\n      return {\n        ncells: 0,\n        cells: null\n      };\n    });\n    model.extend = ext;\n    model.maxId = -1;\n  };\n\n  publicAPI.initialize = function () {\n    model.array = null;\n  };\n  /**\n   * Get a link structure given a point id.\n   */\n\n\n  publicAPI.getLink = function (ptId) {\n    return model.array[ptId];\n  };\n  /**\n   * Get the number of cells using the point specified by ptId.\n   */\n\n\n  publicAPI.getNcells = function (ptId) {\n    return model.array[ptId].ncells;\n  };\n  /**\n   * Return a list of cell ids using the point.\n   */\n\n\n  publicAPI.getCells = function (ptId) {\n    return model.array[ptId].cells;\n  };\n  /**\n   * Insert a new point into the cell-links data structure. The size parameter\n   * is the initial size of the list.\n   */\n\n\n  publicAPI.insertNextPoint = function (numLinks) {\n    model.array.push({\n      ncells: numLinks,\n      cells: Array(numLinks)\n    });\n    ++model.maxId;\n  };\n  /**\n   * Insert a cell id into the list of cells (at the end) using the cell id\n   * provided. (Make sure to extend the link list (if necessary) using the\n   * method resizeCellList().)\n   */\n\n\n  publicAPI.insertNextCellReference = function (ptId, cellId) {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n  /**\n   * Delete point (and storage) by destroying links to using cells.\n   */\n\n\n  publicAPI.deletePoint = function (ptId) {\n    model.array[ptId].ncells = 0;\n    model.array[ptId].cells = null;\n  };\n  /**\n   * Delete the reference to the cell (cellId) from the point (ptId). This\n   * removes the reference to the cellId from the cell list, but does not\n   * resize the list (recover memory with resizeCellList(), if necessary).\n   */\n\n\n  publicAPI.removeCellReference = function (cellId, ptId) {\n    model.array[ptId].cells = model.array[ptId].cells.filter(function (cell) {\n      return cell !== cellId;\n    });\n    model.array[ptId].ncells = model.array[ptId].cells.length;\n  };\n  /**\n   * Add the reference to the cell (cellId) from the point (ptId). This\n   * adds a reference to the cellId from the cell list, but does not resize\n   * the list (extend memory with resizeCellList(), if necessary).\n   */\n\n\n  publicAPI.addCellReference = function (cellId, ptId) {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n  /**\n   * Change the length of a point's link list (i.e., list of cells using a\n   * point) by the size specified.\n   */\n\n\n  publicAPI.resizeCellList = function (ptId, size) {\n    model.array[ptId].cells.length = size;\n  };\n  /**\n   * Reclaim any unused memory.\n   */\n\n\n  publicAPI.squeeze = function () {\n    resize(model, model.maxId + 1);\n  };\n  /**\n   * Reset to a state of no entries without freeing the memory.\n   */\n\n\n  publicAPI.reset = function () {\n    model.maxId = -1;\n  };\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n\n\n  publicAPI.deepCopy = function (src) {\n    model.array = _toConsumableArray(src.array);\n    model.extend = src.extend;\n    model.maxId = src.maxId;\n  };\n  /**\n   * Increment the count of the number of cells using the point.\n   */\n\n\n  publicAPI.incrementLinkCount = function (ptId) {\n    ++model.array[ptId].ncells;\n  };\n\n  publicAPI.allocateLinks = function (n) {\n    for (var i = 0; i < n; ++i) {\n      model.array[i].cells = new Array(model.array[i].ncells);\n    }\n  };\n  /**\n   * Insert a cell id into the list of cells using the point.\n   */\n\n\n  publicAPI.insertCellReference = function (ptId, pos, cellId) {\n    model.array[ptId].cells[pos] = cellId;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  array: null,\n  // pointer to data\n  maxId: 0,\n  // maximum index inserted thus far\n  extend: 0 // grow array by this point\n\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  vtkCellLinks(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkCellLinks'); // ----------------------------------------------------------------------------\n\nvar vtkCellLinks$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { InitLink, vtkCellLinks$1 as default, extend, newInstance };\n", "var CellType = {\n  // Linear cells\n  VTK_EMPTY_CELL: 0,\n  VTK_VERTEX: 1,\n  VTK_POLY_VERTEX: 2,\n  VTK_LINE: 3,\n  VTK_POLY_LINE: 4,\n  VTK_TRIANGLE: 5,\n  VTK_TRIANGLE_STRIP: 6,\n  VTK_POLYGON: 7,\n  VTK_PIXEL: 8,\n  VTK_QUAD: 9,\n  VTK_TETRA: 10,\n  VTK_VOXEL: 11,\n  VTK_HEXAHEDRON: 12,\n  VTK_WEDGE: 13,\n  VTK_PYRAMID: 14,\n  VTK_PENTAGONAL_PRISM: 15,\n  VTK_HEXAGONAL_PRISM: 16,\n  // Quadratic, isoparametric cells\n  VTK_QUADRATIC_EDGE: 21,\n  VTK_QUADRATIC_TRIANGLE: 22,\n  VTK_QUADRATIC_QUAD: 23,\n  VTK_QUADRATIC_POLYGON: 36,\n  VTK_QUADRATIC_TETRA: 24,\n  VTK_QUADRATIC_HEXAHEDRON: 25,\n  VTK_QUADRATIC_WEDGE: 26,\n  VTK_QUADRATIC_PYRAMID: 27,\n  VTK_BIQUADRATIC_QUAD: 28,\n  VTK_TRIQUADRATIC_HEXAHEDRON: 29,\n  VTK_QUADRATIC_LINEAR_QUAD: 30,\n  VTK_QUADRATIC_LINEAR_WEDGE: 31,\n  VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,\n  VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,\n  VTK_BIQUADRATIC_TRIANGLE: 34,\n  // Cubic, isoparametric cell\n  VTK_CUBIC_LINE: 35,\n  // Special class of cells formed by convex group of points\n  VTK_CONVEX_POINT_SET: 41,\n  // Polyhedron cell (consisting of polygonal faces)\n  VTK_POLYHEDRON: 42,\n  // Higher order cells in parametric form\n  VTK_PARAMETRIC_CURVE: 51,\n  VTK_PARAMETRIC_SURFACE: 52,\n  VTK_PARAMETRIC_TRI_SURFACE: 53,\n  VTK_PARAMETRIC_QUAD_SURFACE: 54,\n  VTK_PARAMETRIC_TETRA_REGION: 55,\n  VTK_PARAMETRIC_HEX_REGION: 56,\n  // Higher order cells\n  VTK_HIGHER_ORDER_EDGE: 60,\n  VTK_HIGHER_ORDER_TRIANGLE: 61,\n  VTK_HIGHER_ORDER_QUAD: 62,\n  VTK_HIGHER_ORDER_POLYGON: 63,\n  VTK_HIGHER_ORDER_TETRAHEDRON: 64,\n  VTK_HIGHER_ORDER_WEDGE: 65,\n  VTK_HIGHER_ORDER_PYRAMID: 66,\n  VTK_HIGHER_ORDER_HEXAHEDRON: 67,\n  // Arbitrary order Lagrange elements (formulated separated from generic higher order cells)\n  VTK_LAGRANGE_CURVE: 68,\n  VTK_LAGRANGE_TRIANGLE: 69,\n  VTK_LAGRANGE_QUADRILATERAL: 70,\n  VTK_LAGRANGE_TETRAHEDRON: 71,\n  VTK_LAGRANGE_HEXAHEDRON: 72,\n  VTK_LAGRANGE_WEDGE: 73,\n  VTK_LAGRANGE_PYRAMID: 74,\n  VTK_NUMBER_OF_CELL_TYPES: 75\n}; // This list should contain the cell class names in\n// the same order as in CellType.\n\nvar CellTypesStrings = ['vtkEmptyCell', 'vtkVertex', 'vtkPolyVertex', 'vtkLine', 'vtkPolyLine', 'vtkTriangle', 'vtkTriangleStrip', 'vtkPolygon', 'vtkPixel', 'vtkQuad', 'vtkTetra', 'vtkVoxel', 'vtkHexahedron', 'vtkWedge', 'vtkPyramid', 'vtkPentagonalPrism', 'vtkHexagonalPrism', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkQuadraticEdge', 'vtkQuadraticTriangle', 'vtkQuadraticQuad', 'vtkQuadraticTetra', 'vtkQuadraticHexahedron', 'vtkQuadraticWedge', 'vtkQuadraticPyramid', 'vtkBiQuadraticQuad', 'vtkTriQuadraticHexahedron', 'vtkQuadraticLinearQuad', 'vtkQuadraticLinearWedge', 'vtkBiQuadraticQuadraticWedge', 'vtkBiQuadraticQuadraticHexahedron', 'vtkBiQuadraticTriangle', 'vtkCubicLine', 'vtkQuadraticPolygon', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkConvexPointSet', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkParametricCurve', 'vtkParametricSurface', 'vtkParametricTriSurface', 'vtkParametricQuadSurface', 'vtkParametricTetraRegion', 'vtkParametricHexRegion', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkHigherOrderEdge', 'vtkHigherOrderTriangle', 'vtkHigherOrderQuad', 'vtkHigherOrderPolygon', 'vtkHigherOrderTetrahedron', 'vtkHigherOrderWedge', 'vtkHigherOrderPyramid', 'vtkHigherOrderHexahedron'];\nvar Constants = {\n  CellType: CellType,\n  CellTypesStrings: CellTypesStrings\n};\n\nexport { CellType, CellTypesStrings, Constants as default };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport { CellTypesStrings, CellType } from './CellTypes/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n// Global methods\n// ----------------------------------------------------------------------------\n\n/**\n * Given an int (as defined in vtkCellType.h) identifier for a class\n * return it's classname.\n */\n\nfunction getClassNameFromTypeId(typeId) {\n  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : 'UnknownClass';\n}\n/**\n * Given a data object classname, return it's int identified (as\n * defined in vtkCellType.h)\n */\n\n\nfunction getTypeIdFromClassName(cellTypeString) {\n  return CellTypesStrings.findIndex(cellTypeString);\n}\n/**\n * This convenience method is a fast check to determine if a cell type\n * represents a linear or nonlinear cell.  This is generally much more\n * efficient than getting the appropriate vtkCell and checking its IsLinear\n * method.\n */\n\n\nfunction isLinear(type) {\n  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;\n}\n\nfunction hasSubCells(cellType) {\n  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\n\nvar STATIC = {\n  getClassNameFromTypeId: getClassNameFromTypeId,\n  getTypeIdFromClassName: getTypeIdFromClassName,\n  isLinear: isLinear,\n  hasSubCells: hasSubCells\n}; // ----------------------------------------------------------------------------\n// vtkCellTypes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellTypes(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellTypes');\n  /**\n   * Allocate memory for this array. Delete old storage only if necessary.\n   */\n\n  publicAPI.allocate = function () {\n    var sz = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 512;\n    var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.size = sz > 0 ? sz : 1;\n    model.extend = ext > 0 ? ext : 1;\n    model.maxId = -1;\n    model.typeArray = new Uint8Array(sz);\n    model.locationArray = new Uint32Array(sz);\n  };\n  /**\n   * Add a cell at specified id.\n   */\n\n\n  publicAPI.insertCell = function (cellId, type, loc) {\n    model.typeArray[cellId] = type;\n    model.locationArray[cellId] = loc;\n\n    if (cellId > model.maxId) {\n      model.maxId = cellId;\n    }\n  };\n  /**\n   * Add a cell to the object in the next available slot.\n   */\n\n\n  publicAPI.insertNextCell = function (type, loc) {\n    publicAPI.insertCell(++model.maxId, type, loc);\n    return model.maxId;\n  };\n  /**\n   * Specify a group of cell types. This version is provided to maintain\n   * backwards compatibility and does a copy of the cellLocations\n   */\n\n\n  publicAPI.setCellTypes = function (ncells, cellTypes, cellLocations) {\n    model.size = ncells;\n    model.typeArray = cellTypes;\n    model.locationArray = cellLocations;\n    model.maxId = ncells - 1;\n  };\n  /**\n   * Return the location of the cell in the associated vtkCellArray.\n   */\n\n\n  publicAPI.getCellLocation = function (cellId) {\n    return model.locationArray[cellId];\n  };\n  /**\n   * Delete cell by setting to nullptr cell type.\n   */\n\n\n  publicAPI.deleteCell = function (cellId) {\n    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;\n  };\n  /**\n   * Return the number of types in the list.\n   */\n\n\n  publicAPI.getNumberOfTypes = function () {\n    return model.maxId + 1;\n  };\n  /**\n   * Return true if type specified is contained in list; false otherwise.\n   */\n\n\n  publicAPI.isType = function (type) {\n    var numTypes = publicAPI.getNumberOfTypes();\n\n    for (var i = 0; i < numTypes; ++i) {\n      if (type === publicAPI.getCellType(i)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Add the type specified to the end of the list. Range checking is performed.\n   */\n\n\n  publicAPI.insertNextType = function (type) {\n    return publicAPI.insertNextCell(type, -1);\n  };\n  /**\n   * Return the type of cell.\n   */\n\n\n  publicAPI.getCellType = function (cellId) {\n    return model.typeArray[cellId];\n  };\n  /**\n   * Reclaim any extra memory.\n   */\n  // TODO: publicAPI.squeeze = () =>  {};\n\n  /**\n   * Initialize object without releasing memory.\n   */\n\n\n  publicAPI.reset = function () {\n    model.maxId = -1;\n  };\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n\n\n  publicAPI.deepCopy = function (src) {\n    publicAPI.allocate(src.getSize(), src.getExtend());\n    model.typeArray.set(src.getTypeArray());\n    model.locationArray.set(src.getLocationArray());\n    model.maxId = src.getMaxId();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  // typeArray: null, // pointer to types array\n  // locationArray: null;   // pointer to array of offsets\n  size: 0,\n  // allocated size of data\n  maxId: -1,\n  // maximum index inserted thus far\n  extend: 1000 // grow array by this point\n\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['size', 'maxId', 'extend']);\n  macro.getArray(publicAPI, model, ['typeArray', 'locationArray']);\n  vtkCellTypes(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkCellTypes'); // ----------------------------------------------------------------------------\n\nvar vtkCellTypes$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC);\n\nexport { STATIC, vtkCellTypes$1 as default, extend, newInstance };\n", "var IntersectionState = {\n  NO_INTERSECTION: 0,\n  YES_INTERSECTION: 1,\n  ON_LINE: 2\n};\nvar Constants = {\n  IntersectionState: IntersectionState\n};\n\nexport { IntersectionState, Constants as default };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport Constants from './Line/Constants.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, f as distance2BetweenPoints, s as subtract, j as solveLinearSystem } from '../Core/Math/index.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar IntersectionState = Constants.IntersectionState; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction distanceToLine(x, p1, p2) {\n  var closestPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var outObj = {\n    t: Number.MIN_VALUE,\n    distance: 0\n  };\n  var p21 = [];\n  var closest; // Determine appropriate vector\n\n  p21[0] = p2[0] - p1[0];\n  p21[1] = p2[1] - p1[1];\n  p21[2] = p2[2] - p1[2]; // Get parametric location\n\n  var num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);\n  var denom = dot(p21, p21); // trying to avoid an expensive fabs\n\n  var tolerance = 1e-5 * num;\n\n  if (denom !== 0.0) {\n    outObj.t = num / denom;\n  }\n\n  if (tolerance < 0.0) {\n    tolerance = -tolerance;\n  }\n\n  if (-tolerance < denom && denom < tolerance) {\n    closest = p1;\n  } else if (denom <= 0.0 || outObj.t < 0.0) {\n    // If parametric coordinate is within 0<=p<=1, then the point is closest to\n    // the line.  Otherwise, it's closest to a point at the end of the line.\n    closest = p1;\n  } else if (outObj.t > 1.0) {\n    closest = p2;\n  } else {\n    closest = p21;\n    p21[0] = p1[0] + outObj.t * p21[0];\n    p21[1] = p1[1] + outObj.t * p21[1];\n    p21[2] = p1[2] + outObj.t * p21[2];\n  }\n\n  if (closestPoint) {\n    closestPoint[0] = closest[0];\n    closestPoint[1] = closest[1];\n    closestPoint[2] = closest[2];\n  }\n\n  outObj.distance = distance2BetweenPoints(closest, x);\n  return outObj;\n}\n\nfunction intersection(a1, a2, b1, b2, u, v) {\n  var a21 = [];\n  var b21 = [];\n  var b1a1 = [];\n  u[0] = 0.0;\n  v[0] = 0.0; // Determine line vectors.\n\n  subtract(a2, a1, a21);\n  subtract(b2, b1, b21);\n  subtract(b1, a1, b1a1); // Compute the system (least squares) matrix.\n\n  var A = [dot(a21, a21), -dot(a21, b21), -dot(a21, b21), dot(b21, b21)]; // Compute the least squares system constant term.\n\n  var c = [];\n  c[0] = dot(a21, b1a1);\n  c[1] = -dot(b21, b1a1); // Solve the system of equations\n\n  if (solveLinearSystem(A, c, 2) === 0) {\n    // The lines are colinear. Therefore, one of the four endpoints is the\n    // point of closest approach\n    var minDist = Number.MAX_VALUE;\n    var p = [a1, a2, b1, b2];\n    var l1 = [b1, b1, a1, a1];\n    var l2 = [b2, b2, a2, a2];\n    var uv1 = [v[0], v[0], u[0], u[0]];\n    var uv2 = [u[0], u[0], v[0], v[0]];\n    var obj;\n\n    for (var i = 0; i < 4; i++) {\n      obj = distanceToLine(p[i], l1[i], l2[i]);\n\n      if (obj.distance < minDist) {\n        minDist = obj.distance;\n        uv1[i] = obj.t;\n        uv2[i] = i % 2;\n      }\n    }\n\n    return IntersectionState.ON_LINE;\n  }\n\n  u[0] = c[0];\n  v[0] = c[1]; // Check parametric coordinates for intersection.\n\n  if (u[0] >= 0.0 && u[0] <= 1.0 && v[0] >= 0.0 && v[0] <= 1.0) {\n    return IntersectionState.YES_INTERSECTION;\n  }\n\n  return IntersectionState.NO_INTERSECTION;\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\n\nvar STATIC = {\n  distanceToLine: distanceToLine,\n  intersection: intersection\n}; // ----------------------------------------------------------------------------\n// vtkLine methods\n// ----------------------------------------------------------------------------\n\nfunction vtkLine(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkLine');\n\n  function isBetweenPoints(t) {\n    return t >= 0.0 && t <= 1.0;\n  }\n\n  publicAPI.getCellDimension = function () {\n    return 1;\n  };\n\n  publicAPI.intersectWithLine = function (p1, p2, tol, x, pcoords) {\n    var outObj = {\n      intersect: 0,\n      t: Number.MAX_VALUE,\n      subId: 0,\n      betweenPoints: null\n    };\n    pcoords[1] = 0.0;\n    pcoords[2] = 0.0;\n    var projXYZ = [];\n    var a1 = [];\n    var a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    var u = [];\n    var v = [];\n    var intersect = intersection(p1, p2, a1, a2, u, v);\n    outObj.t = u[0];\n    outObj.betweenPoints = isBetweenPoints(outObj.t);\n    pcoords[0] = v[0];\n\n    if (intersect === IntersectionState.YES_INTERSECTION) {\n      // make sure we are within tolerance\n      for (var i = 0; i < 3; i++) {\n        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);\n      }\n\n      if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {\n        outObj.intersect = 1;\n        return outObj;\n      }\n    } else {\n      var outDistance; // check to see if it lies within tolerance\n      // one of the parametric coords must be outside 0-1\n\n      if (outObj.t < 0.0) {\n        outDistance = distanceToLine(p1, a1, a2, x);\n\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 0.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p1\n\n          return outObj;\n        }\n\n        return outObj;\n      }\n\n      if (outObj.t > 1.0) {\n        outDistance = distanceToLine(p2, a1, a2, x);\n\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 1.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p2\n\n          return outObj;\n        }\n\n        return outObj;\n      }\n\n      if (pcoords[0] < 0.0) {\n        pcoords[0] = 0.0;\n        outDistance = distanceToLine(a1, p1, p2, x);\n        outObj.t = outDistance.t;\n\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n\n        return outObj;\n      }\n\n      if (pcoords[0] > 1.0) {\n        pcoords[0] = 1.0;\n        outDistance = distanceToLine(a2, p1, p2, x);\n        outObj.t = outDistance.t;\n\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n\n        return outObj;\n      }\n    }\n\n    return outObj;\n  };\n\n  publicAPI.evaluateLocation = function (pcoords, x, weights) {\n    var a1 = [];\n    var a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n\n    for (var i = 0; i < 3; i++) {\n      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n    }\n\n    weights[0] = 1.0 - pcoords[0];\n    weights[1] = pcoords[0];\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkLine(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkLine'); // ----------------------------------------------------------------------------\n\nvar vtkLine$1 = _objectSpread(_objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC), Constants);\n\nexport { STATIC, vtkLine$1 as default, extend, newInstance };\n", "import vtk from '../../vtk.js';\nimport macro from '../../macros.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkPoints from '../Core/Points.js';\n\n// Global methods\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// vtkPointSet methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPointSet(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPointSet'); // Create empty points\n\n  if (!model.points) {\n    model.points = vtkPoints.newInstance();\n  } else {\n    model.points = vtk(model.points);\n  }\n\n  publicAPI.getNumberOfPoints = function () {\n    return model.points.getNumberOfPoints();\n  };\n\n  publicAPI.getBounds = function () {\n    return model.points.getBounds();\n  };\n\n  publicAPI.computeBounds = function () {\n    publicAPI.getBounds();\n  };\n\n  var superShallowCopy = publicAPI.shallowCopy;\n\n  publicAPI.shallowCopy = function (other) {\n    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    superShallowCopy(other, debug);\n    model.points = vtkPoints.newInstance();\n    model.points.shallowCopy(other.getPoints());\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {// points: null,\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['points']); // Object specific methods\n\n  vtkPointSet(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkPointSet'); // ----------------------------------------------------------------------------\n\nvar vtkPointSet$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkPointSet$1 as default, extend, newInstance };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, k as cross, m as normalize, o as multiplyAccumulate, f as distance2BetweenPoints, p as determinant2x2 } from '../Core/Math/index.js';\nimport vtkLine from './Line.js';\nimport vtkPlane from './Plane.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction computeNormalDirection(v1, v2, v3, n) {\n  // order is important!!! maintain consistency with triangle vertex order\n  var ax = v3[0] - v2[0];\n  var ay = v3[1] - v2[1];\n  var az = v3[2] - v2[2];\n  var bx = v1[0] - v2[0];\n  var by = v1[1] - v2[1];\n  var bz = v1[2] - v2[2];\n  n[0] = ay * bz - az * by;\n  n[1] = az * bx - ax * bz;\n  n[2] = ax * by - ay * bx;\n}\n\nfunction computeNormal(v1, v2, v3, n) {\n  computeNormalDirection(v1, v2, v3, n);\n  var length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);\n\n  if (length !== 0.0) {\n    n[0] /= length;\n    n[1] /= length;\n    n[2] /= length;\n  }\n}\n\nfunction intersectWithTriangle(p1, q1, r1, p2, q2, r2) {\n  var tolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1e-6;\n  var coplanar = false;\n  var pt1 = [];\n  var pt2 = [];\n  var surfaceId = [];\n  var n1 = [];\n  var n2 = []; // Compute supporting plane normals.\n\n  computeNormal(p1, q1, r1, n1);\n  computeNormal(p2, q2, r2, n2);\n  var s1 = -dot(n1, p1);\n  var s2 = -dot(n2, p2); // Compute signed distances of points p1, q1, r1 from supporting\n  // plane of second triangle.\n\n  var dist1 = [dot(n2, p1) + s2, dot(n2, q1) + s2, dot(n2, r1) + s2]; // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n\n  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 1!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  } // Do the same for p2, q2, r2 and supporting plane of first\n  // triangle.\n\n\n  var dist2 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1]; // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n\n  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 2!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  } // Check for coplanarity of the supporting planes.\n\n\n  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {\n    coplanar = true; // vtkDebugMacro(<<\"Coplanar!\");\n\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  } // There are more efficient ways to find the intersection line (if\n  // it exists), but this is clear enough.\n\n\n  var pts1 = [p1, q1, r1];\n  var pts2 = [p2, q2, r2]; // Find line of intersection (L = p + t*v) between two planes.\n\n  var n1n2 = dot(n1, n2);\n  var a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1.0);\n  var b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1.0);\n  var p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];\n  var v = cross(n1, n2, []);\n  normalize(v);\n  var index1 = 0;\n  var index2 = 0;\n  var t1 = [];\n  var t2 = [];\n  var ts1 = 50;\n  var ts2 = 50;\n\n  for (var i = 0; i < 3; i++) {\n    var id1 = i;\n    var id2 = (i + 1) % 3; // Find t coordinate on line of intersection between two planes.\n\n    var val1 = vtkPlane.intersectWithLine(pts1[id1], pts1[id2], p2, n2);\n\n    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {\n      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {\n        ts1 = index1;\n      }\n\n      t1[index1++] = dot(val1.x, v) - dot(p, v);\n    }\n\n    var val2 = vtkPlane.intersectWithLine(pts2[id1], pts2[id2], p1, n1);\n\n    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {\n      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {\n        ts2 = index2;\n      }\n\n      t2[index2++] = dot(val2.x, v) - dot(p, v);\n    }\n  } // If the value of the index is greater than 2, the intersecting point\n  // actually is intersected by all three edges. In this case, set the two\n  // edges to the two edges where the intersecting point is not the end point\n\n\n  if (index1 > 2) {\n    index1--; // swap\n\n    var t12 = t1[2];\n    t1[2] = t1[ts1];\n    t1[ts1] = t12;\n  }\n\n  if (index2 > 2) {\n    index2--;\n    var t22 = t2[2];\n    t2[2] = t2[ts2];\n    t2[ts2] = t22;\n  } // Check if only one edge or all edges intersect the supporting\n  // planes intersection.\n\n\n  if (index1 !== 2 || index2 !== 2) {\n    // vtkDebugMacro(<<\"Only one edge intersecting!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  } // Check for NaNs\n\n\n  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {\n    // vtkWarningMacro(<<\"NaNs!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    };\n  }\n\n  if (t1[0] > t1[1]) {\n    // swap\n    var t11 = t1[1];\n    t1[1] = t1[0];\n    t1[0] = t11;\n  }\n\n  if (t2[0] > t2[1]) {\n    // swap\n    var t21 = t2[1];\n    t2[1] = t2[0];\n    t2[0] = t21;\n  } // Handle the different interval configuration cases.\n\n\n  var tt1;\n  var tt2;\n\n  if (t1[1] < t2[0] || t2[1] < t1[0]) {\n    // vtkDebugMacro(<<\"No Overlap!\");\n    return {\n      intersect: false,\n      coplanar: coplanar,\n      pt1: pt1,\n      pt2: pt2,\n      surfaceId: surfaceId\n    }; // No overlap\n  }\n\n  if (t1[0] < t2[0]) {\n    if (t1[1] < t2[1]) {\n      // First point on surface 2, second point on surface 1\n      surfaceId[0] = 2;\n      surfaceId[1] = 1;\n      tt1 = t2[0];\n      tt2 = t1[1];\n    } else {\n      // Both points belong to lines on surface 2\n      surfaceId[0] = 2;\n      surfaceId[1] = 2;\n      tt1 = t2[0];\n      tt2 = t2[1];\n    }\n  } // t1[0] >= t2[0]\n  else if (t1[1] < t2[1]) {\n    // Both points belong to lines on surface 1\n    surfaceId[0] = 1;\n    surfaceId[1] = 1;\n    tt1 = t1[0];\n    tt2 = t1[1];\n  } else {\n    // First point on surface 1, second point on surface 2\n    surfaceId[0] = 1;\n    surfaceId[1] = 2;\n    tt1 = t1[0];\n    tt2 = t2[1];\n  } // Create actual intersection points.\n\n\n  multiplyAccumulate(p, v, tt1, pt1);\n  multiplyAccumulate(p, v, tt2, pt2);\n  return {\n    intersect: true,\n    coplanar: coplanar,\n    pt1: pt1,\n    pt2: pt2,\n    surfaceId: surfaceId\n  };\n} // ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\n\nvar STATIC = {\n  computeNormalDirection: computeNormalDirection,\n  computeNormal: computeNormal,\n  intersectWithTriangle: intersectWithTriangle\n}; // ----------------------------------------------------------------------------\n// vtkTriangle methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTriangle(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTriangle');\n\n  publicAPI.getCellDimension = function () {\n    return 2;\n  };\n\n  publicAPI.intersectWithLine = function (p1, p2, tol, x, pcoords) {\n    var outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    pcoords[2] = 0.0;\n    var closestPoint = [];\n    var tol2 = tol * tol; // Get normal for triangle\n\n    var pt1 = [];\n    var pt2 = [];\n    var pt3 = [];\n    model.points.getPoint(0, pt1);\n    model.points.getPoint(1, pt2);\n    model.points.getPoint(2, pt3);\n    var n = [];\n    var weights = [];\n    computeNormal(pt1, pt2, pt3, n);\n\n    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {\n      // Intersect plane of triangle with line\n      var plane = vtkPlane.intersectWithLine(p1, p2, pt1, n);\n      outObj.betweenPoints = plane.betweenPoints;\n      outObj.t = plane.t;\n      x[0] = plane.x[0];\n      x[1] = plane.x[1];\n      x[2] = plane.x[2];\n\n      if (!plane.intersection) {\n        pcoords[0] = 0.0;\n        pcoords[1] = 0.0;\n        outObj.intersect = 0;\n        return outObj;\n      } // Evaluate position\n\n\n      var inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);\n\n      if (inside.evaluation >= 0) {\n        if (inside.dist2 <= tol2) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n\n        outObj.intersect = inside.evaluation;\n        return outObj;\n      }\n    } // Normals are null, so the triangle is degenerated and\n    // we still need to check intersection between line and\n    // the longest edge.\n\n\n    var dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);\n    var dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);\n    var dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);\n\n    if (!model.line) {\n      model.line = vtkLine.newInstance();\n    }\n\n    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {\n      model.line.getPoints().setPoint(0, pt1);\n      model.line.getPoints().setPoint(1, pt2);\n    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {\n      model.line.getPoints().setPoint(0, pt2);\n      model.line.getPoints().setPoint(1, pt3);\n    } else {\n      model.line.getPoints().setPoint(0, pt3);\n      model.line.getPoints().setPoint(1, pt1);\n    }\n\n    var intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);\n    outObj.betweenPoints = intersectLine.betweenPoints;\n    outObj.t = intersectLine.t;\n\n    if (intersectLine.intersect) {\n      var pt3Pt1 = [];\n      var pt3Pt2 = [];\n      var pt3X = []; // Compute r and s manually, using dot and norm.\n\n      for (var i = 0; i < 3; i++) {\n        pt3Pt1[i] = pt1[i] - pt3[i];\n        pt3Pt2[i] = pt2[i] - pt3[i];\n        pt3X[i] = x[i] - pt3[i];\n      }\n\n      pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;\n      pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;\n      outObj.intersect = 1;\n      return outObj;\n    }\n\n    pcoords[0] = 0.0;\n    pcoords[1] = 0.0;\n    outObj.intersect = 0;\n    return outObj;\n  };\n\n  publicAPI.evaluatePosition = function (x, closestPoint, pcoords, weights) {\n    // will return obj\n    var outObj = {\n      subId: 0,\n      dist2: 0,\n      evaluation: -1\n    };\n    var i;\n    var j;\n    var pt1 = [];\n    var pt2 = [];\n    var pt3 = [];\n    var n = [];\n    var fabsn;\n    var rhs = [];\n    var c1 = [];\n    var c2 = [];\n    var det = 0;\n    var idx = 0;\n    var indices = [];\n    var dist2Point;\n    var dist2Line1;\n    var dist2Line2;\n    var closest = [];\n    var closestPoint1 = [];\n    var closestPoint2 = [];\n    var cp = [];\n    outObj.subId = 0;\n    pcoords[2] = 0.0; // Get normal for triangle, only the normal direction is needed, i.e. the\n    // normal need not be normalized (unit length)\n    //\n\n    model.points.getPoint(1, pt1);\n    model.points.getPoint(2, pt2);\n    model.points.getPoint(0, pt3);\n    computeNormalDirection(pt1, pt2, pt3, n); // Project point to plane\n\n    vtkPlane.generalizedProjectPoint(x, pt1, n, cp); // Construct matrices.  Since we have over determined system, need to find\n    // which 2 out of 3 equations to use to develop equations. (Any 2 should\n    // work since we've projected point to plane.)\n\n    var maxComponent = 0.0;\n\n    for (i = 0; i < 3; i++) {\n      // trying to avoid an expensive call to fabs()\n      if (n[i] < 0) {\n        fabsn = -n[i];\n      } else {\n        fabsn = n[i];\n      }\n\n      if (fabsn > maxComponent) {\n        maxComponent = fabsn;\n        idx = i;\n      }\n    }\n\n    for (j = 0, i = 0; i < 3; i++) {\n      if (i !== idx) {\n        indices[j++] = i;\n      }\n    }\n\n    for (i = 0; i < 2; i++) {\n      rhs[i] = cp[indices[i]] - pt3[indices[i]];\n      c1[i] = pt1[indices[i]] - pt3[indices[i]];\n      c2[i] = pt2[indices[i]] - pt3[indices[i]];\n    }\n\n    det = determinant2x2(c1, c2);\n\n    if (det === 0.0) {\n      pcoords[0] = 0.0;\n      pcoords[1] = 0.0;\n      outObj.evaluation = -1;\n      return outObj;\n    }\n\n    pcoords[0] = determinant2x2(rhs, c2) / det;\n    pcoords[1] = determinant2x2(c1, rhs) / det; // Okay, now find closest point to element\n\n    weights[0] = 1 - (pcoords[0] + pcoords[1]);\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n\n    if (weights[0] >= 0.0 && weights[0] <= 1.0 && weights[1] >= 0.0 && weights[1] <= 1.0 && weights[2] >= 0.0 && weights[2] <= 1.0) {\n      // projection distance\n      if (closestPoint) {\n        outObj.dist2 = distance2BetweenPoints(cp, x);\n        closestPoint[0] = cp[0];\n        closestPoint[1] = cp[1];\n        closestPoint[2] = cp[2];\n      }\n\n      outObj.evaluation = 1;\n    } else {\n      var t;\n\n      if (closestPoint) {\n        if (weights[1] < 0.0 && weights[2] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt3);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt3, pt2, t, closestPoint2);\n\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt3;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[2] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt1);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt1;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[1] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt2);\n          dist2Line1 = vtkLine.distanceToLine(x, pt2, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt2;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[0] < 0.0) {\n          var lineDistance = vtkLine.distanceToLine(x, pt1, pt2, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[1] < 0.0) {\n          var _lineDistance = vtkLine.distanceToLine(x, pt2, pt3, closestPoint);\n\n          outObj.dist2 = _lineDistance.distance;\n        } else if (weights[2] < 0.0) {\n          var _lineDistance2 = vtkLine.distanceToLine(x, pt1, pt3, closestPoint);\n\n          outObj.dist2 = _lineDistance2.distance;\n        }\n      }\n\n      outObj.evaluation = 0;\n    }\n\n    return outObj;\n  };\n\n  publicAPI.evaluateLocation = function (pcoords, x, weights) {\n    var p0 = [];\n    var p1 = [];\n    var p2 = [];\n    model.points.getPoint(0, p0);\n    model.points.getPoint(1, p1);\n    model.points.getPoint(2, p2);\n    var u3 = 1.0 - pcoords[0] - pcoords[1];\n\n    for (var i = 0; i < 3; i++) {\n      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];\n    }\n\n    weights[0] = u3;\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n  };\n\n  publicAPI.getParametricDistance = function (pcoords) {\n    var pDist;\n    var pDistMax = 0.0;\n    var pc = [];\n    pc[0] = pcoords[0];\n    pc[1] = pcoords[1];\n    pc[2] = 1.0 - pcoords[0] - pcoords[1];\n\n    for (var i = 0; i < 3; i++) {\n      if (pc[i] < 0.0) {\n        pDist = -pc[i];\n      } else if (pc[i] > 1.0) {\n        pDist = pc[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n\n    return pDistMax;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkTriangle(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkTriangle'); // ----------------------------------------------------------------------------\n\nvar vtkTriangle$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, STATIC);\n\nexport { STATIC, vtkTriangle$1 as default, extend, newInstance };\n", "var POLYDATA_FIELDS = ['verts', 'lines', 'polys', 'strips'];\nvar Constants = {\n  POLYDATA_FIELDS: POLYDATA_FIELDS\n};\n\nexport { POLYDATA_FIELDS, Constants as default };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtk from '../../vtk.js';\nimport vtkCellArray from '../Core/CellArray.js';\nimport vtkCellLinks from './CellLinks.js';\nimport vtkCellTypes from './CellTypes.js';\nimport vtkLine from './Line.js';\nimport vtkPointSet from './PointSet.js';\nimport vtkTriangle from './Triangle.js';\nimport { CellType } from './CellTypes/Constants.js';\nimport { POLYDATA_FIELDS } from './PolyData/Constants.js';\n\nvar _CELL_FACTORY;\nvar vtkWarningMacro = macro.vtkWarningMacro;\nvar CELL_FACTORY = (_CELL_FACTORY = {}, _defineProperty(_CELL_FACTORY, CellType.VTK_LINE, vtkLine), _defineProperty(_CELL_FACTORY, CellType.VTK_POLY_LINE, vtkLine), _defineProperty(_CELL_FACTORY, CellType.VTK_TRIANGLE, vtkTriangle), _CELL_FACTORY); // ----------------------------------------------------------------------------\n// vtkPolyData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPolyData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPolyData');\n\n  function camelize(str) {\n    return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function (letter) {\n      return letter.toUpperCase();\n    }).replace(/\\s+/g, '');\n  } // build empty cell arrays and set methods\n\n\n  POLYDATA_FIELDS.forEach(function (type) {\n    publicAPI[\"getNumberOf\".concat(camelize(type))] = function () {\n      return model[type].getNumberOfCells();\n    };\n\n    if (!model[type]) {\n      model[type] = vtkCellArray.newInstance();\n    } else {\n      model[type] = vtk(model[type]);\n    }\n  });\n\n  publicAPI.getNumberOfCells = function () {\n    return POLYDATA_FIELDS.reduce(function (num, cellType) {\n      return num + model[cellType].getNumberOfCells();\n    }, 0);\n  };\n\n  var superShallowCopy = publicAPI.shallowCopy;\n\n  publicAPI.shallowCopy = function (other) {\n    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    superShallowCopy(other, debug);\n    POLYDATA_FIELDS.forEach(function (type) {\n      model[type] = vtkCellArray.newInstance();\n      model[type].shallowCopy(other.getReferenceByName(type));\n    });\n  };\n\n  publicAPI.buildCells = function () {\n    // here are the number of cells we have\n    var nVerts = publicAPI.getNumberOfVerts();\n    var nLines = publicAPI.getNumberOfLines();\n    var nPolys = publicAPI.getNumberOfPolys();\n    var nStrips = publicAPI.getNumberOfStrips(); // pre-allocate the space we need\n\n    var nCells = nVerts + nLines + nPolys + nStrips;\n    var types = new Uint8Array(nCells);\n    var pTypes = types;\n    var locs = new Uint32Array(nCells);\n    var pLocs = locs; // record locations and type of each cell.\n    // verts\n\n    if (nVerts) {\n      var nextCellPts = 0;\n      model.verts.getCellSizes().forEach(function (numCellPts, index) {\n        pLocs[index] = nextCellPts;\n        pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs = pLocs.subarray(nVerts);\n      pTypes = pTypes.subarray(nVerts);\n    } // lines\n\n\n    if (nLines) {\n      var _nextCellPts = 0;\n      model.lines.getCellSizes().forEach(function (numCellPts, index) {\n        pLocs[index] = _nextCellPts;\n        pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;\n\n        if (numCellPts === 1) {\n          vtkWarningMacro('Building VTK_LINE ', index, ' with only one point, but VTK_LINE needs at least two points. Check the input.');\n        }\n\n        _nextCellPts += numCellPts + 1;\n      });\n      pLocs = pLocs.subarray(nLines);\n      pTypes = pTypes.subarray(nLines);\n    } // polys\n\n\n    if (nPolys) {\n      var _nextCellPts2 = 0;\n      model.polys.getCellSizes().forEach(function (numCellPts, index) {\n        pLocs[index] = _nextCellPts2;\n\n        switch (numCellPts) {\n          case 3:\n            pTypes[index] = CellType.VTK_TRIANGLE;\n            break;\n\n          case 4:\n            pTypes[index] = CellType.VTK_QUAD;\n            break;\n\n          default:\n            pTypes[index] = CellType.VTK_POLYGON;\n            break;\n        }\n\n        if (numCellPts < 3) {\n          vtkWarningMacro('Building VTK_TRIANGLE ', index, ' with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.');\n        }\n\n        _nextCellPts2 += numCellPts + 1;\n      });\n      pLocs += pLocs.subarray(nPolys);\n      pTypes += pTypes.subarray(nPolys);\n    } // strips\n\n\n    if (nStrips) {\n      var _nextCellPts3 = 0;\n      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);\n      model.strips.getCellSizes().forEach(function (numCellPts, index) {\n        pLocs[index] = _nextCellPts3;\n        _nextCellPts3 += numCellPts + 1;\n      });\n    } // set up the cell types data structure\n\n\n    model.cells = vtkCellTypes.newInstance();\n    model.cells.setCellTypes(nCells, types, locs);\n  };\n  /**\n   * Create upward links from points to cells that use each point. Enables\n   * topologically complex queries.\n   */\n\n\n  publicAPI.buildLinks = function () {\n    var initialSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    if (model.cells === undefined) {\n      publicAPI.buildCells();\n    }\n\n    model.links = vtkCellLinks.newInstance();\n\n    if (initialSize > 0) {\n      model.links.allocate(initialSize);\n    } else {\n      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());\n    }\n\n    model.links.buildLinks(publicAPI);\n  };\n\n  publicAPI.getCellType = function (cellId) {\n    return model.cells.getCellType(cellId);\n  };\n\n  publicAPI.getCellPoints = function (cellId) {\n    var cellType = publicAPI.getCellType(cellId);\n    var cells = null;\n\n    switch (cellType) {\n      case CellType.VTK_VERTEX:\n      case CellType.VTK_POLY_VERTEX:\n        cells = model.verts;\n        break;\n\n      case CellType.VTK_LINE:\n      case CellType.VTK_POLY_LINE:\n        cells = model.lines;\n        break;\n\n      case CellType.VTK_TRIANGLE:\n      case CellType.VTK_QUAD:\n      case CellType.VTK_POLYGON:\n        cells = model.polys;\n        break;\n\n      case CellType.VTK_TRIANGLE_STRIP:\n        cells = model.strips;\n        break;\n\n      default:\n        cells = null;\n        return {\n          type: 0,\n          cellPointIds: null\n        };\n    }\n\n    var loc = model.cells.getCellLocation(cellId);\n    var cellPointIds = cells.getCell(loc);\n    return {\n      cellType: cellType,\n      cellPointIds: cellPointIds\n    };\n  };\n\n  publicAPI.getPointCells = function (ptId) {\n    return model.links.getCells(ptId);\n  };\n\n  publicAPI.getCellEdgeNeighbors = function (cellId, point1, point2) {\n    var link1 = model.links.getLink(point1);\n    var link2 = model.links.getLink(point2);\n    return link1.cells.filter(function (cell) {\n      return cell !== cellId && link2.cells.indexOf(cell) !== -1;\n    });\n  };\n  /**\n   * If you know the type of cell, you may provide it to improve performances.\n   */\n\n\n  publicAPI.getCell = function (cellId) {\n    var cellHint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var cellInfo = publicAPI.getCellPoints(cellId);\n    var cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();\n    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);\n    return cell;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {// verts: null,\n  // lines: null,\n  // polys: null,\n  // strips: null,\n  // cells: null,\n  // links: null,\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkPointSet.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['cells', 'links']);\n  macro.setGet(publicAPI, model, ['verts', 'lines', 'polys', 'strips']); // Object specific methods\n\n  vtkPolyData(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkPolyData'); // ----------------------------------------------------------------------------\n\nvar vtkPolyData$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { CELL_FACTORY, vtkPolyData$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "_loop", "_cellId", "cellPointIds", "_loop2", "_cellId3", "cell", "DEFAULT_VALUES", "extend", "newInstance", "ownKeys", "_objectSpread", "STATIC", "DEFAULT_VALUES", "extend", "newInstance", "ownKeys", "_objectSpread", "IntersectionState", "STATIC", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "ownKeys", "_objectSpread", "STATIC", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance"]
}
