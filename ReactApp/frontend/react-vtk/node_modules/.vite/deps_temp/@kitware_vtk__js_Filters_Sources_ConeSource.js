import {
  vtkPolyData$1
} from "./chunk-XT2DETPC.js";
import "./chunk-Z2LVQNSU.js";
import "./chunk-Z5OKWKLG.js";
import "./chunk-SWDS6M4V.js";
import {
  vtkMatrixBuilder
} from "./chunk-GQ6SS5ID.js";
import "./chunk-GC37RKNO.js";
import "./chunk-SXNZFZKA.js";
import "./chunk-FOWOP5PK.js";
import {
  _toConsumableArray,
  macro
} from "./chunk-OTTIIP4A.js";
import "./chunk-HKWV5KNA.js";
import "./chunk-XL65WI7U.js";
import "./chunk-HUBM7RA2.js";

// node_modules/@kitware/vtk.js/Filters/Sources/ConeSource.js
function vtkConeSource(publicAPI, model) {
  model.classHierarchy.push("vtkConeSource");
  function requestData(inData, outData) {
    var _vtkMatrixBuilder$bui;
    if (model.deleted) {
      return;
    }
    var dataset = outData[0];
    var angle = 2 * Math.PI / model.resolution;
    var xbot = -model.height / 2;
    var numberOfPoints = model.resolution + 1;
    var cellArraySize = 4 * model.resolution + 1 + model.resolution;
    var pointIdx = 0;
    var points = macro.newTypedArray(model.pointType, numberOfPoints * 3);
    var cellLocation = 0;
    var polys = new Uint32Array(cellArraySize);
    points[0] = model.height / 2;
    points[1] = 0;
    points[2] = 0;
    if (model.capping) {
      polys[cellLocation++] = model.resolution;
    }
    for (var i = 0; i < model.resolution; i++) {
      pointIdx++;
      points[pointIdx * 3 + 0] = xbot;
      points[pointIdx * 3 + 1] = model.radius * Math.cos(i * angle);
      points[pointIdx * 3 + 2] = model.radius * Math.sin(i * angle);
      if (model.capping) {
        polys[model.resolution - cellLocation++ + 1] = pointIdx;
      }
    }
    for (var _i = 0; _i < model.resolution; _i++) {
      polys[cellLocation++] = 3;
      polys[cellLocation++] = 0;
      polys[cellLocation++] = _i + 1;
      polys[cellLocation++] = _i + 2 > model.resolution ? 1 : _i + 2;
    }
    (_vtkMatrixBuilder$bui = vtkMatrixBuilder.buildFromRadian()).translate.apply(_vtkMatrixBuilder$bui, _toConsumableArray(model.center)).rotateFromDirections([1, 0, 0], model.direction).apply(points);
    dataset = vtkPolyData$1.newInstance();
    dataset.getPoints().setData(points, 3);
    dataset.getPolys().setData(polys, 1);
    outData[0] = dataset;
  }
  publicAPI.requestData = requestData;
}
var DEFAULT_VALUES = {
  height: 1,
  radius: 0.5,
  resolution: 6,
  center: [0, 0, 0],
  direction: [1, 0, 0],
  capping: true,
  pointType: "Float64Array"
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["height", "radius", "resolution", "capping"]);
  macro.setGetArray(publicAPI, model, ["center", "direction"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkConeSource(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkConeSource");
var vtkConeSource$1 = {
  newInstance,
  extend
};

// dep:@kitware_vtk__js_Filters_Sources_ConeSource
var kitware_vtk_js_Filters_Sources_ConeSource_default = vtkConeSource$1;
export {
  kitware_vtk_js_Filters_Sources_ConeSource_default as default,
  extend,
  newInstance
};
//# sourceMappingURL=@kitware_vtk__js_Filters_Sources_ConeSource.js.map
