{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js"],
  "sourcesContent": ["import macro from '../../macros.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkPiecewiseFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPiecewiseFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPiecewiseFunction'); // Return the number of points which specify this function\n\n  publicAPI.getSize = function () {\n    return model.nodes.length;\n  }; // Return the type of function stored in object:\n  // Function Types:\n  //    0 : Constant        (No change in slope between end points)\n  //    1 : NonDecreasing   (Always increasing or zero slope)\n  //    2 : NonIncreasing   (Always decreasing or zero slope)\n  //    3 : Varied          (Contains both decreasing and increasing slopes)\n  //    4 : Unknown         (Error condition)\n  //\n\n\n  publicAPI.getType = function () {\n    var value;\n    var prevValue = 0.0;\n    var functionType = 0;\n\n    if (model.nodes.length > 0) {\n      prevValue = model.nodes[0].y;\n    }\n\n    for (var i = 1; i < model.nodes.length; i++) {\n      value = model.nodes[i].y; // Do not change the function type if equal\n\n      if (value !== prevValue) {\n        if (value > prevValue) {\n          switch (functionType) {\n            case 0:\n            case 1:\n              // NonDecreasing\n              functionType = 1;\n              break;\n\n            case 2:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        } else {\n          // value < prev_value\n          switch (functionType) {\n            case 0:\n            case 2:\n              // NonIncreasing\n              functionType = 2;\n              break;\n\n            case 1:\n            default:\n              // Varied\n              functionType = 3;\n              break;\n          }\n        }\n      }\n\n      prevValue = value; // Exit loop if we find a Varied function\n\n      if (functionType === 3) {\n        break;\n      }\n    }\n\n    switch (functionType) {\n      case 0:\n        return 'Constant';\n\n      case 1:\n        return 'NonDecreasing';\n\n      case 2:\n        return 'NonIncreasing';\n\n      case 3:\n      default:\n        return 'Varied';\n    }\n  }; // Since we no longer store the data in an array, we must\n  // copy out of the vector into an array. No modified check -\n  // could be added if performance is a problem\n\n\n  publicAPI.getDataPointer = function () {\n    var size = model.nodes.length;\n    model.function = null;\n\n    if (size > 0) {\n      model.function = [];\n\n      for (var i = 0; i < size; i++) {\n        model.function[2 * i] = model.nodes[i].x;\n        model.function[2 * i + 1] = model.nodes[i].y;\n      }\n    }\n\n    return model.function;\n  }; // Returns the first point location which starts a non-zero segment of the\n  // function. Note that the value at this point may be zero.\n\n\n  publicAPI.getFirstNonZeroValue = function () {\n    // Check if no points specified\n    if (model.nodes.length === 0) {\n      return 0;\n    }\n\n    var allZero = 1;\n    var x = 0.0;\n    var i = 0;\n\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].y !== 0.0) {\n        allZero = 0;\n        break;\n      }\n    } // If every specified point has a zero value then return\n    // a large value\n\n\n    if (allZero) {\n      x = Number.MAX_VALUE;\n    } else if (i > 0) {\n      // A point was found with a non-zero value\n      // Return the value of the point that precedes this one\n      x = model.nodes[i - 1].x;\n    } else if (model.clamping) {\n      // If this is the first point in the function, return its\n      // value is clamping is off, otherwise VTK_DOUBLE_MIN if\n      // clamping is on.\n      x = -Number.MAX_VALUE;\n    } else {\n      x = model.nodes[0].x;\n    }\n\n    return x;\n  }; // For a specified index value, get the node parameters\n\n\n  publicAPI.getNodeValue = function (index, val) {\n    var size = model.nodes.length;\n\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].y;\n    val[2] = model.nodes[index].midpoint;\n    val[3] = model.nodes[index].sharpness;\n    return 1;\n  }; // For a specified index value, get the node parameters\n\n\n  publicAPI.setNodeValue = function (index, val) {\n    var size = model.nodes.length;\n\n    if (index < 0 || index >= size) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n\n    var oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].y = val[1];\n    model.nodes[index].midpoint = val[2];\n    model.nodes[index].sharpness = val[3];\n\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange(); // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n\n    return 1;\n  }; // Adds a point to the function. If a duplicate point is inserted\n  // then the function value at that location is set to the new value.\n  // This is the legacy version that assumes midpoint = 0.5 and\n  // sharpness = 0.0\n\n\n  publicAPI.addPoint = function (x, y) {\n    return publicAPI.addPointLong(x, y, 0.5, 0.0);\n  }; // Adds a point to the function and returns the array index of the point.\n\n\n  publicAPI.addPointLong = function (x, y, midpoint, sharpness) {\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    } // remove any node already at this X location\n\n\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    } // Create the new node\n\n\n    var node = {\n      x: x,\n      y: y,\n      midpoint: midpoint,\n      sharpness: sharpness\n    }; // Add it, then sort to get everything in order\n\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange(); // Now find this node so we can return the index\n\n    var i;\n\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    } // If we didn't find it, something went horribly wrong so\n    // return -1\n\n\n    if (i < model.nodes.length) {\n      return i;\n    }\n\n    return -1;\n  };\n\n  publicAPI.setNodes = function (nodes) {\n    if (model.nodes !== nodes) {\n      model.nodes = nodes;\n      publicAPI.sortAndUpdateRange();\n    }\n  }; // Sort the vector in increasing order, then fill in\n  // the Range\n\n\n  publicAPI.sortAndUpdateRange = function () {\n    model.nodes.sort(function (a, b) {\n      return a.x - b.x;\n    });\n    var modifiedInvoked = publicAPI.updateRange(); // If range is updated, Modified() has been called, don't call it again.\n\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.updateRange = function () {\n    var oldRange = model.range.slice();\n    var size = model.nodes.length;\n\n    if (size) {\n      model.range[0] = model.nodes[0].x;\n      model.range[1] = model.nodes[size - 1].x;\n    } else {\n      model.range[0] = 0;\n      model.range[1] = 0;\n    } // If the rage is the same, then no need to call Modified()\n\n\n    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {\n      return false;\n    }\n\n    publicAPI.modified();\n    return true;\n  }; // Removes a point from the function. If no point is found then function\n  // remains the same.\n\n\n  publicAPI.removePoint = function (x) {\n    // First find the node since we need to know its\n    // index as our return value\n    var i;\n\n    for (i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    } // If the node doesn't exist, we return -1\n\n\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n\n    var retVal = i; // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n\n    var modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n\n    return retVal;\n  }; // Removes all points from the function.\n\n\n  publicAPI.removeAllPoints = function () {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  }; // Add in end points of line and remove any points between them\n  // Legacy method with no way to specify midpoint and sharpness\n\n\n  publicAPI.addSegment = function (x1, y1, x2, y2) {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n\n    for (var i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    } // Now add the points\n\n\n    publicAPI.addPoint(x1, y1, 0.5, 0.0);\n    publicAPI.addPoint(x2, y2, 0.5, 0.0);\n  }; // Return the value of the function at a position\n\n\n  publicAPI.getValue = function (x) {\n    var table = [];\n    publicAPI.getTable(x, x, 1, table);\n    return table[0];\n  }; // Remove all points outside the range, and make sure a point\n  // exists at each end of the range. Used as a convenience method\n  // for transfer function editors\n\n\n  publicAPI.adjustRange = function (range) {\n    if (range.length < 2) {\n      return 0;\n    }\n\n    var functionRange = publicAPI.getRange(); // Make sure we have points at each end of the range\n\n    if (functionRange[0] < range[0]) {\n      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));\n    } else {\n      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));\n    }\n\n    if (functionRange[1] > range[1]) {\n      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));\n    } else {\n      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));\n    } // Remove all points out-of-range\n\n\n    publicAPI.sortAndUpdateRange();\n\n    for (var i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n\n    publicAPI.sortAndUpdateRange();\n    return 1;\n  }; //--------------------------------------------------------------------------\n\n\n  publicAPI.estimateMinNumberOfSamples = function (x1, x2) {\n    var d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.findMinimumXDistance = function () {\n    var size = model.nodes.length;\n\n    if (size < 2) {\n      return -1.0;\n    }\n\n    var distance = model.nodes[1].x - model.nodes[0].x;\n\n    for (var i = 0; i < size - 1; i++) {\n      var currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n\n    return distance;\n  }; // Returns a table of function values evaluated at regular intervals\n\n  /* eslint-disable prefer-destructuring */\n\n  /* eslint-disable no-continue */\n\n\n  publicAPI.getTable = function (xStart, xEnd, size, table) {\n    var stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    var i;\n    var idx = 0;\n    var numNodes = model.nodes.length; // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n\n    var lastValue = 0.0;\n\n    if (numNodes !== 0) {\n      lastValue = model.nodes[numNodes - 1].y;\n    }\n\n    var x = 0.0;\n    var x1 = 0.0;\n    var x2 = 0.0;\n    var y1 = 0.0;\n    var y2 = 0.0;\n    var midpoint = 0.0;\n    var sharpness = 0.0; // For each table entry\n\n    for (i = 0; i < size; i++) {\n      // Find our location in the table\n      var tidx = stride * i; // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n\n      if (size > 1) {\n        x = xStart + i / (size - 1.0) * (xEnd - xStart);\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      } // Do we need to move to the next node?\n\n\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++; // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          y1 = model.nodes[idx - 1].y;\n          y2 = model.nodes[idx].y; // We only need the previous midpoint and sharpness\n          // since these control this region\n\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness; // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      } // Are we at the end? If so, just use the last value\n\n\n      if (idx >= numNodes) {\n        table[tidx] = model.clamping ? lastValue : 0.0;\n      } else if (idx === 0) {\n        // Are we before the first node? If so, duplicate this nodes values\n        table[tidx] = model.clamping ? model.nodes[0].y : 0.0;\n      } else {\n        // Otherwise, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        var s = (x - x1) / (x2 - x1); // Readjust based on the midpoint - linear adjustment\n\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        } // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n\n\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = y1;\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = y2;\n            continue;\n          }\n        } // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n\n\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          table[tidx] = (1 - s) * y1 + s * y2;\n          continue;\n        } // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n\n\n        if (s < 0.5) {\n          s = 0.5 * Math.pow(s * 2, 1.0 + 10 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * Math.pow((1.0 - s) * 2, 1 + 10 * sharpness);\n        } // Compute some coefficients we will need for the hermite curve\n\n\n        var ss = s * s;\n        var sss = ss * s;\n        var h1 = 2 * sss - 3 * ss + 1;\n        var h2 = -2 * sss + 3 * ss;\n        var h3 = sss - 2 * ss + s;\n        var h4 = sss - ss; // Use one slope for both end points\n\n        var slope = y2 - y1;\n        var t = (1.0 - sharpness) * slope; // Compute the value\n\n        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t; // Final error check to make sure we don't go outside\n        // the Y range\n\n        var min = y1 < y2 ? y1 : y2;\n        var max = y1 > y2 ? y1 : y2;\n        table[tidx] = table[tidx] < min ? min : table[tidx];\n        table[tidx] = table[tidx] > max ? max : table[tidx];\n      }\n    }\n  };\n}\n/* eslint-enable prefer-destructuring */\n\n/* eslint-enable no-continue */\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  // model.function = NULL;\n  range: [0, 0],\n  clamping: true,\n  allowDuplicateScalars: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  macro.obj(publicAPI, model); // Internal objects initialization\n\n  model.nodes = []; // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['allowDuplicateScalars', 'clamping']);\n  macro.setArray(publicAPI, model, ['range'], 2); // Create get macros for array\n\n  macro.getArray(publicAPI, model, ['range']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkPiecewiseFunction(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkPiecewiseFunction'); // ----------------------------------------------------------------------------\n\nvar vtkPiecewiseFunction$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkPiecewiseFunction$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": []
}
