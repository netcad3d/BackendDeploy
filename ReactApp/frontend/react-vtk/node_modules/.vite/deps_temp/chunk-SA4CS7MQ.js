import {
  vtkScalarsToColors$1
} from "./chunk-MXMJXURM.js";
import {
  floor,
  hsv2rgb,
  isInf,
  isNan,
  lab2rgb,
  rgb2hsv,
  rgb2lab
} from "./chunk-FOWOP5PK.js";
import {
  macro
} from "./chunk-OTTIIP4A.js";
import {
  _defineProperty
} from "./chunk-HKWV5KNA.js";

// node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/Constants.js
var ColorSpace = {
  RGB: 0,
  HSV: 1,
  LAB: 2,
  DIVERGING: 3
};
var Scale = {
  LINEAR: 0,
  LOG10: 1
};
var Constants = {
  ColorSpace,
  Scale
};

// node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var ColorSpace2 = Constants.ColorSpace;
var Scale2 = Constants.Scale;
var ScalarMappingTarget = vtkScalarsToColors$1.ScalarMappingTarget;
var vtkDebugMacro = macro.vtkDebugMacro;
var vtkErrorMacro = macro.vtkErrorMacro;
var vtkWarningMacro = macro.vtkWarningMacro;
function vtkColorTransferFunctionLabToMsh(lab, msh) {
  var L = lab[0];
  var a = lab[1];
  var b = lab[2];
  var M = Math.sqrt(L * L + a * a + b * b);
  var s = M > 1e-3 ? Math.acos(L / M) : 0;
  var h = s > 1e-3 ? Math.atan2(b, a) : 0;
  msh[0] = M;
  msh[1] = s;
  msh[2] = h;
}
function vtkColorTransferFunctionMshToLab(msh, lab) {
  var M = msh[0];
  var s = msh[1];
  var h = msh[2];
  lab[0] = M * Math.cos(s);
  lab[1] = M * Math.sin(s) * Math.cos(h);
  lab[2] = M * Math.sin(s) * Math.sin(h);
}
function vtkColorTransferFunctionAdjustHue(msh, unsatM) {
  if (msh[0] >= unsatM - 0.1) {
    return msh[2];
  }
  var hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));
  if (msh[2] > -0.3 * Math.PI) {
    return msh[2] + hueSpin;
  }
  return msh[2] - hueSpin;
}
function vtkColorTransferFunctionAngleDiff(a1, a2) {
  var adiff = a1 - a2;
  if (adiff < 0) {
    adiff = -adiff;
  }
  while (adiff >= 2 * Math.PI) {
    adiff -= 2 * Math.PI;
  }
  if (adiff > Math.PI) {
    adiff = 2 * Math.PI - adiff;
  }
  return adiff;
}
function vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {
  var lab1 = [];
  var lab2 = [];
  rgb2lab(rgb1, lab1);
  rgb2lab(rgb2, lab2);
  var msh1 = [];
  var msh2 = [];
  vtkColorTransferFunctionLabToMsh(lab1, msh1);
  vtkColorTransferFunctionLabToMsh(lab2, msh2);
  var localS = s;
  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {
    var Mmid = Math.max(msh1[0], msh2[0]);
    Mmid = Math.max(88, Mmid);
    if (s < 0.5) {
      msh2[0] = Mmid;
      msh2[1] = 0;
      msh2[2] = 0;
      localS *= 2;
    } else {
      msh1[0] = Mmid;
      msh1[1] = 0;
      msh1[2] = 0;
      localS = 2 * localS - 1;
    }
  }
  if (msh1[1] < 0.05 && msh2[1] > 0.05) {
    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);
  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {
    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);
  }
  var mshTmp = [];
  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];
  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];
  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];
  var labTmp = [];
  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);
  lab2rgb(labTmp, result);
}
function vtkColorTransferFunction(publicAPI, model) {
  model.classHierarchy.push("vtkColorTransferFunction");
  publicAPI.getSize = function() {
    return model.nodes.length;
  };
  publicAPI.addRGBPoint = function(x, r, g, b) {
    return publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0);
  };
  publicAPI.addRGBPointLong = function(x, r, g, b) {
    var midpoint = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
    var sharpness = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
    if (midpoint < 0 || midpoint > 1) {
      vtkErrorMacro("Midpoint outside range [0.0, 1.0]");
      return -1;
    }
    if (sharpness < 0 || sharpness > 1) {
      vtkErrorMacro("Sharpness outside range [0.0, 1.0]");
      return -1;
    }
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }
    var node = {
      x,
      r,
      g,
      b,
      midpoint,
      sharpness
    };
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();
    var i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };
  publicAPI.addHSVPoint = function(x, h, s, v) {
    return publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0);
  };
  publicAPI.addHSVPointLong = function(x, h, s, v) {
    var midpoint = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
    var sharpness = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
    var rgb = [];
    var hsv = [h, s, v];
    hsv2rgb(hsv, rgb);
    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);
  };
  publicAPI.setNodes = function(nodes) {
    if (model.nodes !== nodes) {
      var before = JSON.stringify(model.nodes);
      model.nodes = nodes;
      var after = JSON.stringify(model.nodes);
      if (publicAPI.sortAndUpdateRange() || before !== after) {
        publicAPI.modified();
        return true;
      }
    }
    return false;
  };
  publicAPI.sortAndUpdateRange = function() {
    var before = JSON.stringify(model.nodes);
    model.nodes.sort(function(a, b) {
      return a.x - b.x;
    });
    var after = JSON.stringify(model.nodes);
    var modifiedInvoked = publicAPI.updateRange();
    if (!modifiedInvoked && before !== after) {
      publicAPI.modified();
      return true;
    }
    return modifiedInvoked;
  };
  publicAPI.updateRange = function() {
    var oldRange = [2];
    oldRange[0] = model.mappingRange[0];
    oldRange[1] = model.mappingRange[1];
    var size = model.nodes.length;
    if (size) {
      model.mappingRange[0] = model.nodes[0].x;
      model.mappingRange[1] = model.nodes[size - 1].x;
    } else {
      model.mappingRange[0] = 0;
      model.mappingRange[1] = 0;
    }
    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };
  publicAPI.removePoint = function(x) {
    var i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    var retVal = i;
    if (i >= model.nodes.length) {
      return -1;
    }
    var modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };
  publicAPI.movePoint = function(oldX, newX) {
    if (oldX === newX) {
      return;
    }
    publicAPI.removePoint(newX);
    for (var i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === oldX) {
        model.nodes[i].x = newX;
        publicAPI.sortAndUpdateRange();
        break;
      }
    }
  };
  publicAPI.removeAllPoints = function() {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.addRGBSegment = function(x1, r1, g1, b1, x2, r2, g2, b2) {
    publicAPI.sortAndUpdateRange();
    for (var i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }
    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0);
    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0);
    publicAPI.modified();
  };
  publicAPI.addHSVSegment = function(x1, h1, s1, v1, x2, h2, s2, v2) {
    var hsv1 = [h1, s1, v1];
    var hsv2 = [h2, s2, v2];
    var rgb1 = [];
    var rgb2 = [];
    hsv2rgb(hsv1, rgb1);
    hsv2rgb(hsv2, rgb2);
    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);
  };
  publicAPI.mapValue = function(x) {
    var rgb = [];
    publicAPI.getColor(x, rgb);
    return [Math.floor(255 * rgb[0] + 0.5), Math.floor(255 * rgb[1] + 0.5), Math.floor(255 * rgb[2] + 0.5), 255];
  };
  publicAPI.getColor = function(x, rgb) {
    if (model.indexedLookup) {
      var numNodes = publicAPI.getSize();
      var idx = publicAPI.getAnnotatedValueIndexInternal(x);
      if (idx < 0 || numNodes === 0) {
        publicAPI.getNanColor(rgb);
      } else {
        var nodeVal = [];
        publicAPI.getNodeValue(idx % numNodes, nodeVal);
        rgb[0] = nodeVal.r;
        rgb[1] = nodeVal.g;
        rgb[2] = nodeVal.b;
      }
      return;
    }
    publicAPI.getTable(x, x, 1, rgb);
  };
  publicAPI.getRedValue = function(x) {
    var rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[0];
  };
  publicAPI.getGreenValue = function(x) {
    var rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[1];
  };
  publicAPI.getBlueValue = function(x) {
    var rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[2];
  };
  publicAPI.getTable = function(xStart, xEnd, size, table) {
    if (isNan(xStart) || isNan(xEnd)) {
      for (var i = 0; i < size; i++) {
        table[i * 3 + 0] = model.nanColor[0];
        table[i * 3 + 1] = model.nanColor[1];
        table[i * 3 + 2] = model.nanColor[2];
      }
      return;
    }
    var idx = 0;
    var numNodes = model.nodes.length;
    var lastR = 0;
    var lastG = 0;
    var lastB = 0;
    if (numNodes !== 0) {
      lastR = model.nodes[numNodes - 1].r;
      lastG = model.nodes[numNodes - 1].g;
      lastB = model.nodes[numNodes - 1].b;
    }
    var x = 0;
    var x1 = 0;
    var x2 = 0;
    var rgb1 = [0, 0, 0];
    var rgb2 = [0, 0, 0];
    var midpoint = 0;
    var sharpness = 0;
    var tmpVec = [];
    var usingLogScale = model.scale === Scale2.LOG10;
    if (usingLogScale) {
      usingLogScale = model.mappingRange[0] > 0;
    }
    var logStart = 0;
    var logEnd = 0;
    var logX = 0;
    if (usingLogScale) {
      logStart = Math.log10(xStart);
      logEnd = Math.log10(xEnd);
    }
    for (var _i = 0; _i < size; _i++) {
      var tidx = 3 * _i;
      if (size > 1) {
        if (usingLogScale) {
          logX = logStart + _i / (size - 1) * (logEnd - logStart);
          x = Math.pow(10, logX);
        } else {
          x = xStart + _i / (size - 1) * (xEnd - xStart);
        }
      } else if (usingLogScale) {
        logX = 0.5 * (logStart + logEnd);
        x = Math.pow(10, logX);
      } else {
        x = 0.5 * (xStart + xEnd);
      }
      if (model.discretize) {
        var range = model.mappingRange;
        if (x >= range[0] && x <= range[1]) {
          var numberOfValues = model.numberOfValues;
          var deltaRange = range[1] - range[0];
          if (numberOfValues <= 1) {
            x = range[0] + deltaRange / 2;
          } else {
            var xn = (x - range[0]) / deltaRange;
            var discretizeIndex = floor(numberOfValues * xn);
            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;
          }
        }
      }
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          if (usingLogScale) {
            x1 = Math.log10(x1);
            x2 = Math.log10(x2);
          }
          rgb1[0] = model.nodes[idx - 1].r;
          rgb2[0] = model.nodes[idx].r;
          rgb1[1] = model.nodes[idx - 1].g;
          rgb2[1] = model.nodes[idx].g;
          rgb1[2] = model.nodes[idx - 1].b;
          rgb2[2] = model.nodes[idx].b;
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;
          if (midpoint < 1e-5) {
            midpoint = 1e-5;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }
      if (x > model.mappingRange[1]) {
        table[tidx] = 0;
        table[tidx + 1] = 0;
        table[tidx + 2] = 0;
        if (model.clamping) {
          if (publicAPI.getUseAboveRangeColor()) {
            table[tidx] = model.aboveRangeColor[0];
            table[tidx + 1] = model.aboveRangeColor[1];
            table[tidx + 2] = model.aboveRangeColor[2];
          } else {
            table[tidx] = lastR;
            table[tidx + 1] = lastG;
            table[tidx + 2] = lastB;
          }
        }
      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {
        table[tidx] = 0;
        table[tidx + 1] = 0;
        table[tidx + 2] = 0;
        if (model.clamping) {
          if (publicAPI.getUseBelowRangeColor()) {
            table[tidx] = model.belowRangeColor[0];
            table[tidx + 1] = model.belowRangeColor[1];
            table[tidx + 2] = model.belowRangeColor[2];
          } else if (numNodes > 0) {
            table[tidx] = model.nodes[0].r;
            table[tidx + 1] = model.nodes[0].g;
            table[tidx + 2] = model.nodes[0].b;
          }
        }
      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {
        if (numNodes > 0) {
          table[tidx] = model.nodes[0].r;
          table[tidx + 1] = model.nodes[0].g;
          table[tidx + 2] = model.nodes[0].b;
        } else {
          table[tidx] = 0;
          table[tidx + 1] = 0;
          table[tidx + 2] = 0;
        }
      } else {
        var s = 0;
        if (usingLogScale) {
          s = (logX - x1) / (x2 - x1);
        } else {
          s = (x - x1) / (x2 - x1);
        }
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1 - midpoint);
        }
        if (sharpness > 0.99) {
          if (s < 0.5) {
            table[tidx] = rgb1[0];
            table[tidx + 1] = rgb1[1];
            table[tidx + 2] = rgb1[2];
            continue;
          } else {
            table[tidx] = rgb2[0];
            table[tidx + 1] = rgb2[1];
            table[tidx + 2] = rgb2[2];
            continue;
          }
        }
        if (sharpness < 0.01) {
          if (model.colorSpace === ColorSpace2.RGB) {
            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];
            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];
            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];
          } else if (model.colorSpace === ColorSpace2.HSV) {
            var hsv1 = [];
            var hsv2 = [];
            rgb2hsv(rgb1, hsv1);
            rgb2hsv(rgb2, hsv2);
            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {
              if (hsv1[0] > hsv2[0]) {
                hsv1[0] -= 1;
              } else {
                hsv2[0] -= 1;
              }
            }
            var hsvTmp = [];
            hsvTmp[0] = (1 - s) * hsv1[0] + s * hsv2[0];
            if (hsvTmp[0] < 0) {
              hsvTmp[0] += 1;
            }
            hsvTmp[1] = (1 - s) * hsv1[1] + s * hsv2[1];
            hsvTmp[2] = (1 - s) * hsv1[2] + s * hsv2[2];
            hsv2rgb(hsvTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace2.LAB) {
            var lab1 = [];
            var lab2 = [];
            rgb2lab(rgb1, lab1);
            rgb2lab(rgb2, lab2);
            var labTmp = [];
            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];
            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];
            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];
            lab2rgb(labTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace2.DIVERGING) {
            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else {
            vtkErrorMacro("ColorSpace set to invalid value.", model.colorSpace);
          }
          continue;
        }
        if (s < 0.5) {
          s = 0.5 * Math.pow(s * 2, 1 + 10 * sharpness);
        } else if (s > 0.5) {
          s = 1 - 0.5 * Math.pow((1 - s) * 2, 1 + 10 * sharpness);
        }
        var ss = s * s;
        var sss = ss * s;
        var h1 = 2 * sss - 3 * ss + 1;
        var h2 = -2 * sss + 3 * ss;
        var h3 = sss - 2 * ss + s;
        var h4 = sss - ss;
        var slope = void 0;
        var t = void 0;
        if (model.colorSpace === ColorSpace2.RGB) {
          for (var j = 0; j < 3; j++) {
            slope = rgb2[j] - rgb1[j];
            t = (1 - sharpness) * slope;
            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;
          }
        } else if (model.colorSpace === ColorSpace2.HSV) {
          var _hsv = [];
          var _hsv2 = [];
          rgb2hsv(rgb1, _hsv);
          rgb2hsv(rgb2, _hsv2);
          if (model.hSVWrap && (_hsv[0] - _hsv2[0] > 0.5 || _hsv2[0] - _hsv[0] > 0.5)) {
            if (_hsv[0] > _hsv2[0]) {
              _hsv[0] -= 1;
            } else {
              _hsv2[0] -= 1;
            }
          }
          var _hsvTmp = [];
          for (var _j = 0; _j < 3; _j++) {
            slope = _hsv2[_j] - _hsv[_j];
            t = (1 - sharpness) * slope;
            _hsvTmp[_j] = h1 * _hsv[_j] + h2 * _hsv2[_j] + h3 * t + h4 * t;
            if (_j === 0 && _hsvTmp[_j] < 0) {
              _hsvTmp[_j] += 1;
            }
          }
          hsv2rgb(_hsvTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorSpace2.LAB) {
          var _lab = [];
          var _lab2 = [];
          rgb2lab(rgb1, _lab);
          rgb2lab(rgb2, _lab2);
          var _labTmp = [];
          for (var _j2 = 0; _j2 < 3; _j2++) {
            slope = _lab2[_j2] - _lab[_j2];
            t = (1 - sharpness) * slope;
            _labTmp[_j2] = h1 * _lab[_j2] + h2 * _lab2[_j2] + h3 * t + h4 * t;
          }
          lab2rgb(_labTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorSpace2.DIVERGING) {
          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else {
          vtkErrorMacro("ColorSpace set to invalid value.");
        }
        for (var _j3 = 0; _j3 < 3; _j3++) {
          table[tidx + _j3] = table[tidx + _j3] < 0 ? 0 : table[tidx + _j3];
          table[tidx + _j3] = table[tidx + _j3] > 1 ? 1 : table[tidx + _j3];
        }
      }
    }
  };
  publicAPI.getUint8Table = function(xStart, xEnd, size) {
    var withAlpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {
      return model.table;
    }
    if (model.nodes.length === 0) {
      vtkErrorMacro("Attempting to lookup a value with no points in the function");
      return model.table;
    }
    var nbChannels = withAlpha ? 4 : 3;
    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {
      model.table = new Uint8Array(size * nbChannels);
      model.tableSize = size;
      model.tableWithAlpha = withAlpha;
    }
    var tmpTable = [];
    publicAPI.getTable(xStart, xEnd, size, tmpTable);
    for (var i = 0; i < size; i++) {
      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255 + 0.5);
      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255 + 0.5);
      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255 + 0.5);
      if (withAlpha) {
        model.table[i * nbChannels + 3] = 255;
      }
    }
    model.buildTime.modified();
    return model.table;
  };
  publicAPI.buildFunctionFromTable = function(xStart, xEnd, size, table) {
    var inc = 0;
    publicAPI.removeAllPoints();
    if (size > 1) {
      inc = (xEnd - xStart) / (size - 1);
    }
    for (var i = 0; i < size; i++) {
      var node = {
        x: xStart + inc * i,
        r: table[i * 3],
        g: table[i * 3 + 1],
        b: table[i * 3 + 2],
        sharpness: 0,
        midpoint: 0.5
      };
      model.nodes.push(node);
    }
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.getNodeValue = function(index, val) {
    if (index < 0 || index >= model.nodes.length) {
      vtkErrorMacro("Index out of range!");
      return -1;
    }
    val[0] = model.nodes[index].x;
    val[1] = model.nodes[index].r;
    val[2] = model.nodes[index].g;
    val[3] = model.nodes[index].b;
    val[4] = model.nodes[index].midpoint;
    val[5] = model.nodes[index].sharpness;
    return 1;
  };
  publicAPI.setNodeValue = function(index, val) {
    if (index < 0 || index >= model.nodes.length) {
      vtkErrorMacro("Index out of range!");
      return -1;
    }
    var oldX = model.nodes[index].x;
    model.nodes[index].x = val[0];
    model.nodes[index].r = val[1];
    model.nodes[index].g = val[2];
    model.nodes[index].b = val[3];
    model.nodes[index].midpoint = val[4];
    model.nodes[index].sharpness = val[5];
    if (oldX !== val[0]) {
      publicAPI.sortAndUpdateRange();
    } else {
      publicAPI.modified();
    }
    return 1;
  };
  publicAPI.getNumberOfAvailableColors = function() {
    if (model.indexedLookup && publicAPI.getSize()) {
      return publicAPI.getSize();
    }
    if (model.tableSize) {
      return model.tableSize;
    }
    return 16777216;
  };
  publicAPI.getIndexedColor = function(idx, rgba) {
    var n = publicAPI.getSize();
    if (n > 0 && idx >= 0) {
      var nodeValue = [];
      publicAPI.getNodeValue(idx % n, nodeValue);
      for (var j = 0; j < 3; ++j) {
        rgba[j] = nodeValue[j + 1];
      }
      rgba[3] = 1;
      return;
    }
    publicAPI.getNanColor(rgba);
    rgba[3] = 1;
  };
  publicAPI.fillFromDataPointer = function(nb, ptr) {
    if (nb <= 0 || !ptr) {
      return;
    }
    publicAPI.removeAllPoints();
    for (var i = 0; i < nb; i++) {
      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);
    }
  };
  publicAPI.setMappingRange = function(min, max) {
    var range = [min, max];
    var originalRange = publicAPI.getRange();
    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {
      return;
    }
    if (range[1] === range[0]) {
      vtkErrorMacro("attempt to set zero width color range");
      return;
    }
    var scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);
    var shift = range[0] - originalRange[0] * scale;
    for (var i = 0; i < model.nodes.length; ++i) {
      model.nodes[i].x = model.nodes[i].x * scale + shift;
    }
    model.mappingRange[0] = range[0];
    model.mappingRange[1] = range[1];
    publicAPI.modified();
  };
  publicAPI.adjustRange = function(range) {
    var functionRange = publicAPI.getRange();
    var rgb = [];
    if (functionRange[0] < range[0]) {
      publicAPI.getColor(range[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    }
    if (functionRange[1] > range[1]) {
      publicAPI.getColor(range[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    }
    publicAPI.sortAndUpdateRange();
    for (var i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    return 1;
  };
  publicAPI.estimateMinNumberOfSamples = function(x1, x2) {
    var d = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d);
  };
  publicAPI.findMinimumXDistance = function() {
    if (model.nodes.length < 2) {
      return -1;
    }
    var distance = Number.MAX_VALUE;
    for (var i = 0; i < model.nodes.length - 1; i++) {
      var currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance) {
        distance = currentDist;
      }
    }
    return distance;
  };
  publicAPI.mapScalarsThroughTable = function(input, output, outFormat, inputOffset) {
    if (publicAPI.getSize() === 0) {
      vtkDebugMacro("Transfer Function Has No Points!");
      return;
    }
    if (model.indexedLookup) {
      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);
    } else {
      publicAPI.mapData(input, output, outFormat, inputOffset);
    }
  };
  publicAPI.mapData = function(input, output, outFormat, inputOffset) {
    if (publicAPI.getSize() === 0) {
      vtkWarningMacro("Transfer Function Has No Points!");
      return;
    }
    var alpha = Math.floor(publicAPI.getAlpha() * 255 + 0.5);
    var length = input.getNumberOfTuples();
    var inIncr = input.getNumberOfComponents();
    var outputV = output.getData();
    var inputV = input.getData();
    var rgb = [];
    if (outFormat === ScalarMappingTarget.RGBA) {
      for (var i = 0; i < length; i++) {
        var x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 4] = Math.floor(rgb[0] * 255 + 0.5);
        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255 + 0.5);
        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255 + 0.5);
        outputV[i * 4 + 3] = alpha;
      }
    }
    if (outFormat === ScalarMappingTarget.RGB) {
      for (var _i2 = 0; _i2 < length; _i2++) {
        var _x = inputV[_i2 * inIncr + inputOffset];
        publicAPI.getColor(_x, rgb);
        outputV[_i2 * 3] = Math.floor(rgb[0] * 255 + 0.5);
        outputV[_i2 * 3 + 1] = Math.floor(rgb[1] * 255 + 0.5);
        outputV[_i2 * 3 + 2] = Math.floor(rgb[2] * 255 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget.LUMINANCE) {
      for (var _i3 = 0; _i3 < length; _i3++) {
        var _x2 = inputV[_i3 * inIncr + inputOffset];
        publicAPI.getColor(_x2, rgb);
        outputV[_i3] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {
      for (var _i4 = 0; _i4 < length; _i4++) {
        var _x3 = inputV[_i4 * inIncr + inputOffset];
        publicAPI.getColor(_x3, rgb);
        outputV[_i4 * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
        outputV[_i4 * 2 + 1] = alpha;
      }
    }
  };
  publicAPI.applyColorMap = function(colorMap) {
    if (colorMap.ColorSpace) {
      model.colorSpace = ColorSpace2[colorMap.ColorSpace.toUpperCase()];
      if (model.colorSpace === void 0) {
        vtkErrorMacro("ColorSpace ".concat(colorMap.ColorSpace, " not supported, using RGB instead"));
        model.colorSpace = ColorSpace2.RGB;
      }
    }
    if (colorMap.NanColor) {
      model.nanColor = [].concat(colorMap.NanColor);
      while (model.nanColor.length < 4) {
        model.nanColor.push(1);
      }
    }
    if (colorMap.RGBPoints) {
      var size = colorMap.RGBPoints.length;
      model.nodes = [];
      var midpoint = 0.5;
      var sharpness = 0;
      for (var i = 0; i < size; i += 4) {
        model.nodes.push({
          x: colorMap.RGBPoints[i],
          r: colorMap.RGBPoints[i + 1],
          g: colorMap.RGBPoints[i + 2],
          b: colorMap.RGBPoints[i + 3],
          midpoint,
          sharpness
        });
      }
    }
    publicAPI.sortAndUpdateRange();
  };
}
var DEFAULT_VALUES = {
  clamping: true,
  colorSpace: ColorSpace2.RGB,
  hSVWrap: true,
  scale: Scale2.LINEAR,
  nanColor: null,
  belowRangeColor: null,
  aboveRangeColor: null,
  useAboveRangeColor: false,
  useBelowRangeColor: false,
  allowDuplicateScalars: false,
  table: null,
  tableSize: 0,
  buildTime: null,
  nodes: null,
  discretize: false,
  numberOfValues: 256
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  vtkScalarsToColors$1.extend(publicAPI, model, initialValues);
  model.table = [];
  model.nodes = [];
  model.nanColor = [0.5, 0, 0, 1];
  model.belowRangeColor = [0, 0, 0, 1];
  model.aboveRangeColor = [1, 1, 1, 1];
  model.buildTime = {};
  macro.obj(model.buildTime);
  macro.get(publicAPI, model, ["buildTime", "mappingRange"]);
  macro.setGet(publicAPI, model, ["useAboveRangeColor", "useBelowRangeColor", "colorSpace", "discretize", "numberOfValues"]);
  macro.setArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"], 4);
  macro.getArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"]);
  vtkColorTransferFunction(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkColorTransferFunction");
var vtkColorTransferFunction$1 = _objectSpread({
  newInstance,
  extend
}, Constants);

export {
  extend,
  newInstance,
  vtkColorTransferFunction$1
};
//# sourceMappingURL=chunk-SA4CS7MQ.js.map
