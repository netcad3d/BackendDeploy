import {
  mat4_exports,
  quat_exports,
  vec3_exports,
  vec4_exports
} from "./chunk-GC37RKNO.js";
import {
  vtkBoundingBox
} from "./chunk-IC3JHQHE.js";
import {
  add,
  areBoundsInitialized,
  createUninitializedBounds,
  cross,
  dot,
  normalize,
  radiansFromDegrees,
  uninitializeBounds
} from "./chunk-FOWOP5PK.js";
import {
  _toConsumableArray,
  get,
  getArray,
  macro,
  moveToProtected,
  newInstance,
  setGet,
  setGetArray,
  vtkDebugMacro,
  vtkErrorMacro,
  vtkWarningMacro
} from "./chunk-OTTIIP4A.js";

// node_modules/@kitware/vtk.js/Rendering/Core/Camera.js
var vtkDebugMacro2 = macro.vtkDebugMacro;
function vtkCamera(publicAPI, model) {
  model.classHierarchy.push("vtkCamera");
  var origin = new Float64Array(3);
  var dopbasis = new Float64Array([0, 0, -1]);
  var upbasis = new Float64Array([0, 1, 0]);
  var tmpMatrix = mat4_exports.identity(new Float64Array(16));
  var tmpMatrix2 = mat4_exports.identity(new Float64Array(16));
  var tmpvec1 = new Float64Array(3);
  var tmpvec2 = new Float64Array(3);
  var tmpvec3 = new Float64Array(3);
  var rotateMatrix = mat4_exports.identity(new Float64Array(16));
  var trans = mat4_exports.identity(new Float64Array(16));
  var newPosition = new Float64Array(3);
  var newFocalPoint = new Float64Array(3);
  function computeViewPlaneNormal() {
    model.viewPlaneNormal[0] = -model.directionOfProjection[0];
    model.viewPlaneNormal[1] = -model.directionOfProjection[1];
    model.viewPlaneNormal[2] = -model.directionOfProjection[2];
  }
  publicAPI.orthogonalizeViewUp = function() {
    var vt = publicAPI.getViewMatrix();
    model.viewUp[0] = vt[4];
    model.viewUp[1] = vt[5];
    model.viewUp[2] = vt[6];
    publicAPI.modified();
  };
  publicAPI.setPosition = function(x, y, z) {
    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {
      return;
    }
    model.position[0] = x;
    model.position[1] = y;
    model.position[2] = z;
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setFocalPoint = function(x, y, z) {
    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {
      return;
    }
    model.focalPoint[0] = x;
    model.focalPoint[1] = y;
    model.focalPoint[2] = z;
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setDistance = function(d) {
    if (model.distance === d) {
      return;
    }
    model.distance = d;
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro2("Distance is set to minimum.");
    }
    var vec = model.directionOfProjection;
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    publicAPI.modified();
  };
  publicAPI.computeDistance = function() {
    var dx = model.focalPoint[0] - model.position[0];
    var dy = model.focalPoint[1] - model.position[1];
    var dz = model.focalPoint[2] - model.position[2];
    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro2("Distance is set to minimum.");
      var vec = model.directionOfProjection;
      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    }
    model.directionOfProjection[0] = dx / model.distance;
    model.directionOfProjection[1] = dy / model.distance;
    model.directionOfProjection[2] = dz / model.distance;
    computeViewPlaneNormal();
  };
  publicAPI.dolly = function(amount) {
    if (amount <= 0) {
      return;
    }
    var d = model.distance / amount;
    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);
  };
  publicAPI.roll = function(angle) {
    var eye = model.position;
    var at = model.focalPoint;
    var up = model.viewUp;
    var viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0]);
    mat4_exports.identity(rotateMatrix);
    var viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);
    mat4_exports.rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle), viewDir);
    vec4_exports.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);
    model.viewUp[0] = viewUpVec4[0];
    model.viewUp[1] = viewUpVec4[1];
    model.viewUp[2] = viewUpVec4[2];
    publicAPI.modified();
  };
  publicAPI.azimuth = function(angle) {
    var fp = model.focalPoint;
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, fp);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);
    mat4_exports.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
    vec3_exports.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.yaw = function(angle) {
    var position = model.position;
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, position);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);
    mat4_exports.translate(trans, trans, [-position[0], -position[1], -position[2]]);
    vec3_exports.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);
  };
  publicAPI.elevation = function(angle) {
    var fp = model.focalPoint;
    var vt = publicAPI.getViewMatrix();
    var axis = [-vt[0], -vt[1], -vt[2]];
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, fp);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle), axis);
    mat4_exports.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
    vec3_exports.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.pitch = function(angle) {
    var position = model.position;
    var vt = publicAPI.getViewMatrix();
    var axis = [vt[0], vt[1], vt[2]];
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, position);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle), axis);
    mat4_exports.translate(trans, trans, [-position[0], -position[1], -position[2]]);
    vec3_exports.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint.apply(publicAPI, _toConsumableArray(newFocalPoint));
  };
  publicAPI.zoom = function(factor) {
    if (factor <= 0) {
      return;
    }
    if (model.parallelProjection) {
      model.parallelScale /= factor;
    } else {
      model.viewAngle /= factor;
    }
    publicAPI.modified();
  };
  publicAPI.translate = function(x, y, z) {
    var offset = [x, y, z];
    add(model.position, offset, model.position);
    add(model.focalPoint, offset, model.focalPoint);
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.applyTransform = function(transformMat4) {
    var vuOld = [].concat(_toConsumableArray(model.viewUp), [1]);
    var posNew = [];
    var fpNew = [];
    var vuNew = [];
    vuOld[0] += model.position[0];
    vuOld[1] += model.position[1];
    vuOld[2] += model.position[2];
    vec4_exports.transformMat4(posNew, [].concat(_toConsumableArray(model.position), [1]), transformMat4);
    vec4_exports.transformMat4(fpNew, [].concat(_toConsumableArray(model.focalPoint), [1]), transformMat4);
    vec4_exports.transformMat4(vuNew, vuOld, transformMat4);
    vuNew[0] -= posNew[0];
    vuNew[1] -= posNew[1];
    vuNew[2] -= posNew[2];
    publicAPI.setPosition.apply(publicAPI, _toConsumableArray(posNew.slice(0, 3)));
    publicAPI.setFocalPoint.apply(publicAPI, _toConsumableArray(fpNew.slice(0, 3)));
    publicAPI.setViewUp.apply(publicAPI, _toConsumableArray(vuNew.slice(0, 3)));
  };
  publicAPI.getThickness = function() {
    return model.clippingRange[1] - model.clippingRange[0];
  };
  publicAPI.setThickness = function(thickness) {
    var t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro2("Thickness is set to minimum.");
    }
    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);
  };
  publicAPI.setThicknessFromFocalPoint = function(thickness) {
    var t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro2("Thickness is set to minimum.");
    }
    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);
  };
  publicAPI.setRoll = function(angle) {
  };
  publicAPI.getRoll = function() {
  };
  publicAPI.setObliqueAngles = function(alpha, beta) {
  };
  publicAPI.getOrientation = function() {
  };
  publicAPI.getOrientationWXYZ = function() {
  };
  publicAPI.getFrustumPlanes = function(aspect) {
  };
  publicAPI.getCameraLightTransformMatrix = function(matrix) {
    mat4_exports.copy(matrix, model.cameraLightTransform);
    return matrix;
  };
  publicAPI.computeCameraLightTransform = function() {
    mat4_exports.copy(tmpMatrix, publicAPI.getViewMatrix());
    mat4_exports.invert(tmpMatrix, tmpMatrix);
    mat4_exports.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);
    mat4_exports.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);
    mat4_exports.identity(model.cameraLightTransform);
    mat4_exports.translate(model.cameraLightTransform, tmpMatrix, [0, 0, -1]);
  };
  publicAPI.deepCopy = function(sourceCamera) {
  };
  publicAPI.physicalOrientationToWorldDirection = function(ori) {
    var oriq = quat_exports.fromValues(ori[0], ori[1], ori[2], ori[3]);
    var coriq = quat_exports.create();
    var qdir = quat_exports.fromValues(0, 0, 1, 0);
    quat_exports.conjugate(coriq, oriq);
    quat_exports.multiply(qdir, oriq, qdir);
    quat_exports.multiply(qdir, qdir, coriq);
    return [qdir[0], qdir[1], qdir[2]];
  };
  publicAPI.getPhysicalToWorldMatrix = function(result) {
    publicAPI.getWorldToPhysicalMatrix(result);
    mat4_exports.invert(result, result);
  };
  publicAPI.getWorldToPhysicalMatrix = function(result) {
    mat4_exports.identity(result);
    var physVRight = [3];
    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);
    result[0] = physVRight[0];
    result[1] = physVRight[1];
    result[2] = physVRight[2];
    result[4] = model.physicalViewUp[0];
    result[5] = model.physicalViewUp[1];
    result[6] = model.physicalViewUp[2];
    result[8] = -model.physicalViewNorth[0];
    result[9] = -model.physicalViewNorth[1];
    result[10] = -model.physicalViewNorth[2];
    mat4_exports.transpose(result, result);
    vec3_exports.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);
    mat4_exports.scale(result, result, tmpvec1);
    mat4_exports.translate(result, result, model.physicalTranslation);
  };
  publicAPI.computeViewParametersFromViewMatrix = function(vmat) {
    mat4_exports.invert(tmpMatrix, vmat);
    vec3_exports.transformMat4(tmpvec1, origin, tmpMatrix);
    publicAPI.computeDistance();
    var oldDist = model.distance;
    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);
    vec3_exports.transformMat4(tmpvec2, dopbasis, tmpMatrix);
    vec3_exports.subtract(tmpvec2, tmpvec2, tmpvec1);
    vec3_exports.normalize(tmpvec2, tmpvec2);
    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);
    vec3_exports.transformMat4(tmpvec3, upbasis, tmpMatrix);
    vec3_exports.subtract(tmpvec3, tmpvec3, tmpvec1);
    vec3_exports.normalize(tmpvec3, tmpvec3);
    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);
    publicAPI.setDistance(oldDist);
  };
  publicAPI.computeViewParametersFromPhysicalMatrix = function(mat) {
    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);
    mat4_exports.multiply(tmpMatrix, mat, tmpMatrix);
    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
  };
  publicAPI.setViewMatrix = function(mat) {
    model.viewMatrix = mat;
    if (model.viewMatrix) {
      mat4_exports.copy(tmpMatrix, model.viewMatrix);
      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
      mat4_exports.transpose(model.viewMatrix, model.viewMatrix);
    }
  };
  publicAPI.getViewMatrix = function() {
    if (model.viewMatrix) {
      return model.viewMatrix;
    }
    mat4_exports.lookAt(
      tmpMatrix,
      model.position,
      model.focalPoint,
      model.viewUp
    );
    mat4_exports.transpose(tmpMatrix, tmpMatrix);
    var result = new Float64Array(16);
    mat4_exports.copy(result, tmpMatrix);
    return result;
  };
  publicAPI.setProjectionMatrix = function(mat) {
    model.projectionMatrix = mat;
  };
  publicAPI.getProjectionMatrix = function(aspect, nearz, farz) {
    var result = new Float64Array(16);
    mat4_exports.identity(result);
    if (model.projectionMatrix) {
      var scale = 1 / model.physicalScale;
      vec3_exports.set(tmpvec1, scale, scale, scale);
      mat4_exports.copy(result, model.projectionMatrix);
      mat4_exports.scale(result, result, tmpvec1);
      mat4_exports.transpose(result, result);
      return result;
    }
    mat4_exports.identity(tmpMatrix);
    var cWidth = model.clippingRange[1] - model.clippingRange[0];
    var cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2, model.clippingRange[0] + (farz + 1) * cWidth / 2];
    if (model.parallelProjection) {
      var width = model.parallelScale * aspect;
      var height = model.parallelScale;
      var xmin = (model.windowCenter[0] - 1) * width;
      var xmax = (model.windowCenter[0] + 1) * width;
      var ymin = (model.windowCenter[1] - 1) * height;
      var ymax = (model.windowCenter[1] + 1) * height;
      mat4_exports.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
      mat4_exports.transpose(tmpMatrix, tmpMatrix);
    } else if (model.useOffAxisProjection) {
      throw new Error("Off-Axis projection is not supported at this time");
    } else {
      var tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2);
      var _width;
      var _height;
      if (model.useHorizontalViewAngle === true) {
        _width = model.clippingRange[0] * tmp;
        _height = model.clippingRange[0] * tmp / aspect;
      } else {
        _width = model.clippingRange[0] * tmp * aspect;
        _height = model.clippingRange[0] * tmp;
      }
      var _xmin = (model.windowCenter[0] - 1) * _width;
      var _xmax = (model.windowCenter[0] + 1) * _width;
      var _ymin = (model.windowCenter[1] - 1) * _height;
      var _ymax = (model.windowCenter[1] + 1) * _height;
      var znear = cRange[0];
      var zfar = cRange[1];
      tmpMatrix[0] = 2 * znear / (_xmax - _xmin);
      tmpMatrix[5] = 2 * znear / (_ymax - _ymin);
      tmpMatrix[2] = (_xmin + _xmax) / (_xmax - _xmin);
      tmpMatrix[6] = (_ymin + _ymax) / (_ymax - _ymin);
      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
      tmpMatrix[14] = -1;
      tmpMatrix[11] = -2 * znear * zfar / (zfar - znear);
      tmpMatrix[15] = 0;
    }
    mat4_exports.copy(result, tmpMatrix);
    return result;
  };
  publicAPI.getCompositeProjectionMatrix = function(aspect, nearz, farz) {
    var vMat = publicAPI.getViewMatrix();
    var pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);
    mat4_exports.multiply(pMat, vMat, pMat);
    return pMat;
  };
  publicAPI.setDirectionOfProjection = function(x, y, z) {
    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {
      return;
    }
    model.directionOfProjection[0] = x;
    model.directionOfProjection[1] = y;
    model.directionOfProjection[2] = z;
    var vec = model.directionOfProjection;
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    computeViewPlaneNormal();
  };
  publicAPI.setDeviceAngles = function(alpha, beta, gamma, screen) {
    var physVRight = [3];
    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);
    var rotmat = mat4_exports.identity(new Float64Array(16));
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(gamma), model.physicalViewNorth);
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);
    var dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);
    var vup = new Float64Array(model.physicalViewNorth);
    vec3_exports.transformMat4(dop, dop, rotmat);
    vec3_exports.transformMat4(vup, vup, rotmat);
    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);
    publicAPI.setViewUp(vup[0], vup[1], vup[2]);
    publicAPI.modified();
  };
  publicAPI.setOrientationWXYZ = function(degrees, x, y, z) {
    var quatMat = mat4_exports.identity(new Float64Array(16));
    if (degrees !== 0 && (x !== 0 || y !== 0 || z !== 0)) {
      var angle = radiansFromDegrees(degrees);
      var q = quat_exports.create();
      quat_exports.setAxisAngle(q, [x, y, z], angle);
      mat4_exports.fromQuat(quatMat, q);
    }
    var newdop = new Float64Array(3);
    vec3_exports.transformMat4(newdop, [0, 0, -1], quatMat);
    var newvup = new Float64Array(3);
    vec3_exports.transformMat4(newvup, [0, 1, 0], quatMat);
    publicAPI.setDirectionOfProjection.apply(publicAPI, _toConsumableArray(newdop));
    publicAPI.setViewUp.apply(publicAPI, _toConsumableArray(newvup));
    publicAPI.modified();
  };
  publicAPI.computeClippingRange = function(bounds) {
    var vn = null;
    var position = null;
    vn = model.viewPlaneNormal;
    position = model.position;
    var a = -vn[0];
    var b = -vn[1];
    var c = -vn[2];
    var d = -(a * position[0] + b * position[1] + c * position[2]);
    var range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];
    for (var k = 0; k < 2; k++) {
      for (var j = 0; j < 2; j++) {
        for (var i = 0; i < 2; i++) {
          var dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;
          range[0] = dist < range[0] ? dist : range[0];
          range[1] = dist > range[1] ? dist : range[1];
        }
      }
    }
    return range;
  };
}
var DEFAULT_VALUES = {
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  viewUp: [0, 1, 0],
  directionOfProjection: [0, 0, -1],
  parallelProjection: false,
  useHorizontalViewAngle: false,
  viewAngle: 30,
  parallelScale: 1,
  clippingRange: [0.01, 1000.01],
  windowCenter: [0, 0],
  viewPlaneNormal: [0, 0, 1],
  useOffAxisProjection: false,
  screenBottomLeft: [-0.5, -0.5, -0.5],
  screenBottomRight: [0.5, -0.5, -0.5],
  screenTopRight: [0.5, 0.5, -0.5],
  freezeFocalPoint: false,
  projectionMatrix: null,
  viewMatrix: null,
  cameraLightTransform: mat4_exports.create(),
  physicalTranslation: [0, 0, 0],
  physicalScale: 1,
  physicalViewUp: [0, 1, 0],
  physicalViewNorth: [0, 0, -1]
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["distance"]);
  macro.setGet(publicAPI, model, ["parallelProjection", "useHorizontalViewAngle", "viewAngle", "parallelScale", "useOffAxisProjection", "freezeFocalPoint", "physicalScale"]);
  macro.getArray(publicAPI, model, ["directionOfProjection", "viewPlaneNormal", "position", "focalPoint"]);
  macro.setGetArray(publicAPI, model, ["clippingRange", "windowCenter"], 2);
  macro.setGetArray(publicAPI, model, ["viewUp", "screenBottomLeft", "screenBottomRight", "screenTopRight", "physicalTranslation", "physicalViewUp", "physicalViewNorth"], 3);
  vtkCamera(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend, "vtkCamera");
var vtkCamera$1 = {
  newInstance: newInstance2,
  extend
};

// node_modules/@kitware/vtk.js/Rendering/Core/Light.js
var LIGHT_TYPES = ["HeadLight", "CameraLight", "SceneLight"];
function vtkLight(publicAPI, model) {
  model.classHierarchy.push("vtkLight");
  var tmpVec = new Float64Array(3);
  publicAPI.getTransformedPosition = function() {
    if (model.transformMatrix) {
      vec3_exports.transformMat4(tmpVec, model.position, model.transformMatrix);
    } else {
      vec3_exports.set(tmpVec, model.position[0], model.position[1], model.position[2]);
    }
    return tmpVec;
  };
  publicAPI.getTransformedFocalPoint = function() {
    if (model.transformMatrix) {
      vec3_exports.transformMat4(tmpVec, model.focalPoint, model.transformMatrix);
    } else {
      vec3_exports.set(tmpVec, model.focalPoint[0], model.focalPoint[1], model.focalPoint[2]);
    }
    return tmpVec;
  };
  publicAPI.getDirection = function() {
    if (model.directionMTime < model.mtime) {
      vec3_exports.sub(model.direction, model.focalPoint, model.position);
      normalize(model.direction);
      model.directionMTime = model.mtime;
    }
    return model.direction;
  };
  publicAPI.setDirection = function(directionVector) {
    var newFocalPoint = new Float64Array(3);
    vec3_exports.sub(newFocalPoint, model.position, directionVector);
    model.focalPoint = newFocalPoint;
  };
  publicAPI.setDirectionAngle = function(elevation, azimuth) {
    var elevationRadians = radiansFromDegrees(elevation);
    var azimuthRadians = radiansFromDegrees(azimuth);
    publicAPI.setPosition(Math.cos(elevationRadians) * Math.sin(azimuthRadians), Math.sin(elevationRadians), Math.cos(elevationRadians) * Math.cos(azimuthRadians));
    publicAPI.setFocalPoint(0, 0, 0);
    publicAPI.setPositional(0);
  };
  publicAPI.setLightTypeToHeadLight = function() {
    publicAPI.setLightType("HeadLight");
  };
  publicAPI.setLightTypeToCameraLight = function() {
    publicAPI.setLightType("CameraLight");
  };
  publicAPI.setLightTypeToSceneLight = function() {
    publicAPI.setTransformMatrix(null);
    publicAPI.setLightType("SceneLight");
  };
  publicAPI.lightTypeIsHeadLight = function() {
    return model.lightType === "HeadLight";
  };
  publicAPI.lightTypeIsSceneLight = function() {
    return model.lightType === "SceneLight";
  };
  publicAPI.lightTypeIsCameraLight = function() {
    return model.lightType === "CameraLight";
  };
}
var DEFAULT_VALUES2 = {
  switch: true,
  intensity: 1,
  color: [1, 1, 1],
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  positional: false,
  exponent: 1,
  coneAngle: 30,
  coneFalloff: 5,
  attenuationValues: [1, 0, 0],
  transformMatrix: null,
  lightType: "SceneLight",
  shadowAttenuation: 1,
  direction: [0, 0, 0],
  directionMTime: 0
};
function extend2(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["intensity", "switch", "positional", "exponent", "coneAngle", "coneFalloff", "transformMatrix", "lightType", "shadowAttenuation", "attenuationValues"]);
  macro.setGetArray(publicAPI, model, ["color", "position", "focalPoint", "attenuationValues"], 3);
  vtkLight(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend2, "vtkLight");
var vtkLight$1 = {
  newInstance: newInstance3,
  extend: extend2,
  LIGHT_TYPES
};

// node_modules/@kitware/vtk.js/Rendering/Core/Viewport.js
var vtkErrorMacro2 = macro.vtkErrorMacro;
function notImplemented(method) {
  return function() {
    return vtkErrorMacro2("vtkViewport::".concat(method, " - NOT IMPLEMENTED"));
  };
}
function vtkViewport(publicAPI, model) {
  model.classHierarchy.push("vtkViewport");
  publicAPI.getViewProps = function() {
    return model.props;
  };
  publicAPI.hasViewProp = function(prop) {
    return !!model.props.filter(function(item) {
      return item === prop;
    }).length;
  };
  publicAPI.addViewProp = function(prop) {
    if (prop && !publicAPI.hasViewProp(prop)) {
      model.props = model.props.concat(prop);
    }
  };
  publicAPI.removeViewProp = function(prop) {
    var newPropList = model.props.filter(function(item) {
      return item !== prop;
    });
    if (model.props.length !== newPropList.length) {
      model.props = newPropList;
    }
  };
  publicAPI.removeAllViewProps = function() {
    model.props = [];
  };
  function gatherProps(prop) {
    var allProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    allProps.push(prop);
    var children = prop.getNestedProps();
    if (children && children.length) {
      for (var i = 0; i < children.length; i++) {
        gatherProps(children[i], allProps);
      }
    }
    return allProps;
  }
  publicAPI.getViewPropsWithNestedProps = function() {
    var allPropsArray = [];
    for (var i = 0; i < model.props.length; i++) {
      gatherProps(model.props[i], allPropsArray);
    }
    return allPropsArray;
  };
  publicAPI.addActor2D = publicAPI.addViewProp;
  publicAPI.removeActor2D = function(prop) {
    publicAPI.removeViewProp(prop);
  };
  publicAPI.getActors2D = function() {
    model.actors2D = [];
    model.props.forEach(function(prop) {
      model.actors2D = model.actors2D.concat(prop.getActors2D());
    });
    return model.actors2D;
  };
  publicAPI.displayToView = function() {
    return vtkErrorMacro2("call displayToView on your view instead");
  };
  publicAPI.viewToDisplay = function() {
    return vtkErrorMacro2("callviewtodisplay on your view instead");
  };
  publicAPI.getSize = function() {
    return vtkErrorMacro2("call getSize on your View instead");
  };
  publicAPI.normalizedDisplayToProjection = function(x, y, z) {
    var nvp = publicAPI.normalizedDisplayToNormalizedViewport(x, y, z);
    return publicAPI.normalizedViewportToProjection(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedDisplayToNormalizedViewport = function(x, y, z) {
    var scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [(x - model.viewport[0]) / scale[0], (y - model.viewport[1]) / scale[1], z];
  };
  publicAPI.normalizedViewportToProjection = function(x, y, z) {
    return [x * 2 - 1, y * 2 - 1, z * 2 - 1];
  };
  publicAPI.projectionToNormalizedDisplay = function(x, y, z) {
    var nvp = publicAPI.projectionToNormalizedViewport(x, y, z);
    return publicAPI.normalizedViewportToNormalizedDisplay(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedViewportToNormalizedDisplay = function(x, y, z) {
    var scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [x * scale[0] + model.viewport[0], y * scale[1] + model.viewport[1], z];
  };
  publicAPI.projectionToNormalizedViewport = function(x, y, z) {
    return [(x + 1) * 0.5, (y + 1) * 0.5, (z + 1) * 0.5];
  };
  publicAPI.PickPropFrom = notImplemented("PickPropFrom");
}
var DEFAULT_VALUES3 = {
  background: [0, 0, 0],
  background2: [0.2, 0.2, 0.2],
  gradientBackground: false,
  viewport: [0, 0, 1, 1],
  aspect: [1, 1],
  pixelAspect: [1, 1],
  props: [],
  actors2D: []
};
function extend3(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "event");
  macro.setGetArray(publicAPI, model, ["viewport"], 4);
  macro.setGetArray(publicAPI, model, ["background", "background2"], 3);
  vtkViewport(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend3, "vtkViewport");
var vtkViewport$1 = {
  newInstance: newInstance4,
  extend: extend3
};

// node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js
var vtkDebugMacro3 = vtkDebugMacro;
var vtkErrorMacro3 = vtkErrorMacro;
var vtkWarningMacro2 = vtkWarningMacro;
function notImplemented2(method) {
  return function() {
    return vtkErrorMacro3("vtkRenderer::".concat(method, " - NOT IMPLEMENTED"));
  };
}
function vtkRenderer(publicAPI, model) {
  model.classHierarchy.push("vtkRenderer");
  var COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {
    type: "ComputeVisiblePropBoundsEvent",
    renderer: publicAPI
  };
  var RESET_CAMERA_CLIPPING_RANGE_EVENT = {
    type: "ResetCameraClippingRangeEvent",
    renderer: publicAPI
  };
  var RESET_CAMERA_EVENT = {
    type: "ResetCameraEvent",
    renderer: publicAPI
  };
  publicAPI.updateCamera = function() {
    if (!model.activeCamera) {
      vtkDebugMacro3("No cameras are on, creating one.");
      publicAPI.getActiveCameraAndResetIfCreated();
    }
    model.activeCamera.render(publicAPI);
    return true;
  };
  publicAPI.updateLightsGeometryToFollowCamera = function() {
    var camera = publicAPI.getActiveCameraAndResetIfCreated();
    model.lights.forEach(function(light) {
      if (light.lightTypeIsSceneLight())
        ;
      else if (light.lightTypeIsHeadLight()) {
        light.setPositionFrom(camera.getPositionByReference());
        light.setFocalPointFrom(camera.getFocalPointByReference());
        light.modified(camera.getMTime());
      } else if (light.lightTypeIsCameraLight()) {
        light.setTransformMatrix(camera.getCameraLightTransformMatrix(mat4_exports.create()));
      } else {
        vtkErrorMacro3("light has unknown light type", light.get());
      }
    });
  };
  publicAPI.updateLightGeometry = function() {
    if (model.lightFollowCamera) {
      return publicAPI.updateLightsGeometryToFollowCamera();
    }
    return true;
  };
  publicAPI.allocateTime = notImplemented2("allocateTime");
  publicAPI.updateGeometry = notImplemented2("updateGeometry");
  publicAPI.getVTKWindow = function() {
    return model._renderWindow;
  };
  publicAPI.setLayer = function(layer) {
    vtkDebugMacro3(publicAPI.getClassName(), publicAPI, "setting Layer to ", layer);
    if (model.layer !== layer) {
      model.layer = layer;
      publicAPI.modified();
    }
    publicAPI.setPreserveColorBuffer(!!layer);
  };
  publicAPI.setActiveCamera = function(camera) {
    if (model.activeCamera === camera) {
      return false;
    }
    model.activeCamera = camera;
    publicAPI.modified();
    publicAPI.invokeEvent({
      type: "ActiveCameraEvent",
      camera
    });
    return true;
  };
  publicAPI.makeCamera = function() {
    var camera = vtkCamera$1.newInstance();
    publicAPI.invokeEvent({
      type: "CreateCameraEvent",
      camera
    });
    return camera;
  };
  publicAPI.getActiveCamera = function() {
    if (!model.activeCamera) {
      model.activeCamera = publicAPI.makeCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActiveCameraAndResetIfCreated = function() {
    if (!model.activeCamera) {
      publicAPI.getActiveCamera();
      publicAPI.resetCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActors = function() {
    model.actors = [];
    model.props.forEach(function(prop) {
      model.actors = model.actors.concat(prop.getActors());
    });
    return model.actors;
  };
  publicAPI.addActor = publicAPI.addViewProp;
  publicAPI.removeActor = function(actor) {
    model.actors = model.actors.filter(function(a) {
      return a !== actor;
    });
    publicAPI.removeViewProp(actor);
    publicAPI.modified();
  };
  publicAPI.removeAllActors = function() {
    var actors = publicAPI.getActors();
    actors.forEach(function(actor) {
      publicAPI.removeViewProp(actor);
    });
    model.actors = [];
    publicAPI.modified();
  };
  publicAPI.getVolumes = function() {
    model.volumes = [];
    model.props.forEach(function(prop) {
      model.volumes = model.volumes.concat(prop.getVolumes());
    });
    return model.volumes;
  };
  publicAPI.addVolume = publicAPI.addViewProp;
  publicAPI.removeVolume = function(volume) {
    model.volumes = model.volumes.filter(function(v) {
      return v !== volume;
    });
    publicAPI.removeViewProp(volume);
    publicAPI.modified();
  };
  publicAPI.removeAllVolumes = function() {
    var volumes = publicAPI.getVolumes();
    volumes.forEach(function(volume) {
      publicAPI.removeViewProp(volume);
    });
    model.volumes = [];
    publicAPI.modified();
  };
  publicAPI.addLight = function(light) {
    model.lights = [].concat(model.lights, light);
    publicAPI.modified();
  };
  publicAPI.removeLight = function(light) {
    model.lights = model.lights.filter(function(l) {
      return l !== light;
    });
    publicAPI.modified();
  };
  publicAPI.removeAllLights = function() {
    model.lights = [];
    publicAPI.modified();
  };
  publicAPI.setLightCollection = function(lights) {
    model.lights = lights;
    publicAPI.modified();
  };
  publicAPI.makeLight = vtkLight$1.newInstance;
  publicAPI.createLight = function() {
    if (!model.automaticLightCreation) {
      return;
    }
    if (model._createdLight) {
      publicAPI.removeLight(model._createdLight);
      model._createdLight.delete();
      model._createdLight = null;
    }
    model._createdLight = publicAPI.makeLight();
    publicAPI.addLight(model._createdLight);
    model._createdLight.setLightTypeToHeadLight();
    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());
    model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());
  };
  publicAPI.normalizedDisplayToWorld = function(x, y, z, aspect) {
    var vpd = publicAPI.normalizedDisplayToProjection(x, y, z);
    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);
  };
  publicAPI.worldToNormalizedDisplay = function(x, y, z, aspect) {
    var vpd = publicAPI.worldToView(x, y, z);
    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);
  };
  publicAPI.viewToWorld = function(x, y, z) {
    if (model.activeCamera === null) {
      vtkErrorMacro3("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0");
      return [0, 0, 0];
    }
    var matrix = model.activeCamera.getViewMatrix();
    mat4_exports.invert(matrix, matrix);
    mat4_exports.transpose(matrix, matrix);
    var result = new Float64Array([x, y, z]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.projectionToView = function(x, y, z, aspect) {
    if (model.activeCamera === null) {
      vtkErrorMacro3("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0");
      return [0, 0, 0];
    }
    var matrix = model.activeCamera.getProjectionMatrix(aspect, -1, 1);
    mat4_exports.invert(matrix, matrix);
    mat4_exports.transpose(matrix, matrix);
    var result = new Float64Array([x, y, z]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.worldToView = function(x, y, z) {
    if (model.activeCamera === null) {
      vtkErrorMacro3("WorldToView: no active camera, cannot compute view to world, returning 0,0,0");
      return [0, 0, 0];
    }
    var matrix = model.activeCamera.getViewMatrix();
    mat4_exports.transpose(matrix, matrix);
    var result = new Float64Array([x, y, z]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.viewToProjection = function(x, y, z, aspect) {
    if (model.activeCamera === null) {
      vtkErrorMacro3("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0");
      return [0, 0, 0];
    }
    var matrix = model.activeCamera.getProjectionMatrix(aspect, -1, 1);
    mat4_exports.transpose(matrix, matrix);
    var result = new Float64Array([x, y, z]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.computeVisiblePropBounds = function() {
    model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];
    model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];
    model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];
    model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];
    model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];
    model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];
    var nothingVisible = true;
    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);
    for (var index = 0; index < model.props.length; ++index) {
      var prop = model.props[index];
      if (prop.getVisibility() && prop.getUseBounds()) {
        var bounds = prop.getBounds();
        if (bounds && areBoundsInitialized(bounds)) {
          nothingVisible = false;
          if (bounds[0] < model.allBounds[0]) {
            model.allBounds[0] = bounds[0];
          }
          if (bounds[1] > model.allBounds[1]) {
            model.allBounds[1] = bounds[1];
          }
          if (bounds[2] < model.allBounds[2]) {
            model.allBounds[2] = bounds[2];
          }
          if (bounds[3] > model.allBounds[3]) {
            model.allBounds[3] = bounds[3];
          }
          if (bounds[4] < model.allBounds[4]) {
            model.allBounds[4] = bounds[4];
          }
          if (bounds[5] > model.allBounds[5]) {
            model.allBounds[5] = bounds[5];
          }
        }
      }
    }
    if (nothingVisible) {
      uninitializeBounds(model.allBounds);
      vtkDebugMacro3("Can't compute bounds, no 3D props are visible");
    }
    return model.allBounds;
  };
  publicAPI.resetCamera = function() {
    var bounds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    var boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    var center = [0, 0, 0];
    if (!areBoundsInitialized(boundsToUse)) {
      vtkDebugMacro3("Cannot reset camera!");
      return false;
    }
    var vn = null;
    if (publicAPI.getActiveCamera()) {
      vn = model.activeCamera.getViewPlaneNormal();
    } else {
      vtkErrorMacro3("Trying to reset non-existent camera");
      return false;
    }
    model.activeCamera.setViewAngle(30);
    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2;
    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2;
    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2;
    var w1 = boundsToUse[1] - boundsToUse[0];
    var w2 = boundsToUse[3] - boundsToUse[2];
    var w3 = boundsToUse[5] - boundsToUse[4];
    w1 *= w1;
    w2 *= w2;
    w3 *= w3;
    var radius = w1 + w2 + w3;
    radius = radius === 0 ? 1 : radius;
    radius = Math.sqrt(radius) * 0.5;
    var angle = radiansFromDegrees(model.activeCamera.getViewAngle());
    var parallelScale = radius;
    var distance = radius / Math.sin(angle * 0.5);
    var vup = model.activeCamera.getViewUp();
    if (Math.abs(dot(vup, vn)) > 0.999) {
      vtkWarningMacro2("Resetting view-up since view plane normal is parallel");
      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);
    }
    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);
    model.activeCamera.setPosition(center[0] + distance * vn[0], center[1] + distance * vn[1], center[2] + distance * vn[2]);
    publicAPI.resetCameraClippingRange(boundsToUse);
    model.activeCamera.setParallelScale(parallelScale);
    model.activeCamera.setPhysicalScale(radius);
    model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]);
    publicAPI.invokeEvent(RESET_CAMERA_EVENT);
    return true;
  };
  publicAPI.resetCameraClippingRange = function() {
    var bounds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    var boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    if (!areBoundsInitialized(boundsToUse)) {
      vtkDebugMacro3("Cannot reset camera clipping range!");
      return false;
    }
    publicAPI.getActiveCameraAndResetIfCreated();
    if (!model.activeCamera) {
      vtkErrorMacro3("Trying to reset clipping range of non-existent camera");
      return false;
    }
    var range = model.activeCamera.computeClippingRange(boundsToUse);
    var minGap = 0;
    if (model.activeCamera.getParallelProjection()) {
      minGap = 0.2 * model.activeCamera.getParallelScale();
    } else {
      var angle = radiansFromDegrees(model.activeCamera.getViewAngle());
      minGap = 0.2 * Math.tan(angle / 2) * range[1];
    }
    if (range[1] - range[0] < minGap) {
      minGap = minGap - range[1] + range[0];
      range[1] += minGap / 2;
      range[0] -= minGap / 2;
    }
    if (range[0] < 0) {
      range[0] = 0;
    }
    range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;
    range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;
    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];
    if (!model.nearClippingPlaneTolerance) {
      model.nearClippingPlaneTolerance = 0.01;
    }
    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {
      range[0] = model.nearClippingPlaneTolerance * range[1];
    }
    model.activeCamera.setClippingRange(range[0], range[1]);
    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);
    return false;
  };
  publicAPI.setRenderWindow = function(renderWindow) {
    if (renderWindow !== model._renderWindow) {
      model._vtkWindow = renderWindow;
      model._renderWindow = renderWindow;
    }
  };
  publicAPI.visibleActorCount = function() {
    return model.props.filter(function(prop) {
      return prop.getVisibility();
    }).length;
  };
  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;
  publicAPI.getMTime = function() {
    var m1 = model.mtime;
    var m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;
    if (m2 > m1) {
      m1 = m2;
    }
    var m3 = model._createdLight ? model._createdLight.getMTime() : 0;
    if (m3 > m1) {
      m1 = m3;
    }
    return m1;
  };
  publicAPI.getTransparent = function() {
    return !!model.preserveColorBuffer;
  };
  publicAPI.isActiveCameraCreated = function() {
    return !!model.activeCamera;
  };
}
var DEFAULT_VALUES4 = {
  pickedProp: null,
  activeCamera: null,
  allBounds: [],
  ambient: [1, 1, 1],
  allocatedRenderTime: 100,
  timeFactor: 1,
  automaticLightCreation: true,
  twoSidedLighting: true,
  lastRenderTimeInSeconds: -1,
  renderWindow: null,
  lights: [],
  actors: [],
  volumes: [],
  lightFollowCamera: true,
  numberOfPropsRendered: 0,
  propArray: null,
  pathArray: null,
  layer: 0,
  preserveColorBuffer: false,
  preserveDepthBuffer: false,
  computeVisiblePropBounds: createUninitializedBounds(),
  interactive: true,
  nearClippingPlaneTolerance: 0,
  clippingRangeExpansion: 0.05,
  erase: true,
  draw: true,
  useShadows: false,
  useDepthPeeling: false,
  occlusionRatio: 0,
  maximumNumberOfPeels: 4,
  selector: null,
  delegate: null,
  texturedBackground: false,
  backgroundTexture: null,
  environmentTexture: null,
  environmentTextureDiffuseStrength: 1,
  environmentTextureSpecularStrength: 1,
  useEnvironmentTextureAsBackground: false,
  pass: 0
};
function extend4(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  vtkViewport$1.extend(publicAPI, model, initialValues);
  if (!model.background)
    model.background = [0, 0, 0, 1];
  while (model.background.length < 3) {
    model.background.push(0);
  }
  if (model.background.length === 3)
    model.background.push(1);
  get(publicAPI, model, ["_renderWindow", "allocatedRenderTime", "timeFactor", "lastRenderTimeInSeconds", "numberOfPropsRendered", "lastRenderingUsedDepthPeeling", "selector"]);
  setGet(publicAPI, model, ["twoSidedLighting", "lightFollowCamera", "automaticLightCreation", "erase", "draw", "nearClippingPlaneTolerance", "clippingRangeExpansion", "backingStore", "interactive", "layer", "preserveColorBuffer", "preserveDepthBuffer", "useDepthPeeling", "occlusionRatio", "maximumNumberOfPeels", "delegate", "backgroundTexture", "texturedBackground", "environmentTexture", "environmentTextureDiffuseStrength", "environmentTextureSpecularStrength", "useEnvironmentTextureAsBackground", "useShadows", "pass"]);
  getArray(publicAPI, model, ["actors", "volumes", "lights"]);
  setGetArray(publicAPI, model, ["background"], 4, 1);
  moveToProtected(publicAPI, model, ["renderWindow"]);
  vtkRenderer(publicAPI, model);
}
var newInstance5 = newInstance(extend4, "vtkRenderer");
var vtkRenderer$1 = {
  newInstance: newInstance5,
  extend: extend4
};

export {
  extend4 as extend,
  newInstance5 as newInstance,
  vtkRenderer$1
};
//# sourceMappingURL=chunk-CVQLE3V5.js.map
