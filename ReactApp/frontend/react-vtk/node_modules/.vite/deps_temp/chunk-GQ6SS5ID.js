import {
  common_exports,
  mat4_exports,
  vec3_exports
} from "./chunk-GC37RKNO.js";
import {
  areMatricesEqual
} from "./chunk-FOWOP5PK.js";
import {
  _classCallCheck,
  _createClass,
  _toConsumableArray
} from "./chunk-OTTIIP4A.js";

// node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js
var NoOp = function NoOp2(v) {
  return v;
};
var IDENTITY = mat4_exports.identity(new Float64Array(16));
var EPSILON = 1e-6;
var Transform = function() {
  function Transform2() {
    var useDegree = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    _classCallCheck(this, Transform2);
    this.matrix = mat4_exports.identity(new Float64Array(16));
    this.tmp = new Float64Array(3);
    this.angleConv = useDegree ? common_exports.toRadian : NoOp;
  }
  _createClass(Transform2, [{
    key: "rotateFromDirections",
    value: function rotateFromDirections(originDirection, targetDirection) {
      var src = new Float64Array(3);
      var dst = new Float64Array(3);
      var transf = new Float64Array(16);
      vec3_exports.set(src, originDirection[0], originDirection[1], originDirection[2]);
      vec3_exports.set(dst, targetDirection[0], targetDirection[1], targetDirection[2]);
      vec3_exports.normalize(src, src);
      vec3_exports.normalize(dst, dst);
      var cosAlpha = vec3_exports.dot(src, dst);
      if (cosAlpha >= 1) {
        return this;
      }
      vec3_exports.cross(this.tmp, src, dst);
      if (vec3_exports.length(this.tmp) < EPSILON) {
        vec3_exports.cross(this.tmp, [1, 0, 0], originDirection);
        if (vec3_exports.length(this.tmp) < EPSILON) {
          vec3_exports.cross(this.tmp, [0, 1, 0], originDirection);
        }
      }
      mat4_exports.fromRotation(transf, Math.acos(cosAlpha), this.tmp);
      mat4_exports.multiply(this.matrix, this.matrix, transf);
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(angle, axis) {
      vec3_exports.set.apply(vec3_exports, [this.tmp].concat(_toConsumableArray(axis)));
      vec3_exports.normalize(this.tmp, this.tmp);
      mat4_exports.rotate(this.matrix, this.matrix, this.angleConv(angle), this.tmp);
      return this;
    }
  }, {
    key: "rotateX",
    value: function rotateX(angle) {
      mat4_exports.rotateX(this.matrix, this.matrix, this.angleConv(angle));
      return this;
    }
  }, {
    key: "rotateY",
    value: function rotateY(angle) {
      mat4_exports.rotateY(this.matrix, this.matrix, this.angleConv(angle));
      return this;
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(angle) {
      mat4_exports.rotateZ(this.matrix, this.matrix, this.angleConv(angle));
      return this;
    }
  }, {
    key: "translate",
    value: function translate(x, y, z) {
      vec3_exports.set(this.tmp, x, y, z);
      mat4_exports.translate(this.matrix, this.matrix, this.tmp);
      return this;
    }
  }, {
    key: "scale",
    value: function scale(sx, sy, sz) {
      vec3_exports.set(this.tmp, sx, sy, sz);
      mat4_exports.scale(this.matrix, this.matrix, this.tmp);
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(mat4x4) {
      mat4_exports.multiply(this.matrix, this.matrix, mat4x4);
      return this;
    }
  }, {
    key: "identity",
    value: function identity() {
      mat4_exports.identity(this.matrix);
      return this;
    }
  }, {
    key: "apply",
    value: function apply(typedArray) {
      var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var nbIterations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      if (areMatricesEqual(IDENTITY, this.matrix)) {
        return this;
      }
      var size = nbIterations === -1 ? typedArray.length : offset + nbIterations * 3;
      for (var i = offset; i < size; i += 3) {
        vec3_exports.set(this.tmp, typedArray[i], typedArray[i + 1], typedArray[i + 2]);
        vec3_exports.transformMat4(this.tmp, this.tmp, this.matrix);
        typedArray[i] = this.tmp[0];
        typedArray[i + 1] = this.tmp[1];
        typedArray[i + 2] = this.tmp[2];
      }
      return this;
    }
  }, {
    key: "getMatrix",
    value: function getMatrix() {
      return this.matrix;
    }
  }, {
    key: "setMatrix",
    value: function setMatrix(mat4x4) {
      if (!!mat4x4 && mat4x4.length === 16) {
        mat4_exports.copy(this.matrix, mat4x4);
      }
      return this;
    }
  }]);
  return Transform2;
}();
function buildFromDegree() {
  return new Transform(true);
}
function buildFromRadian() {
  return new Transform(false);
}
var vtkMatrixBuilder = {
  buildFromDegree,
  buildFromRadian
};

export {
  vtkMatrixBuilder
};
//# sourceMappingURL=chunk-GQ6SS5ID.js.map
