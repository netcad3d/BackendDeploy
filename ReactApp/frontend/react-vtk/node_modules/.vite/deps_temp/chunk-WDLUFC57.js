import {
  vtkAbstractMapper$1
} from "./chunk-FOQ7GAAT.js";
import {
  PassTypes
} from "./chunk-DG5VRK2V.js";
import {
  ScalarMappingTarget,
  vtkScalarsToColors,
  vtkScalarsToColors$1
} from "./chunk-MXMJXURM.js";
import {
  Constants
} from "./chunk-AAZ2P47N.js";
import {
  vtkImageData$1
} from "./chunk-CNJU7J6N.js";
import {
  vtkDataSet$1
} from "./chunk-Z2LVQNSU.js";
import {
  vtkDataArray$1
} from "./chunk-Z5OKWKLG.js";
import {
  VtkDataTypes
} from "./chunk-SWDS6M4V.js";
import {
  createUninitializedBounds,
  hsv2rgb,
  isNan,
  uninitializeBounds
} from "./chunk-FOWOP5PK.js";
import {
  macro
} from "./chunk-OTTIIP4A.js";
import {
  _defineProperty
} from "./chunk-HKWV5KNA.js";

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper3D.js
function vtkAbstractMapper3D(publicAPI, model) {
  publicAPI.getBounds = function() {
    return 0;
  };
  publicAPI.getBounds = function(bounds) {
    publicAPI.getBounds();
    for (var i = 0; i < 6; i++) {
      bounds[i] = model.bounds[i];
    }
  };
  publicAPI.getCenter = function() {
    publicAPI.getBounds();
    for (var i = 0; i < 3; i++) {
      model.center[i] = (model.bounds[2 * i + 1] + model.bounds[2 * i]) / 2;
    }
    return model.center.slice();
  };
  publicAPI.getLength = function() {
    var diff = 0;
    var l = 0;
    publicAPI.getBounds();
    for (var i = 0; i < 3; i++) {
      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];
      l += diff * diff;
    }
    return Math.sqrt(l);
  };
}
var DEFAULT_VALUES = {
  bounds: [1, -1, 1, -1, 1, -1],
  center: [0, 0, 0]
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
  if (!model.bounds) {
    uninitializeBounds(model.bounds);
  }
  if (!model.center) {
    model.center = [0, 0, 0];
  }
  vtkAbstractMapper3D(publicAPI, model);
}
var vtkAbstractMapper3D$1 = {
  extend
};

// node_modules/@kitware/vtk.js/Common/Core/LookupTable.js
var vtkErrorMacro = macro.vtkErrorMacro;
var BELOW_RANGE_COLOR_INDEX = 0;
var ABOVE_RANGE_COLOR_INDEX = 1;
var NAN_COLOR_INDEX = 2;
function vtkLookupTable(publicAPI, model) {
  model.classHierarchy.push("vtkLookupTable");
  publicAPI.isOpaque = function() {
    if (model.opaqueFlagBuildTime.getMTime() < publicAPI.getMTime()) {
      var opaque = true;
      if (model.nanColor[3] < 1) {
        opaque = 0;
      }
      if (model.useBelowRangeColor && model.belowRangeColor[3] < 1) {
        opaque = 0;
      }
      if (model.useAboveRangeColor && model.aboveRangeColor[3] < 1) {
        opaque = 0;
      }
      for (var i = 3; i < model.table.length && opaque; i += 4) {
        if (model.table[i] < 255) {
          opaque = false;
        }
      }
      model.opaqueFlag = opaque;
      model.opaqueFlagBuildTime.modified();
    }
    return model.opaqueFlag;
  };
  publicAPI.usingLogScale = function() {
    return false;
  };
  publicAPI.getNumberOfAvailableColors = function() {
    return model.table.length;
  };
  publicAPI.linearIndexLookup = function(v, p) {
    var dIndex = 0;
    if (v < p.range[0]) {
      dIndex = p.maxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
    } else if (v > p.range[1]) {
      dIndex = p.maxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
    } else {
      dIndex = (v + p.shift) * p.scale;
      dIndex = dIndex < p.maxIndex ? dIndex : p.maxIndex;
    }
    return Math.floor(dIndex);
  };
  publicAPI.linearLookup = function(v, table, p) {
    var index = 0;
    if (isNan(v)) {
      index = Math.floor(p.maxIndex + 1.5 + NAN_COLOR_INDEX);
    } else {
      index = publicAPI.linearIndexLookup(v, p);
    }
    var offset = 4 * index;
    return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];
  };
  publicAPI.indexedLookupFunction = function(v, table, p) {
    var index = publicAPI.getAnnotatedValueIndexInternal(v);
    if (index === -1) {
      index = model.numberOfColors + NAN_COLOR_INDEX;
    }
    var offset = 4 * index;
    return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];
  };
  publicAPI.lookupShiftAndScale = function(range, p) {
    p.shift = -range[0];
    p.scale = Number.MAX_VALUE;
    if (range[1] > range[0]) {
      p.scale = (p.maxIndex + 1) / (range[1] - range[0]);
    }
  };
  publicAPI.mapScalarsThroughTable = function(input, output, outFormat, inputOffset) {
    var lookupFunc = publicAPI.linearLookup;
    if (model.indexedLookup) {
      lookupFunc = publicAPI.indexedLookupFunction;
    }
    var trange = publicAPI.getMappingRange();
    var p = {
      maxIndex: publicAPI.getNumberOfColors() - 1,
      range: trange,
      shift: 0,
      scale: 0
    };
    publicAPI.lookupShiftAndScale(trange, p);
    var alpha = publicAPI.getAlpha();
    var length = input.getNumberOfTuples();
    var inIncr = input.getNumberOfComponents();
    var outputV = output.getData();
    var inputV = input.getData();
    if (alpha >= 1) {
      if (outFormat === ScalarMappingTarget.RGBA) {
        for (var i = 0; i < length; i++) {
          var cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = cptr[3];
        }
      }
    } else {
      if (outFormat === ScalarMappingTarget.RGBA) {
        for (var _i = 0; _i < length; _i++) {
          var _cptr = lookupFunc(inputV[_i * inIncr + inputOffset], model.table, p);
          outputV[_i * 4] = _cptr[0];
          outputV[_i * 4 + 1] = _cptr[1];
          outputV[_i * 4 + 2] = _cptr[2];
          outputV[_i * 4 + 3] = Math.floor(_cptr[3] * alpha + 0.5);
        }
      }
    }
  };
  publicAPI.forceBuild = function() {
    var hinc = 0;
    var sinc = 0;
    var vinc = 0;
    var ainc = 0;
    var maxIndex = model.numberOfColors - 1;
    if (maxIndex) {
      hinc = (model.hueRange[1] - model.hueRange[0]) / maxIndex;
      sinc = (model.saturationRange[1] - model.saturationRange[0]) / maxIndex;
      vinc = (model.valueRange[1] - model.valueRange[0]) / maxIndex;
      ainc = (model.alphaRange[1] - model.alphaRange[0]) / maxIndex;
    }
    var hsv = [];
    var rgba = [];
    for (var i = 0; i <= maxIndex; i++) {
      hsv[0] = model.hueRange[0] + i * hinc;
      hsv[1] = model.saturationRange[0] + i * sinc;
      hsv[2] = model.valueRange[0] + i * vinc;
      hsv2rgb(hsv, rgba);
      rgba[3] = model.alphaRange[0] + i * ainc;
      model.table[i * 4] = rgba[0] * 255 + 0.5;
      model.table[i * 4 + 1] = rgba[1] * 255 + 0.5;
      model.table[i * 4 + 2] = rgba[2] * 255 + 0.5;
      model.table[i * 4 + 3] = rgba[3] * 255 + 0.5;
    }
    publicAPI.buildSpecialColors();
    model.buildTime.modified();
  };
  publicAPI.setTable = function(table) {
    if (table.getNumberOfComponents() !== 4) {
      vtkErrorMacro("Expected 4 components for RGBA colors");
      return;
    }
    if (table.getDataType() !== VtkDataTypes.UNSIGNED_CHAR) {
      vtkErrorMacro("Expected unsigned char values for RGBA colors");
      return;
    }
    model.numberOfColors = table.getNumberOfTuples();
    var data = table.getData();
    for (var i = 0; i < data.length; i++) {
      model.table[i] = data[i];
    }
    publicAPI.buildSpecialColors();
    model.insertTime.modified();
    publicAPI.modified();
  };
  publicAPI.buildSpecialColors = function() {
    var numberOfColors = model.numberOfColors;
    var tptr = model.table;
    var base = (numberOfColors + BELOW_RANGE_COLOR_INDEX) * 4;
    if (model.useBelowRangeColor || numberOfColors === 0) {
      tptr[base] = model.belowRangeColor[0] * 255 + 0.5;
      tptr[base + 1] = model.belowRangeColor[1] * 255 + 0.5;
      tptr[base + 2] = model.belowRangeColor[2] * 255 + 0.5;
      tptr[base + 3] = model.belowRangeColor[3] * 255 + 0.5;
    } else {
      tptr[base] = tptr[0];
      tptr[base + 1] = tptr[1];
      tptr[base + 2] = tptr[2];
      tptr[base + 3] = tptr[3];
    }
    base = (numberOfColors + ABOVE_RANGE_COLOR_INDEX) * 4;
    if (model.useAboveRangeColor || numberOfColors === 0) {
      tptr[base] = model.aboveRangeColor[0] * 255 + 0.5;
      tptr[base + 1] = model.aboveRangeColor[1] * 255 + 0.5;
      tptr[base + 2] = model.aboveRangeColor[2] * 255 + 0.5;
      tptr[base + 3] = model.aboveRangeColor[3] * 255 + 0.5;
    } else {
      tptr[base] = tptr[4 * (numberOfColors - 1) + 0];
      tptr[base + 1] = tptr[4 * (numberOfColors - 1) + 1];
      tptr[base + 2] = tptr[4 * (numberOfColors - 1) + 2];
      tptr[base + 3] = tptr[4 * (numberOfColors - 1) + 3];
    }
    base = (numberOfColors + NAN_COLOR_INDEX) * 4;
    tptr[base] = model.nanColor[0] * 255 + 0.5;
    tptr[base + 1] = model.nanColor[1] * 255 + 0.5;
    tptr[base + 2] = model.nanColor[2] * 255 + 0.5;
    tptr[base + 3] = model.nanColor[3] * 255 + 0.5;
  };
  publicAPI.build = function() {
    if (model.table.length < 1 || publicAPI.getMTime() > model.buildTime.getMTime() && model.insertTime.getMTime() <= model.buildTime.getMTime()) {
      publicAPI.forceBuild();
    }
  };
  if (model.table.length > 0) {
    model.insertTime.modified();
  }
}
var DEFAULT_VALUES2 = {
  numberOfColors: 256,
  hueRange: [0, 0.66667],
  saturationRange: [1, 1],
  valueRange: [1, 1],
  alphaRange: [1, 1],
  nanColor: [0.5, 0, 0, 1],
  belowRangeColor: [0, 0, 0, 1],
  aboveRangeColor: [1, 1, 1, 1],
  useAboveRangeColor: false,
  useBelowRangeColor: false,
  alpha: 1
};
function extend2(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  vtkScalarsToColors$1.extend(publicAPI, model, initialValues);
  if (!model.table) {
    model.table = [];
  }
  model.buildTime = {};
  macro.obj(model.buildTime);
  model.opaqueFlagBuildTime = {};
  macro.obj(model.opaqueFlagBuildTime, {
    mtime: 0
  });
  model.insertTime = {};
  macro.obj(model.insertTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["buildTime"]);
  macro.setGet(publicAPI, model, ["numberOfColors", "useAboveRangeColor", "useBelowRangeColor"]);
  macro.setArray(publicAPI, model, ["alphaRange", "hueRange", "saturationRange", "valueRange"], 2);
  macro.setArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"], 4);
  macro.getArray(publicAPI, model, ["hueRange", "saturationRange", "valueRange", "alphaRange", "nanColor", "belowRangeColor", "aboveRangeColor"]);
  vtkLookupTable(publicAPI, model);
}
var newInstance = macro.newInstance(extend2, "vtkLookupTable");
var vtkLookupTable$1 = {
  newInstance,
  extend: extend2
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Static.js
var resolveCoincidentTopologyPolygonOffsetFaces = 1;
var resolveCoincidentTopology = 0;
var RESOLVE_COINCIDENT_TOPOLOGY_MODE = ["VTK_RESOLVE_OFF", "VTK_RESOLVE_POLYGON_OFFSET"];
function getResolveCoincidentTopologyPolygonOffsetFaces() {
  return resolveCoincidentTopologyPolygonOffsetFaces;
}
function setResolveCoincidentTopologyPolygonOffsetFaces(value) {
  resolveCoincidentTopologyPolygonOffsetFaces = value;
}
function getResolveCoincidentTopology() {
  return resolveCoincidentTopology;
}
function setResolveCoincidentTopology() {
  var mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  resolveCoincidentTopology = mode;
}
function setResolveCoincidentTopologyToDefault() {
  setResolveCoincidentTopology(0);
}
function setResolveCoincidentTopologyToOff() {
  setResolveCoincidentTopology(0);
}
function setResolveCoincidentTopologyToPolygonOffset() {
  setResolveCoincidentTopology(1);
}
function getResolveCoincidentTopologyAsString() {
  return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];
}
var otherStaticMethods = {
  getResolveCoincidentTopologyAsString,
  getResolveCoincidentTopologyPolygonOffsetFaces,
  getResolveCoincidentTopology,
  setResolveCoincidentTopology,
  setResolveCoincidentTopologyPolygonOffsetFaces,
  setResolveCoincidentTopologyToDefault,
  setResolveCoincidentTopologyToOff,
  setResolveCoincidentTopologyToPolygonOffset
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js
function addCoincidentTopologyMethods(publicAPI, model, nameList) {
  nameList.forEach(function(item) {
    publicAPI["get".concat(item.method)] = function() {
      return model[item.key];
    };
    publicAPI["set".concat(item.method)] = function(factor, offset) {
      model[item.key] = {
        factor,
        offset
      };
    };
  });
}
var CATEGORIES = ["Polygon", "Line", "Point"];
var staticOffsetModel = {
  Polygon: {
    factor: 2,
    offset: 0
  },
  Line: {
    factor: 1,
    offset: -1
  },
  Point: {
    factor: 0,
    offset: -2
  }
};
var staticOffsetAPI = {};
addCoincidentTopologyMethods(staticOffsetAPI, staticOffsetModel, CATEGORIES.map(function(key) {
  return {
    key,
    method: "ResolveCoincidentTopology".concat(key, "OffsetParameters")
  };
}));
function implementCoincidentTopologyMethods(publicAPI, model) {
  if (model.resolveCoincidentTopology === void 0) {
    model.resolveCoincidentTopology = false;
  }
  macro.setGet(publicAPI, model, ["resolveCoincidentTopology"]);
  model.topologyOffset = {
    Polygon: {
      factor: 0,
      offset: 0
    },
    Line: {
      factor: 0,
      offset: 0
    },
    Point: {
      factor: 0,
      offset: 0
    }
  };
  Object.keys(otherStaticMethods).forEach(function(methodName) {
    publicAPI[methodName] = otherStaticMethods[methodName];
  });
  Object.keys(staticOffsetAPI).forEach(function(methodName) {
    publicAPI[methodName] = staticOffsetAPI[methodName];
  });
  addCoincidentTopologyMethods(publicAPI, model.topologyOffset, CATEGORIES.map(function(key) {
    return {
      key,
      method: "RelativeCoincidentTopology".concat(key, "OffsetParameters")
    };
  }));
  publicAPI.getCoincidentTopologyPolygonOffsetParameters = function() {
    var globalValue = staticOffsetAPI.getResolveCoincidentTopologyPolygonOffsetParameters();
    var localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyLineOffsetParameters = function() {
    var globalValue = staticOffsetAPI.getResolveCoincidentTopologyLineOffsetParameters();
    var localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyPointOffsetParameter = function() {
    var globalValue = staticOffsetAPI.getResolveCoincidentTopologyPointOffsetParameters();
    var localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
}
var CoincidentTopologyHelper = {
  implementCoincidentTopologyMethods,
  staticOffsetAPI,
  otherStaticMethods,
  CATEGORIES
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var FieldAssociations = vtkDataSet$1.FieldAssociations;
var staticOffsetAPI2 = CoincidentTopologyHelper.staticOffsetAPI;
var otherStaticMethods2 = CoincidentTopologyHelper.otherStaticMethods;
var ColorMode = Constants.ColorMode;
var ScalarMode = Constants.ScalarMode;
var GetArray = Constants.GetArray;
var VectorMode = vtkScalarsToColors.VectorMode;
var VtkDataTypes2 = vtkDataArray$1.VtkDataTypes;
function notImplemented(method) {
  return function() {
    return macro.vtkErrorMacro("vtkMapper::".concat(method, " - NOT IMPLEMENTED"));
  };
}
function vtkMapper(publicAPI, model) {
  model.classHierarchy.push("vtkMapper");
  publicAPI.getBounds = function() {
    var input = publicAPI.getInputData();
    if (!input) {
      model.bounds = createUninitializedBounds();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.setForceCompileOnly = function(v) {
    model.forceCompileOnly = v;
  };
  publicAPI.createDefaultLookupTable = function() {
    model.lookupTable = vtkLookupTable$1.newInstance();
  };
  publicAPI.getColorModeAsString = function() {
    return macro.enumToString(ColorMode, model.colorMode);
  };
  publicAPI.setColorModeToDefault = function() {
    return publicAPI.setColorMode(0);
  };
  publicAPI.setColorModeToMapScalars = function() {
    return publicAPI.setColorMode(1);
  };
  publicAPI.setColorModeToDirectScalars = function() {
    return publicAPI.setColorMode(2);
  };
  publicAPI.getScalarModeAsString = function() {
    return macro.enumToString(ScalarMode, model.scalarMode);
  };
  publicAPI.setScalarModeToDefault = function() {
    return publicAPI.setScalarMode(0);
  };
  publicAPI.setScalarModeToUsePointData = function() {
    return publicAPI.setScalarMode(1);
  };
  publicAPI.setScalarModeToUseCellData = function() {
    return publicAPI.setScalarMode(2);
  };
  publicAPI.setScalarModeToUsePointFieldData = function() {
    return publicAPI.setScalarMode(3);
  };
  publicAPI.setScalarModeToUseCellFieldData = function() {
    return publicAPI.setScalarMode(4);
  };
  publicAPI.setScalarModeToUseFieldData = function() {
    return publicAPI.setScalarMode(5);
  };
  publicAPI.getAbstractScalars = function(input, scalarMode, arrayAccessMode, arrayId, arrayName) {
    if (!input || !model.scalarVisibility) {
      return {
        scalars: null,
        cellFLag: false
      };
    }
    var scalars = null;
    var cellFlag = false;
    if (scalarMode === ScalarMode.DEFAULT) {
      scalars = input.getPointData().getScalars();
      if (!scalars) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      }
    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {
      scalars = input.getPointData().getScalars();
    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {
      scalars = input.getCellData().getScalars();
      cellFlag = true;
    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {
      var pd = input.getPointData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = pd.getArrayByIndex(arrayId);
      } else {
        scalars = pd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {
      var cd = input.getCellData();
      cellFlag = true;
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = cd.getArrayByIndex(arrayId);
      } else {
        scalars = cd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {
      var fd = input.getFieldData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = fd.getArrayByIndex(arrayId);
      } else {
        scalars = fd.getArrayByName(arrayName);
      }
    }
    return {
      scalars,
      cellFlag
    };
  };
  publicAPI.mapScalars = function(input, alpha) {
    var scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;
    if (!scalars) {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      model.colorMapColors = null;
      return;
    }
    var toString = "".concat(publicAPI.getMTime()).concat(scalars.getMTime()).concat(alpha);
    if (model.colorBuildString === toString)
      return;
    if (!model.useLookupTableScalarRange) {
      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
    }
    if (publicAPI.canUseTextureMapForColoring(input)) {
      publicAPI.mapScalarsToTexture(scalars, alpha);
    } else {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      var lut = publicAPI.getLookupTable();
      if (lut) {
        lut.build();
        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
      }
    }
    model.colorBuildString = "".concat(publicAPI.getMTime()).concat(scalars.getMTime()).concat(alpha);
  };
  publicAPI.scalarToTextureCoordinate = function(scalarValue, rangeMin, invRangeWidth) {
    var texCoordS = 0.5;
    var texCoordT = 1;
    if (!isNan(scalarValue)) {
      texCoordT = 0.49;
      texCoordS = (scalarValue - rangeMin) * invRangeWidth;
      if (texCoordS > 1e3) {
        texCoordS = 1e3;
      } else if (texCoordS < -1e3) {
        texCoordS = -1e3;
      }
    }
    return {
      texCoordS,
      texCoordT
    };
  };
  publicAPI.createColorTextureCoordinates = function(input, output, numScalars, numComps, component, range, tableRange, tableNumberOfColors, useLogScale) {
    var scalarTexelWidth = (range[1] - range[0]) / tableNumberOfColors;
    var paddedRange = [];
    paddedRange[0] = range[0] - scalarTexelWidth;
    paddedRange[1] = range[1] + scalarTexelWidth;
    var invRangeWidth = 1 / (paddedRange[1] - paddedRange[0]);
    var outputV = output.getData();
    var inputV = input.getData();
    var count = 0;
    var outputCount = 0;
    if (component < 0 || component >= numComps) {
      for (var scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
        var sum = 0;
        for (var compIdx = 0; compIdx < numComps; ++compIdx) {
          sum += inputV[count] * inputV[count];
          count++;
        }
        var magnitude = Math.sqrt(sum);
        if (useLogScale) {
          magnitude = vtkLookupTable$1.applyLogScale(magnitude, tableRange, range);
        }
        var outputs = publicAPI.scalarToTextureCoordinate(magnitude, paddedRange[0], invRangeWidth);
        outputV[outputCount] = outputs.texCoordS;
        outputV[outputCount + 1] = outputs.texCoordT;
        outputCount += 2;
      }
    } else {
      count += component;
      for (var _scalarIdx = 0; _scalarIdx < numScalars; ++_scalarIdx) {
        var inputValue = inputV[count];
        if (useLogScale) {
          inputValue = vtkLookupTable$1.applyLogScale(inputValue, tableRange, range);
        }
        var _outputs = publicAPI.scalarToTextureCoordinate(inputValue, paddedRange[0], invRangeWidth);
        outputV[outputCount] = _outputs.texCoordS;
        outputV[outputCount + 1] = _outputs.texCoordT;
        outputCount += 2;
        count += numComps;
      }
    }
  };
  publicAPI.mapScalarsToTexture = function(scalars, alpha) {
    var range = model.lookupTable.getRange();
    var useLogScale = model.lookupTable.usingLogScale();
    if (useLogScale) {
      vtkLookupTable$1.getLogRange(range, range);
    }
    var origAlpha = model.lookupTable.getAlpha();
    model.colorMapColors = null;
    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {
      model.lookupTable.setAlpha(alpha);
      model.colorTextureMap = null;
      model.lookupTable.build();
      var numberOfColors = model.lookupTable.getNumberOfAvailableColors();
      if (numberOfColors > 4094) {
        numberOfColors = 4094;
      }
      numberOfColors += 2;
      var k = (range[1] - range[0]) / (numberOfColors - 1 - 2);
      var newArray = new Float64Array(numberOfColors * 2);
      for (var i = 0; i < numberOfColors; ++i) {
        newArray[i] = range[0] + i * k - k;
        if (useLogScale) {
          newArray[i] = Math.pow(10, newArray[i]);
        }
      }
      for (var _i = 0; _i < numberOfColors; ++_i) {
        newArray[_i + numberOfColors] = NaN;
      }
      model.colorTextureMap = vtkImageData$1.newInstance();
      model.colorTextureMap.setExtent(0, numberOfColors - 1, 0, 1, 0, 0);
      var tmp = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: newArray
      });
      model.colorTextureMap.getPointData().setScalars(model.lookupTable.mapScalars(tmp, model.colorMode, 0));
      model.lookupTable.setAlpha(origAlpha);
    }
    if (!model.colorCoordinates || publicAPI.getMTime() > model.colorCoordinates.getMTime() || publicAPI.getInputData(0).getMTime() > model.colorCoordinates.getMTime() || model.lookupTable.getMTime() > model.colorCoordinates.getMTime()) {
      model.colorCoordinates = null;
      var numComps = scalars.getNumberOfComponents();
      var num = scalars.getNumberOfTuples();
      model.colorCoordinates = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: new Float32Array(num * 2)
      });
      var scalarComponent = model.lookupTable.getVectorComponent();
      if (model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE && scalars.getNumberOfComponents() > 1) {
        scalarComponent = -1;
      }
      publicAPI.createColorTextureCoordinates(scalars, model.colorCoordinates, num, numComps, scalarComponent, range, model.lookupTable.getRange(), model.colorTextureMap.getPointData().getScalars().getNumberOfTuples() / 2 - 2, useLogScale);
    }
  };
  publicAPI.getIsOpaque = function() {
    var lut = publicAPI.getLookupTable();
    if (lut) {
      lut.build();
      return lut.isOpaque();
    }
    return true;
  };
  publicAPI.canUseTextureMapForColoring = function(input) {
    if (!model.interpolateScalarsBeforeMapping) {
      return false;
    }
    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {
      return false;
    }
    var gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    var scalars = gasResult.scalars;
    if (!scalars) {
      return false;
    }
    if (gasResult.cellFlag) {
      return false;
    }
    if (model.colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes2.UNSIGNED_CHAR || model.colorMode === ColorMode.DIRECT_SCALARS) {
      return false;
    }
    return true;
  };
  publicAPI.clearColorArrays = function() {
    model.colorMapColors = null;
    model.colorCoordinates = null;
    model.colorTextureMap = null;
  };
  publicAPI.getLookupTable = function() {
    if (!model.lookupTable) {
      publicAPI.createDefaultLookupTable();
    }
    return model.lookupTable;
  };
  publicAPI.getMTime = function() {
    var mt = model.mtime;
    if (model.lookupTable !== null) {
      var time = model.lookupTable.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getPrimitiveCount = function() {
    var input = publicAPI.getInputData();
    var pcount = {
      points: input.getPoints().getNumberOfValues() / 3,
      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
    };
    return pcount;
  };
  publicAPI.acquireInvertibleLookupTable = notImplemented("AcquireInvertibleLookupTable");
  publicAPI.valueToColor = notImplemented("ValueToColor");
  publicAPI.colorToValue = notImplemented("ColorToValue");
  publicAPI.useInvertibleColorFor = notImplemented("UseInvertibleColorFor");
  publicAPI.clearInvertibleColor = notImplemented("ClearInvertibleColor");
  publicAPI.processSelectorPixelBuffers = function(selector, pixelOffsets) {
    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {
      return;
    }
    var rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);
    var rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);
    var currentPass = selector.getCurrentPass();
    var fieldAssociation = selector.getFieldAssociation();
    var idMap = null;
    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {
      idMap = model.selectionWebGLIdsToVTKIds.points;
    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {
      idMap = model.selectionWebGLIdsToVTKIds.cells;
    }
    if (!idMap) {
      return;
    }
    pixelOffsets.forEach(function(pos) {
      if (currentPass === PassTypes.ID_LOW24) {
        var inValue = 0;
        if (rawHighData) {
          inValue += rawHighData[pos];
          inValue *= 256;
        }
        inValue += rawLowData[pos + 2];
        inValue *= 256;
        inValue += rawLowData[pos + 1];
        inValue *= 256;
        inValue += rawLowData[pos];
        var outValue = idMap[inValue];
        var lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);
        lowData[pos] = outValue & 255;
        lowData[pos + 1] = (outValue & 65280) >> 8;
        lowData[pos + 2] = (outValue & 16711680) >> 16;
      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {
        var _inValue = 0;
        _inValue += rawHighData[pos];
        _inValue *= 256;
        _inValue += rawLowData[pos];
        _inValue *= 256;
        _inValue += rawLowData[pos + 1];
        _inValue *= 256;
        _inValue += rawLowData[pos + 2];
        var _outValue = idMap[_inValue];
        var highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);
        highData[pos] = (_outValue & 4278190080) >> 24;
      }
    });
  };
}
var DEFAULT_VALUES3 = {
  colorMapColors: null,
  static: false,
  lookupTable: null,
  scalarVisibility: true,
  scalarRange: [0, 1],
  useLookupTableScalarRange: false,
  colorMode: 0,
  scalarMode: 0,
  arrayAccessMode: 1,
  renderTime: 0,
  colorByArrayName: null,
  fieldDataTupleId: -1,
  populateSelectionSettings: true,
  selectionWebGLIdsToVTKIds: null,
  interpolateScalarsBeforeMapping: false,
  colorCoordinates: null,
  colorTextureMap: null,
  forceCompileOnly: 0,
  useInvertibleColors: false,
  invertibleScalars: null,
  viewSpecificProperties: null,
  customShaderAttributes: []
};
function extend3(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  vtkAbstractMapper3D$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["colorCoordinates", "colorMapColors", "colorTextureMap"]);
  macro.setGet(publicAPI, model, [
    "colorByArrayName",
    "arrayAccessMode",
    "colorMode",
    "fieldDataTupleId",
    "interpolateScalarsBeforeMapping",
    "lookupTable",
    "populateSelectionSettings",
    "renderTime",
    "scalarMode",
    "scalarVisibility",
    "selectionWebGLIdsToVTKIds",
    "static",
    "useLookupTableScalarRange",
    "viewSpecificProperties",
    "customShaderAttributes"
  ]);
  macro.setGetArray(publicAPI, model, ["scalarRange"], 2);
  if (!model.viewSpecificProperties) {
    model.viewSpecificProperties = {};
  }
  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);
  vtkMapper(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend3, "vtkMapper");
var vtkMapper$1 = _objectSpread(_objectSpread(_objectSpread({
  newInstance: newInstance2,
  extend: extend3
}, staticOffsetAPI2), otherStaticMethods2), Constants);

export {
  vtkLookupTable$1,
  extend3 as extend,
  newInstance2 as newInstance,
  vtkMapper$1
};
//# sourceMappingURL=chunk-WDLUFC57.js.map
