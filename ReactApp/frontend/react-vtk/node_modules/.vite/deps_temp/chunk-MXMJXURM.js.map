{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Common/Core/ScalarsToColors/Constants.js", "../../@kitware/vtk.js/Common/Core/ScalarsToColors.js"],
  "sourcesContent": ["var VectorMode = {\n  MAGNITUDE: 0,\n  COMPONENT: 1,\n  RGBCOLORS: 2\n};\nvar ScalarMappingTarget = {\n  LUMINANCE: 1,\n  LUMINANCE_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\nvar vtkScalarsToColors = {\n  VectorMode: VectorMode,\n  ScalarMappingTarget: ScalarMappingTarget\n};\n\nexport { ScalarMappingTarget, VectorMode, vtkScalarsToColors as default };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkDataArray from './DataArray.js';\nimport vtkScalarsToColors$2 from './ScalarsToColors/Constants.js';\nimport Constants from '../../Rendering/Core/Mapper/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar ScalarMappingTarget = vtkScalarsToColors$2.ScalarMappingTarget,\n    VectorMode = vtkScalarsToColors$2.VectorMode;\nvar VtkDataTypes = vtkDataArray.VtkDataTypes;\nvar ColorMode = Constants.ColorMode;\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n// Add module-level functions or api that you want to expose statically via\n// the next section...\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nfunction intColorToUChar(c) {\n  return c;\n}\n\nfunction floatColorToUChar(c) {\n  return Math.floor(c * 255.0 + 0.5);\n} // ----------------------------------------------------------------------------\n// vtkScalarsToColors methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkScalarsToColors(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkScalarsToColors');\n\n  publicAPI.setVectorModeToMagnitude = function () {\n    return publicAPI.setVectorMode(VectorMode.MAGNITUDE);\n  };\n\n  publicAPI.setVectorModeToComponent = function () {\n    return publicAPI.setVectorMode(VectorMode.COMPONENT);\n  };\n\n  publicAPI.setVectorModeToRGBColors = function () {\n    return publicAPI.setVectorMode(VectorMode.RGBCOLORS);\n  };\n\n  publicAPI.build = function () {};\n\n  publicAPI.isOpaque = function () {\n    return true;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.setAnnotations = function (values, annotations) {\n    if (values && !annotations || !values && annotations) {\n      return;\n    }\n\n    if (values && annotations && values.length !== annotations.length) {\n      vtkErrorMacro('Values and annotations do not have the same number of tuples so ignoring');\n      return;\n    }\n\n    model.annotationArray = [];\n\n    if (annotations && values) {\n      var num = annotations.length;\n\n      for (var i = 0; i < num; i++) {\n        model.annotationArray.push({\n          value: values[i],\n          annotation: String(annotations[i])\n        });\n      }\n    }\n\n    publicAPI.updateAnnotatedValueMap();\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.setAnnotation = function (value, annotation) {\n    var i = publicAPI.checkForAnnotatedValue(value);\n    var modified = false;\n\n    if (i >= 0) {\n      if (model.annotationArray[i].annotation !== annotation) {\n        model.annotationArray[i].annotation = annotation;\n        modified = true;\n      }\n    } else {\n      model.annotationArray.push({\n        value: value,\n        annotation: annotation\n      });\n      i = model.annotationArray.length - 1;\n      modified = true;\n    }\n\n    if (modified) {\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n\n    return i;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getNumberOfAnnotatedValues = function () {\n    return model.annotationArray.length;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getAnnotatedValue = function (idx) {\n    if (idx < 0 || idx >= model.annotationArray.length) {\n      return null;\n    }\n\n    return model.annotationArray[idx].value;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getAnnotation = function (idx) {\n    if (model.annotationArray[idx] === undefined) {\n      return null;\n    }\n\n    return model.annotationArray[idx].annotation;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getAnnotatedValueIndex = function (val) {\n    return model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.removeAnnotation = function (value) {\n    var i = publicAPI.checkForAnnotatedValue(value);\n    var needToRemove = i >= 0;\n\n    if (needToRemove) {\n      model.annotationArray.splice(i, 1);\n      publicAPI.updateAnnotatedValueMap();\n      publicAPI.modified();\n    }\n\n    return needToRemove;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.resetAnnotations = function () {\n    model.annotationArray = [];\n    model.annotatedValueMap = [];\n    publicAPI.modified();\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getAnnotationColor = function (val, rgba) {\n    if (model.indexedLookup) {\n      var i = publicAPI.getAnnotatedValueIndex(val);\n      publicAPI.getIndexedColor(i, rgba);\n    } else {\n      publicAPI.getColor(parseFloat(val), rgba);\n      rgba[3] = 1.0;\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.checkForAnnotatedValue = function (value) {\n    return publicAPI.getAnnotatedValueIndexInternal(value);\n  }; //----------------------------------------------------------------------------\n  // An unsafe version of vtkScalarsToColors::CheckForAnnotatedValue for\n  // internal use (no pointer checks performed)\n\n\n  publicAPI.getAnnotatedValueIndexInternal = function (value) {\n    if (model.annotatedValueMap[value] !== undefined) {\n      var na = model.annotationArray.length;\n      return model.annotatedValueMap[value] % na;\n    } // Treat as a NaN\n\n\n    return -1;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getIndexedColor = function (val, rgba) {\n    rgba[0] = 0.0;\n    rgba[1] = 0.0;\n    rgba[2] = 0.0;\n    rgba[3] = 0.0;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.updateAnnotatedValueMap = function () {\n    model.annotatedValueMap = [];\n    var na = model.annotationArray.length;\n\n    for (var i = 0; i < na; i++) {\n      model.annotatedValueMap[model.annotationArray[i].value] = i;\n    }\n  }; // Description:\n  // Internal methods that map a data array into a 4-component,\n  // unsigned char RGBA array. The color mode determines the behavior\n  // of mapping. If ColorMode.DEFAULT is set, then unsigned char\n  // data arrays are treated as colors (and converted to RGBA if\n  // necessary); If ColorMode.DIRECT_SCALARS is set, then all arrays\n  // are treated as colors (integer types are clamped in the range 0-255,\n  // floating point arrays are clamped in the range 0.0-1.0. Note 'char' does\n  // not have enough values to represent a color so mapping this type is\n  // considered an error);\n  // otherwise, the data is mapped through this instance\n  // of ScalarsToColors. The component argument is used for data\n  // arrays with more than one component; it indicates which component\n  // to use to do the blending.  When the component argument is -1,\n  // then the this object uses its own selected technique to change a\n  // vector into a scalar to map.\n\n\n  publicAPI.mapScalars = function (scalars, colorMode, componentIn) {\n    var numberOfComponents = scalars.getNumberOfComponents();\n    var newColors = null; // map scalars through lookup table only if needed\n\n    if (colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || colorMode === ColorMode.DIRECT_SCALARS && scalars) {\n      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());\n    } else {\n      var newscalars = {\n        type: 'vtkDataArray',\n        name: 'temp',\n        numberOfComponents: 4,\n        dataType: VtkDataTypes.UNSIGNED_CHAR\n      };\n      var s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());\n      newscalars.values = s;\n      newscalars.size = s.length;\n      newColors = vtkDataArray.newInstance(newscalars);\n      var component = componentIn; // If mapper did not specify a component, use the VectorMode\n\n      if (component < 0 && numberOfComponents > 1) {\n        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, -1, -1);\n      } else {\n        if (component < 0) {\n          component = 0;\n        }\n\n        if (component >= numberOfComponents) {\n          component = numberOfComponents - 1;\n        } // Map the scalars to colors\n\n\n        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, component);\n      }\n    }\n\n    return newColors;\n  };\n\n  publicAPI.mapVectorsToMagnitude = function (input, output, compsToUse) {\n    var length = input.getNumberOfTuples();\n    var inIncr = input.getNumberOfComponents();\n    var outputV = output.getData();\n    var inputV = input.getData();\n\n    for (var i = 0; i < length; i++) {\n      var sum = 0.0;\n\n      for (var j = 0; j < compsToUse; j++) {\n        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];\n      }\n\n      outputV[i] = Math.sqrt(sum);\n    }\n  }; //----------------------------------------------------------------------------\n  // Map a set of vector values through the table\n\n\n  publicAPI.mapVectorsThroughTable = function (input, output, outputFormat, vectorComponentIn, vectorSizeIn) {\n    var vectorMode = publicAPI.getVectorMode();\n    var vectorSize = vectorSizeIn;\n    var vectorComponent = vectorComponentIn;\n    var inComponents = input.getNumberOfComponents();\n\n    if (vectorMode === VectorMode.COMPONENT) {\n      // make sure vectorComponent is within allowed range\n      if (vectorComponent === -1) {\n        // if set to -1, use default value provided by table\n        vectorComponent = publicAPI.getVectorComponent();\n      }\n\n      if (vectorComponent < 0) {\n        vectorComponent = 0;\n      }\n\n      if (vectorComponent >= inComponents) {\n        vectorComponent = inComponents - 1;\n      }\n    } else {\n      // make sure vectorSize is within allowed range\n      if (vectorSize === -1) {\n        // if set to -1, use default value provided by table\n        vectorSize = publicAPI.getVectorSize();\n      }\n\n      if (vectorSize <= 0) {\n        vectorComponent = 0;\n        vectorSize = inComponents;\n      } else {\n        if (vectorComponent < 0) {\n          vectorComponent = 0;\n        }\n\n        if (vectorComponent >= inComponents) {\n          vectorComponent = inComponents - 1;\n        }\n\n        if (vectorComponent + vectorSize > inComponents) {\n          vectorSize = inComponents - vectorComponent;\n        }\n      }\n\n      if (vectorMode === VectorMode.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {\n        vectorMode = VectorMode.COMPONENT;\n      }\n    } // increment input pointer to the first component to map\n\n\n    var inputOffset = 0;\n\n    if (vectorComponent > 0) {\n      inputOffset = vectorComponent;\n    } // map according to the current vector mode\n\n\n    switch (vectorMode) {\n      case VectorMode.COMPONENT:\n        {\n          publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);\n          break;\n        }\n\n      case VectorMode.RGBCOLORS:\n        {\n          // publicAPI.mapColorsToColors(\n          //   input, output, inComponents, vectorSize,\n          //   outputFormat);\n          break;\n        }\n      // MAGNITUDE is considered default\n\n      case VectorMode.MAGNITUDE:\n      default:\n        {\n          var magValues = vtkDataArray.newInstance({\n            numberOfComponents: 1,\n            values: new Float32Array(input.getNumberOfTuples())\n          });\n          publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);\n          publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);\n          break;\n        }\n    }\n  };\n\n  publicAPI.luminanceToRGBA = function (newColors, colors, alpha, convtFun) {\n    var a = convtFun(alpha);\n    var values = colors.getData();\n    var newValues = newColors.getData();\n    var size = values.length;\n    var component = 0;\n    var tuple = 1;\n    var count = 0;\n\n    for (var i = component; i < size; i += tuple) {\n      var l = convtFun(values[i]);\n      newValues[count * 4] = l;\n      newValues[count * 4 + 1] = l;\n      newValues[count * 4 + 2] = l;\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n\n  publicAPI.luminanceAlphaToRGBA = function (newColors, colors, alpha, convtFun) {\n    var values = colors.getData();\n    var newValues = newColors.getData();\n    var size = values.length;\n    var component = 0;\n    var tuple = 2;\n    var count = 0;\n\n    for (var i = component; i < size; i += tuple) {\n      var l = convtFun(values[i]);\n      newValues[count] = l;\n      newValues[count + 1] = l;\n      newValues[count + 2] = l;\n      newValues[count + 3] = convtFun(values[i + 1]) * alpha;\n      count += 4;\n    }\n  };\n\n  publicAPI.rGBToRGBA = function (newColors, colors, alpha, convtFun) {\n    var a = floatColorToUChar(alpha);\n    var values = colors.getData();\n    var newValues = newColors.getData();\n    var size = values.length;\n    var component = 0;\n    var tuple = 3;\n    var count = 0;\n\n    for (var i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = a;\n      count++;\n    }\n  };\n\n  publicAPI.rGBAToRGBA = function (newColors, colors, alpha, convtFun) {\n    var values = colors.getData();\n    var newValues = newColors.getData();\n    var size = values.length;\n    var component = 0;\n    var tuple = 4;\n    var count = 0;\n\n    for (var i = component; i < size; i += tuple) {\n      newValues[count * 4] = convtFun(values[i]);\n      newValues[count * 4 + 1] = convtFun(values[i + 1]);\n      newValues[count * 4 + 2] = convtFun(values[i + 2]);\n      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;\n      count++;\n    }\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.convertToRGBA = function (colors, numComp, numTuples) {\n    var alpha = model.alpha;\n\n    if (numComp === 4 && alpha >= 1.0 && colors.getDataType() === VtkDataTypes.UNSIGNED_CHAR) {\n      return colors;\n    }\n\n    var newColors = vtkDataArray.newInstance({\n      numberOfComponents: 4,\n      empty: true,\n      size: 4 * numTuples,\n      dataType: VtkDataTypes.UNSIGNED_CHAR\n    });\n\n    if (numTuples <= 0) {\n      return newColors;\n    }\n\n    alpha = alpha > 0 ? alpha : 0;\n    alpha = alpha < 1 ? alpha : 1;\n    var convtFun = intColorToUChar;\n\n    if (colors.getDataType() === VtkDataTypes.FLOAT || colors.getDataType() === VtkDataTypes.DOUBLE) {\n      convtFun = floatColorToUChar;\n    }\n\n    switch (numComp) {\n      case 1:\n        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);\n        break;\n\n      case 2:\n        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);\n        break;\n\n      case 3:\n        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);\n        break;\n\n      case 4:\n        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);\n        break;\n\n      default:\n        vtkErrorMacro('Cannot convert colors');\n        return null;\n    }\n\n    return newColors;\n  };\n\n  publicAPI.usingLogScale = function () {\n    return false;\n  };\n\n  publicAPI.getNumberOfAvailableColors = function () {\n    return 256 * 256 * 256;\n  };\n\n  publicAPI.setRange = function (min, max) {\n    return publicAPI.setMappingRange(min, max);\n  };\n\n  publicAPI.getRange = function (min, max) {\n    return publicAPI.getMappingRange();\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  alpha: 1.0,\n  vectorComponent: 0,\n  vectorSize: -1,\n  vectorMode: VectorMode.COMPONENT,\n  mappingRange: null,\n  annotationArray: null,\n  annotatedValueMap: null,\n  indexedLookup: false\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Object methods\n\n  macro.obj(publicAPI, model);\n  model.mappingRange = [0, 255];\n  model.annotationArray = [];\n  model.annotatedValueMap = []; // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['vectorSize', 'vectorComponent', 'vectorMode', 'alpha', 'indexedLookup']); // Create set macros for array (needs to know size)\n\n  macro.setArray(publicAPI, model, ['mappingRange'], 2); // Create get macros for array\n\n  macro.getArray(publicAPI, model, ['mappingRange']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkScalarsToColors(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkScalarsToColors'); // ----------------------------------------------------------------------------\n\nvar vtkScalarsToColors$1 = _objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, vtkScalarsToColors$2);\n\nexport { vtkScalarsToColors$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["ScalarMappingTarget", "VectorMode", "vtkScalarsToColors"]
}
