import {
  Constants
} from "./chunk-CPX3F44X.js";
import {
  vtkAbstractMapper$1
} from "./chunk-FOQ7GAAT.js";
import {
  clampValue,
  createUninitializedBounds,
  floor
} from "./chunk-FOWOP5PK.js";
import {
  macro
} from "./chunk-OTTIIP4A.js";
import {
  _defineProperty
} from "./chunk-HKWV5KNA.js";
import "./chunk-XL65WI7U.js";
import "./chunk-HUBM7RA2.js";

// node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var BlendMode = Constants.BlendMode;
var FilterMode = Constants.FilterMode;
function vtkVolumeMapper(publicAPI, model) {
  model.classHierarchy.push("vtkVolumeMapper");
  var superClass = _objectSpread({}, publicAPI);
  publicAPI.getBounds = function() {
    var input = publicAPI.getInputData();
    if (!input) {
      model.bounds = createUninitializedBounds();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.update = function() {
    publicAPI.getInputData();
  };
  publicAPI.setBlendModeToComposite = function() {
    publicAPI.setBlendMode(BlendMode.COMPOSITE_BLEND);
  };
  publicAPI.setBlendModeToMaximumIntensity = function() {
    publicAPI.setBlendMode(BlendMode.MAXIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToMinimumIntensity = function() {
    publicAPI.setBlendMode(BlendMode.MINIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAverageIntensity = function() {
    publicAPI.setBlendMode(BlendMode.AVERAGE_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAdditiveIntensity = function() {
    publicAPI.setBlendMode(BlendMode.ADDITIVE_INTENSITY_BLEND);
  };
  publicAPI.getBlendModeAsString = function() {
    return macro.enumToString(BlendMode, model.blendMode);
  };
  publicAPI.setAverageIPScalarRange = function(min, max) {
    console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange");
    publicAPI.setIpScalarRange(min, max);
  };
  publicAPI.getFilterModeAsString = function() {
    return macro.enumToString(FilterMode, model.filterMode);
  };
  publicAPI.setFilterModeToOff = function() {
    publicAPI.setFilterMode(FilterMode.OFF);
  };
  publicAPI.setFilterModeToNormalized = function() {
    publicAPI.setFilterMode(FilterMode.NORMALIZED);
  };
  publicAPI.setFilterModeToRaw = function() {
    publicAPI.setFilterMode(FilterMode.RAW);
  };
  publicAPI.setGlobalIlluminationReach = function(gl) {
    return superClass.setGlobalIlluminationReach(clampValue(gl, 0, 1));
  };
  publicAPI.setVolumetricScatteringBlending = function(vsb) {
    return superClass.setVolumetricScatteringBlending(clampValue(vsb, 0, 1));
  };
  publicAPI.setVolumeShadowSamplingDistFactor = function(vsdf) {
    return superClass.setVolumeShadowSamplingDistFactor(vsdf >= 1 ? vsdf : 1);
  };
  publicAPI.setAnisotropy = function(at) {
    return superClass.setAnisotropy(clampValue(at, -0.99, 0.99));
  };
  publicAPI.setLAOKernelSize = function(ks) {
    return superClass.setLAOKernelSize(floor(clampValue(ks, 1, 32)));
  };
  publicAPI.setLAOKernelRadius = function(kr) {
    return superClass.setLAOKernelRadius(kr >= 1 ? kr : 1);
  };
}
var DEFAULT_VALUES = {
  bounds: [1, -1, 1, -1, 1, -1],
  sampleDistance: 1,
  imageSampleDistance: 1,
  maximumSamplesPerRay: 1e3,
  autoAdjustSampleDistances: true,
  blendMode: BlendMode.COMPOSITE_BLEND,
  ipScalarRange: [-1e6, 1e6],
  filterMode: FilterMode.OFF,
  preferSizeOverAccuracy: false,
  computeNormalFromOpacity: false,
  volumetricScatteringBlending: 0,
  globalIlluminationReach: 0,
  volumeShadowSamplingDistFactor: 5,
  anisotropy: 0,
  localAmbientOcclusion: false,
  LAOKernelSize: 15,
  LAOKernelRadius: 7
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["sampleDistance", "imageSampleDistance", "maximumSamplesPerRay", "autoAdjustSampleDistances", "blendMode", "filterMode", "preferSizeOverAccuracy", "computeNormalFromOpacity", "volumetricScatteringBlending", "globalIlluminationReach", "volumeShadowSamplingDistFactor", "anisotropy", "localAmbientOcclusion", "LAOKernelSize", "LAOKernelRadius"]);
  macro.setGetArray(publicAPI, model, ["ipScalarRange"], 2);
  macro.event(publicAPI, model, "lightingActivated");
  vtkVolumeMapper(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkVolumeMapper");
var vtkVolumeMapper$1 = {
  newInstance,
  extend
};

// dep:@kitware_vtk__js_Rendering_Core_VolumeMapper
var kitware_vtk_js_Rendering_Core_VolumeMapper_default = vtkVolumeMapper$1;
export {
  kitware_vtk_js_Rendering_Core_VolumeMapper_default as default,
  extend,
  newInstance
};
//# sourceMappingURL=@kitware_vtk__js_Rendering_Core_VolumeMapper.js.map
