{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Common/DataModel/StructuredData/Constants.js", "../../@kitware/vtk.js/Common/DataModel/StructuredData.js", "../../@kitware/vtk.js/Common/DataModel/ImageData.js"],
  "sourcesContent": ["var StructuredType = {\n  UNCHANGED: 0,\n  SINGLE_POINT: 1,\n  X_LINE: 2,\n  Y_LINE: 3,\n  Z_LINE: 4,\n  XY_PLANE: 5,\n  YZ_PLANE: 6,\n  XZ_PLANE: 7,\n  XYZ_GRID: 8,\n  EMPTY: 9\n};\nvar Constants = {\n  StructuredType: StructuredType\n};\n\nexport { StructuredType, Constants as default };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport Constants from './StructuredData/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar StructuredType = Constants.StructuredType;\nfunction getDataDescriptionFromExtent(inExt) {\n  var dataDim = 0;\n\n  for (var i = 0; i < 3; ++i) {\n    if (inExt[i * 2] < inExt[i * 2 + 1]) {\n      dataDim++;\n    }\n  }\n\n  if (inExt[0] > inExt[1] || inExt[2] > inExt[3] || inExt[4] > inExt[5]) {\n    return StructuredType.EMPTY;\n  }\n\n  if (dataDim === 3) {\n    return StructuredType.XYZ_GRID;\n  }\n\n  if (dataDim === 2) {\n    if (inExt[0] === inExt[1]) {\n      return StructuredType.YZ_PLANE;\n    }\n\n    if (inExt[2] === inExt[3]) {\n      return StructuredType.XZ_PLANE;\n    }\n\n    return StructuredType.XY_PLANE;\n  }\n\n  if (dataDim === 1) {\n    if (inExt[0] < inExt[1]) {\n      return StructuredType.X_LINE;\n    }\n\n    if (inExt[2] < inExt[3]) {\n      return StructuredType.Y_LINE;\n    }\n\n    return StructuredType.Z_LINE;\n  }\n\n  return StructuredType.SINGLE_POINT;\n}\nvar vtkStructuredData = _objectSpread({\n  getDataDescriptionFromExtent: getDataDescriptionFromExtent\n}, Constants);\n\nexport { vtkStructuredData as default, getDataDescriptionFromExtent };\n", "import _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport macro from '../../macros.js';\nimport { c as computeBoundsFromPoints, b as roundVector, e as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, vec3, mat4 } from 'gl-matrix';\n\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n\n    var extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n\n    if (extentArray.length !== 6) {\n      return false;\n    }\n\n    var changeDetected = false;\n    model.extent.forEach(function (item, index) {\n      if (item !== extentArray[index]) {\n        if (changeDetected) {\n          return;\n        }\n\n        changeDetected = true;\n      }\n    });\n\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n\n    return changeDetected;\n  };\n\n  publicAPI.setDimensions = function () {\n    var i;\n    var j;\n    var k;\n\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n\n    if (arguments.length === 1) {\n      var array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n\n  publicAPI.getDimensions = function () {\n    return [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  };\n\n  publicAPI.getNumberOfCells = function () {\n    var dims = publicAPI.getDimensions();\n    var nCells = 1;\n\n    for (var i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n\n    return nCells;\n  };\n\n  publicAPI.getNumberOfPoints = function () {\n    var dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n\n  publicAPI.getPoint = function (index) {\n    var dims = publicAPI.getDimensions();\n\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n\n    var ijk = new Float64Array(3);\n\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n\n      case StructuredType.SINGLE_POINT:\n        break;\n\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n\n    var coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  }; // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n\n  publicAPI.getBounds = function () {\n    return publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  };\n\n  publicAPI.extentToBounds = function (ex) {\n    // prettier-ignore\n    var corners = [ex[0], ex[2], ex[4], ex[1], ex[2], ex[4], ex[0], ex[3], ex[4], ex[1], ex[3], ex[4], ex[0], ex[2], ex[5], ex[1], ex[2], ex[5], ex[0], ex[3], ex[5], ex[1], ex[3], ex[5]];\n    var idx = new Float64Array([corners[0], corners[1], corners[2]]);\n    var vout = new Float64Array(3);\n    publicAPI.indexToWorld(idx, vout);\n    var bounds = [vout[0], vout[0], vout[1], vout[1], vout[2], vout[2]];\n\n    for (var i = 3; i < 24; i += 3) {\n      vec3.set(idx, corners[i], corners[i + 1], corners[i + 2]);\n      publicAPI.indexToWorld(idx, vout);\n\n      if (vout[0] < bounds[0]) {\n        bounds[0] = vout[0];\n      }\n\n      if (vout[1] < bounds[2]) {\n        bounds[2] = vout[1];\n      }\n\n      if (vout[2] < bounds[4]) {\n        bounds[4] = vout[2];\n      }\n\n      if (vout[0] > bounds[1]) {\n        bounds[1] = vout[0];\n      }\n\n      if (vout[1] > bounds[3]) {\n        bounds[3] = vout[1];\n      }\n\n      if (vout[2] > bounds[5]) {\n        bounds[5] = vout[2];\n      }\n    }\n\n    return bounds;\n  };\n\n  publicAPI.getSpatialExtent = function () {\n    var boundingBox = vtkBoundingBox.newInstance();\n    boundingBox.setBounds(model.extent);\n    boundingBox.inflate(0.5);\n    return boundingBox.getBounds();\n  }; // Internal, shouldn't need to call this manually.\n\n\n  publicAPI.computeTransforms = function () {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  }; //\n  // The direction matrix is a 3x3 basis for the I, J, K axes\n  // of the image. The rows of the matrix correspond to the\n  // axes directions in world coordinates. Direction must\n  // form an orthonormal basis, results are undefined if\n  // it is not.\n  //\n\n\n  publicAPI.setDirection = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    var array = args; // allow an array passed as a single arg.\n\n    if (array.length === 1 && (Array.isArray(array[0]) || array[0].constructor === Float32Array || array[0].constructor === Float64Array)) {\n      array = array[0];\n    }\n\n    if (array.length !== 9) {\n      throw new RangeError('Invalid number of values for array setter');\n    }\n\n    var changeDetected = false;\n    model.direction.forEach(function (item, index) {\n      if (item !== array[index]) {\n        if (changeDetected) {\n          return;\n        }\n\n        changeDetected = true;\n      }\n    });\n\n    if (changeDetected) {\n      for (var i = 0; i < 9; ++i) {\n        model.direction[i] = array[i];\n      }\n\n      publicAPI.modified();\n    }\n\n    return true;\n  };\n\n  publicAPI.indexToWorld = function (ain) {\n    var aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n\n  publicAPI.worldToIndex = function (ain) {\n    var aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n\n  publicAPI.indexToWorldBounds = function (bin) {\n    var bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var in1 = [0, 0, 0];\n    var in2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bin, in1, in2);\n    var out1 = [0, 0, 0];\n    var out2 = [0, 0, 0];\n    vec3.transformMat4(out1, in1, model.indexToWorld);\n    vec3.transformMat4(out2, in2, model.indexToWorld);\n    return computeBoundsFromPoints(out1, out2, bout);\n  };\n\n  publicAPI.worldToIndexBounds = function (bin) {\n    var bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var in1 = [0, 0, 0];\n    var in2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bin, in1, in2);\n    var out1 = [0, 0, 0];\n    var out2 = [0, 0, 0];\n    vec3.transformMat4(out1, in1, model.worldToIndex);\n    vec3.transformMat4(out2, in2, model.worldToIndex);\n    return computeBoundsFromPoints(out1, out2, bout);\n  }; // Make sure the transform is correct\n\n\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n\n  publicAPI.getCenter = function () {\n    var bounds = publicAPI.getBounds();\n    var center = [];\n\n    for (var i = 0; i < 3; i++) {\n      center[i] = (bounds[2 * i + 1] + bounds[2 * i]) / 2;\n    }\n\n    return center;\n  };\n\n  publicAPI.computeHistogram = function (worldBounds) {\n    var voxelFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    var point1 = [0, 0, 0];\n    var point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    var dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    var yStride = dimensions[0];\n    var zStride = dimensions[0] * dimensions[1];\n    var pixels = publicAPI.getPointData().getScalars().getData();\n    var maximum = -Infinity;\n    var minimum = Infinity;\n    var sumOfSquares = 0;\n    var isum = 0;\n    var inum = 0;\n\n    for (var z = point1[2]; z <= point2[2]; z++) {\n      for (var y = point1[1]; y <= point2[1]; y++) {\n        var index = point1[0] + y * yStride + z * zStride;\n\n        for (var x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {\n            var pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n\n          ++index;\n        }\n      }\n    }\n\n    var average = inum > 0 ? isum / inum : 0;\n    var variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    var sigma = Math.sqrt(variance);\n    return {\n      minimum: minimum,\n      maximum: maximum,\n      average: average,\n      variance: variance,\n      sigma: sigma,\n      count: inum\n    };\n  }; // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n\n\n  publicAPI.computeIncrements = function (extent) {\n    var numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var increments = [];\n    var incr = numberOfComponents; // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n\n    for (var idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n\n    return increments;\n  };\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n\n\n  publicAPI.computeOffsetIndex = function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3),\n        i = _ref2[0],\n        j = _ref2[1],\n        k = _ref2[2];\n\n    var extent = publicAPI.getExtent();\n    var numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    var increments = publicAPI.computeIncrements(extent, numberOfComponents); // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n\n\n  publicAPI.getOffsetIndexFromWorld = function (xyz) {\n    var extent = publicAPI.getExtent();\n    var index = publicAPI.worldToIndex(xyz); // Confirm indexed i,j,k coords are within the bounds of the volume\n\n    for (var idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(\"GetScalarPointer: Pixel \".concat(index, \" is not in memory. Current extent = \").concat(extent));\n        return NaN;\n      }\n    } // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n\n\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n\n\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(\"GetScalarPointer: Scalar Component \".concat(comp, \" is not within bounds. Current Scalar numberOfComponents: \").concat(numberOfComponents));\n      return NaN;\n    }\n\n    var offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkDataSet.extend(publicAPI, model, initialValues);\n\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16); // Set/Get methods\n\n  macro.get(publicAPI, model, ['direction', 'indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.getArray(publicAPI, model, ['extent'], 6); // Object specific methods\n\n  vtkImageData(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkImageData'); // ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkImageData$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["StructuredType"]
}
