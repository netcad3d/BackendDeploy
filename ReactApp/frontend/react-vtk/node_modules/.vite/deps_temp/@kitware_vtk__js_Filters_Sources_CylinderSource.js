import {
  vtkPolyData$1
} from "./chunk-XT2DETPC.js";
import "./chunk-Z2LVQNSU.js";
import {
  vtkDataArray$1
} from "./chunk-Z5OKWKLG.js";
import "./chunk-SWDS6M4V.js";
import {
  vtkMatrixBuilder
} from "./chunk-GQ6SS5ID.js";
import "./chunk-GC37RKNO.js";
import "./chunk-SXNZFZKA.js";
import "./chunk-FOWOP5PK.js";
import {
  _toConsumableArray,
  macro
} from "./chunk-OTTIIP4A.js";
import "./chunk-HKWV5KNA.js";
import "./chunk-XL65WI7U.js";
import "./chunk-HUBM7RA2.js";

// node_modules/@kitware/vtk.js/Filters/Sources/CylinderSource.js
function vtkCylinderSource(publicAPI, model) {
  model.classHierarchy.push("vtkCylinderSource");
  function requestData(inData, outData) {
    var _vtkMatrixBuilder$bui, _vtkMatrixBuilder$bui2;
    if (model.deleted) {
      return;
    }
    var dataset = outData[0];
    var angle = 2 * Math.PI / model.resolution;
    var numberOfPoints = 2 * model.resolution;
    var numberOfPolys = 5 * model.resolution;
    if (model.capping) {
      numberOfPoints = 4 * model.resolution;
      numberOfPolys = 7 * model.resolution + 2;
    }
    var points = macro.newTypedArray(model.pointType, numberOfPoints * 3);
    var cellLocation = 0;
    var polys = new Uint32Array(numberOfPolys);
    var normalsData = new Float32Array(numberOfPoints * 3);
    var normals = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      values: normalsData,
      name: "Normals"
    });
    var tcData = new Float32Array(numberOfPoints * 2);
    var tcoords = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcData,
      name: "TCoords"
    });
    var nbot = [0, 0, 0];
    var ntop = [0, 0, 0];
    var xbot = [0, 0, 0];
    var xtop = [0, 0, 0];
    var tcbot = [0, 0];
    var tctop = [0, 0];
    var otherRadius = model.otherRadius == null ? model.radius : model.otherRadius;
    for (var i = 0; i < model.resolution; i++) {
      nbot[0] = Math.cos(i * angle + model.initAngle);
      ntop[0] = nbot[0];
      xbot[0] = model.radius * nbot[0] + model.center[0];
      xtop[0] = xbot[0];
      tcbot[0] = Math.abs(2 * i / model.resolution - 1);
      tctop[0] = tcbot[0];
      xbot[1] = 0.5 * model.height + model.center[1];
      xtop[1] = -0.5 * model.height + model.center[1];
      tcbot[1] = 0;
      tctop[1] = 1;
      nbot[2] = -Math.sin(i * angle + model.initAngle);
      ntop[2] = nbot[2];
      xbot[2] = otherRadius * nbot[2] + model.center[2];
      xtop[2] = xbot[2];
      var pointIdx = 2 * i;
      for (var j = 0; j < 3; j++) {
        normalsData[pointIdx * 3 + j] = nbot[j];
        normalsData[(pointIdx + 1) * 3 + j] = ntop[j];
        points[pointIdx * 3 + j] = xbot[j];
        points[(pointIdx + 1) * 3 + j] = xtop[j];
        if (j < 2) {
          tcData[pointIdx * 2 + j] = tcbot[j];
          tcData[(pointIdx + 1) * 2 + j] = tctop[j];
        }
      }
    }
    for (var _i = 0; _i < model.resolution; _i++) {
      polys[cellLocation++] = 4;
      polys[cellLocation++] = 2 * _i;
      polys[cellLocation++] = 2 * _i + 1;
      var pt = (2 * _i + 3) % (2 * model.resolution);
      polys[cellLocation++] = pt;
      polys[cellLocation++] = pt - 1;
    }
    if (model.capping) {
      for (var _i2 = 0; _i2 < model.resolution; _i2++) {
        xbot[0] = model.radius * Math.cos(_i2 * angle + model.initAngle);
        xtop[0] = xbot[0];
        tcbot[0] = xbot[0];
        tctop[0] = xbot[0];
        xbot[0] += model.center[0];
        xtop[0] += model.center[0];
        nbot[1] = 1;
        ntop[1] = -1;
        xbot[1] = 0.5 * model.height + model.center[1];
        xtop[1] = -0.5 * model.height + model.center[1];
        xbot[2] = -otherRadius * Math.sin(_i2 * angle + model.initAngle);
        xtop[2] = xbot[2];
        tcbot[1] = xbot[2];
        tctop[1] = xbot[2];
        xbot[2] += model.center[2];
        xtop[2] += model.center[2];
        var botIdx = 2 * model.resolution + _i2;
        var topIdx = 3 * model.resolution + model.resolution - _i2 - 1;
        for (var _j = 0; _j < 3; _j++) {
          normalsData[3 * botIdx + _j] = nbot[_j];
          normalsData[3 * topIdx + _j] = ntop[_j];
          points[3 * botIdx + _j] = xbot[_j];
          points[3 * topIdx + _j] = xtop[_j];
          if (_j < 2) {
            tcData[2 * botIdx + _j] = tcbot[_j];
            tcData[2 * topIdx + _j] = tctop[_j];
          }
        }
      }
      polys[cellLocation++] = model.resolution;
      for (var _i3 = 0; _i3 < model.resolution; _i3++) {
        polys[cellLocation++] = 2 * model.resolution + _i3;
      }
      polys[cellLocation++] = model.resolution;
      for (var _i4 = 0; _i4 < model.resolution; _i4++) {
        polys[cellLocation++] = 3 * model.resolution + _i4;
      }
    }
    (_vtkMatrixBuilder$bui = (_vtkMatrixBuilder$bui2 = vtkMatrixBuilder.buildFromRadian()).translate.apply(_vtkMatrixBuilder$bui2, _toConsumableArray(model.center)).rotateFromDirections([0, 1, 0], model.direction)).translate.apply(_vtkMatrixBuilder$bui, _toConsumableArray(model.center.map(function(c) {
      return c * -1;
    }))).apply(points);
    dataset = vtkPolyData$1.newInstance();
    dataset.getPoints().setData(points, 3);
    dataset.getPolys().setData(polys, 1);
    dataset.getPointData().setNormals(normals);
    dataset.getPointData().setTCoords(tcoords);
    outData[0] = dataset;
  }
  publicAPI.requestData = requestData;
}
var DEFAULT_VALUES = {
  height: 1,
  initAngle: 0,
  radius: 1,
  resolution: 6,
  center: [0, 0, 0],
  direction: [0, 1, 0],
  capping: true,
  pointType: "Float64Array"
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["height", "initAngle", "otherRadius", "radius", "resolution", "capping"]);
  macro.setGetArray(publicAPI, model, ["center", "direction"], 3);
  macro.algo(publicAPI, model, 0, 1);
  vtkCylinderSource(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkCylinderSource");
var vtkCylinderSource$1 = {
  newInstance,
  extend
};

// dep:@kitware_vtk__js_Filters_Sources_CylinderSource
var kitware_vtk_js_Filters_Sources_CylinderSource_default = vtkCylinderSource$1;
export {
  kitware_vtk_js_Filters_Sources_CylinderSource_default as default,
  extend,
  newInstance
};
//# sourceMappingURL=@kitware_vtk__js_Filters_Sources_CylinderSource.js.map
