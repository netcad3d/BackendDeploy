{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Rendering/Core/AbstractMapper3D.js", "../../@kitware/vtk.js/Common/Core/LookupTable.js", "../../@kitware/vtk.js/Rendering/Core/Mapper/Static.js", "../../@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js", "../../@kitware/vtk.js/Rendering/Core/Mapper.js"],
  "sourcesContent": ["import vtkAbstractMapper from './AbstractMapper.js';\nimport { u as uninitializeBounds } from '../../Common/Core/Math/index.js';\n\n// vtkAbstractMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkAbstractMapper3D(publicAPI, model) {\n  publicAPI.getBounds = function () {\n    return 0;\n  };\n\n  publicAPI.getBounds = function (bounds) {\n    publicAPI.getBounds();\n\n    for (var i = 0; i < 6; i++) {\n      bounds[i] = model.bounds[i];\n    }\n  };\n\n  publicAPI.getCenter = function () {\n    publicAPI.getBounds();\n\n    for (var i = 0; i < 3; i++) {\n      model.center[i] = (model.bounds[2 * i + 1] + model.bounds[2 * i]) / 2.0;\n    }\n\n    return model.center.slice();\n  };\n\n  publicAPI.getLength = function () {\n    var diff = 0.0;\n    var l = 0.0;\n    publicAPI.getBounds();\n\n    for (var i = 0; i < 3; i++) {\n      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];\n      l += diff * diff;\n    }\n\n    return Math.sqrt(l);\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  bounds: [1, -1, 1, -1, 1, -1],\n  center: [0, 0, 0]\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkAbstractMapper.extend(publicAPI, model, initialValues);\n\n  if (!model.bounds) {\n    uninitializeBounds(model.bounds);\n  }\n\n  if (!model.center) {\n    model.center = [0.0, 0.0, 0.0];\n  }\n\n  vtkAbstractMapper3D(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar vtkAbstractMapper3D$1 = {\n  extend: extend\n};\n\nexport { vtkAbstractMapper3D$1 as default, extend };\n", "import macro from '../../macros.js';\nimport { i as isNan, h as hsv2rgb } from './Math/index.js';\nimport vtkScalarsToColors from './ScalarsToColors.js';\nimport { ScalarMappingTarget } from './ScalarsToColors/Constants.js';\nimport { VtkDataTypes } from './DataArray/Constants.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro; // ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n// Add module-level functions or api that you want to expose statically via\n// the next section...\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nvar BELOW_RANGE_COLOR_INDEX = 0;\nvar ABOVE_RANGE_COLOR_INDEX = 1;\nvar NAN_COLOR_INDEX = 2; // ----------------------------------------------------------------------------\n// vtkMyClass methods\n// ----------------------------------------------------------------------------\n\nfunction vtkLookupTable(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkLookupTable'); //----------------------------------------------------------------------------\n  // Description:\n  // Return true if all of the values defining the mapping have an opacity\n  // equal to 1. Default implementation return true.\n\n  publicAPI.isOpaque = function () {\n    if (model.opaqueFlagBuildTime.getMTime() < publicAPI.getMTime()) {\n      var opaque = true;\n\n      if (model.nanColor[3] < 1.0) {\n        opaque = 0;\n      }\n\n      if (model.useBelowRangeColor && model.belowRangeColor[3] < 1.0) {\n        opaque = 0;\n      }\n\n      if (model.useAboveRangeColor && model.aboveRangeColor[3] < 1.0) {\n        opaque = 0;\n      }\n\n      for (var i = 3; i < model.table.length && opaque; i += 4) {\n        if (model.table[i] < 255) {\n          opaque = false;\n        }\n      }\n\n      model.opaqueFlag = opaque;\n      model.opaqueFlagBuildTime.modified();\n    }\n\n    return model.opaqueFlag;\n  };\n\n  publicAPI.usingLogScale = function () {\n    return false;\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.getNumberOfAvailableColors = function () {\n    return model.table.length;\n  }; //----------------------------------------------------------------------------\n  // Apply shift/scale to the scalar value v and return the index.\n\n\n  publicAPI.linearIndexLookup = function (v, p) {\n    var dIndex = 0;\n\n    if (v < p.range[0]) {\n      dIndex = p.maxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;\n    } else if (v > p.range[1]) {\n      dIndex = p.maxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;\n    } else {\n      dIndex = (v + p.shift) * p.scale; // This conditional is needed because when v is very close to\n      // p.Range[1], it may map above p.MaxIndex in the linear mapping\n      // above.\n\n      dIndex = dIndex < p.maxIndex ? dIndex : p.maxIndex;\n    }\n\n    return Math.floor(dIndex);\n  };\n\n  publicAPI.linearLookup = function (v, table, p) {\n    var index = 0;\n\n    if (isNan(v)) {\n      index = Math.floor(p.maxIndex + 1.5 + NAN_COLOR_INDEX);\n    } else {\n      index = publicAPI.linearIndexLookup(v, p);\n    }\n\n    var offset = 4 * index;\n    return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];\n  };\n\n  publicAPI.indexedLookupFunction = function (v, table, p) {\n    var index = publicAPI.getAnnotatedValueIndexInternal(v);\n\n    if (index === -1) {\n      index = model.numberOfColors + NAN_COLOR_INDEX;\n    }\n\n    var offset = 4 * index;\n    return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];\n  }; //----------------------------------------------------------------------------\n\n\n  publicAPI.lookupShiftAndScale = function (range, p) {\n    p.shift = -range[0];\n    p.scale = Number.MAX_VALUE;\n\n    if (range[1] > range[0]) {\n      p.scale = (p.maxIndex + 1) / (range[1] - range[0]);\n    }\n  }; // Public API methods\n\n\n  publicAPI.mapScalarsThroughTable = function (input, output, outFormat, inputOffset) {\n    var lookupFunc = publicAPI.linearLookup;\n\n    if (model.indexedLookup) {\n      lookupFunc = publicAPI.indexedLookupFunction;\n    }\n\n    var trange = publicAPI.getMappingRange();\n    var p = {\n      maxIndex: publicAPI.getNumberOfColors() - 1,\n      range: trange,\n      shift: 0.0,\n      scale: 0.0\n    };\n    publicAPI.lookupShiftAndScale(trange, p);\n    var alpha = publicAPI.getAlpha();\n    var length = input.getNumberOfTuples();\n    var inIncr = input.getNumberOfComponents();\n    var outputV = output.getData();\n    var inputV = input.getData();\n\n    if (alpha >= 1.0) {\n      if (outFormat === ScalarMappingTarget.RGBA) {\n        for (var i = 0; i < length; i++) {\n          var cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);\n          outputV[i * 4] = cptr[0];\n          outputV[i * 4 + 1] = cptr[1];\n          outputV[i * 4 + 2] = cptr[2];\n          outputV[i * 4 + 3] = cptr[3];\n        }\n      }\n    } else {\n      /* eslint-disable no-lonely-if */\n      if (outFormat === ScalarMappingTarget.RGBA) {\n        for (var _i = 0; _i < length; _i++) {\n          var _cptr = lookupFunc(inputV[_i * inIncr + inputOffset], model.table, p);\n\n          outputV[_i * 4] = _cptr[0];\n          outputV[_i * 4 + 1] = _cptr[1];\n          outputV[_i * 4 + 2] = _cptr[2];\n          outputV[_i * 4 + 3] = Math.floor(_cptr[3] * alpha + 0.5);\n        }\n      }\n    } // alpha blending\n\n  };\n\n  publicAPI.forceBuild = function () {\n    var hinc = 0.0;\n    var sinc = 0.0;\n    var vinc = 0.0;\n    var ainc = 0.0;\n    var maxIndex = model.numberOfColors - 1;\n\n    if (maxIndex) {\n      hinc = (model.hueRange[1] - model.hueRange[0]) / maxIndex;\n      sinc = (model.saturationRange[1] - model.saturationRange[0]) / maxIndex;\n      vinc = (model.valueRange[1] - model.valueRange[0]) / maxIndex;\n      ainc = (model.alphaRange[1] - model.alphaRange[0]) / maxIndex;\n    }\n\n    var hsv = [];\n    var rgba = [];\n\n    for (var i = 0; i <= maxIndex; i++) {\n      hsv[0] = model.hueRange[0] + i * hinc;\n      hsv[1] = model.saturationRange[0] + i * sinc;\n      hsv[2] = model.valueRange[0] + i * vinc;\n      hsv2rgb(hsv, rgba);\n      rgba[3] = model.alphaRange[0] + i * ainc; //  case VTK_RAMP_LINEAR:\n\n      model.table[i * 4] = rgba[0] * 255.0 + 0.5;\n      model.table[i * 4 + 1] = rgba[1] * 255.0 + 0.5;\n      model.table[i * 4 + 2] = rgba[2] * 255.0 + 0.5;\n      model.table[i * 4 + 3] = rgba[3] * 255.0 + 0.5;\n    }\n\n    publicAPI.buildSpecialColors();\n    model.buildTime.modified();\n  };\n\n  publicAPI.setTable = function (table) {\n    if (table.getNumberOfComponents() !== 4) {\n      vtkErrorMacro('Expected 4 components for RGBA colors');\n      return;\n    }\n\n    if (table.getDataType() !== VtkDataTypes.UNSIGNED_CHAR) {\n      vtkErrorMacro('Expected unsigned char values for RGBA colors');\n      return;\n    }\n\n    model.numberOfColors = table.getNumberOfTuples();\n    var data = table.getData();\n\n    for (var i = 0; i < data.length; i++) {\n      model.table[i] = data[i];\n    }\n\n    publicAPI.buildSpecialColors();\n    model.insertTime.modified();\n    publicAPI.modified();\n  };\n\n  publicAPI.buildSpecialColors = function () {\n    // Add \"special\" colors (NaN, below range, above range) to table here.\n    var numberOfColors = model.numberOfColors;\n    var tptr = model.table;\n    var base = (numberOfColors + BELOW_RANGE_COLOR_INDEX) * 4; // Below range color\n\n    if (model.useBelowRangeColor || numberOfColors === 0) {\n      tptr[base] = model.belowRangeColor[0] * 255.0 + 0.5;\n      tptr[base + 1] = model.belowRangeColor[1] * 255.0 + 0.5;\n      tptr[base + 2] = model.belowRangeColor[2] * 255.0 + 0.5;\n      tptr[base + 3] = model.belowRangeColor[3] * 255.0 + 0.5;\n    } else {\n      // Duplicate the first color in the table.\n      tptr[base] = tptr[0];\n      tptr[base + 1] = tptr[1];\n      tptr[base + 2] = tptr[2];\n      tptr[base + 3] = tptr[3];\n    } // Above range color\n\n\n    base = (numberOfColors + ABOVE_RANGE_COLOR_INDEX) * 4;\n\n    if (model.useAboveRangeColor || numberOfColors === 0) {\n      tptr[base] = model.aboveRangeColor[0] * 255.0 + 0.5;\n      tptr[base + 1] = model.aboveRangeColor[1] * 255.0 + 0.5;\n      tptr[base + 2] = model.aboveRangeColor[2] * 255.0 + 0.5;\n      tptr[base + 3] = model.aboveRangeColor[3] * 255.0 + 0.5;\n    } else {\n      // Duplicate the last color in the table.\n      tptr[base] = tptr[4 * (numberOfColors - 1) + 0];\n      tptr[base + 1] = tptr[4 * (numberOfColors - 1) + 1];\n      tptr[base + 2] = tptr[4 * (numberOfColors - 1) + 2];\n      tptr[base + 3] = tptr[4 * (numberOfColors - 1) + 3];\n    } // Always use NanColor\n\n\n    base = (numberOfColors + NAN_COLOR_INDEX) * 4;\n    tptr[base] = model.nanColor[0] * 255.0 + 0.5;\n    tptr[base + 1] = model.nanColor[1] * 255.0 + 0.5;\n    tptr[base + 2] = model.nanColor[2] * 255.0 + 0.5;\n    tptr[base + 3] = model.nanColor[3] * 255.0 + 0.5;\n  };\n\n  publicAPI.build = function () {\n    if (model.table.length < 1 || publicAPI.getMTime() > model.buildTime.getMTime() && model.insertTime.getMTime() <= model.buildTime.getMTime()) {\n      publicAPI.forceBuild();\n    }\n  };\n\n  if (model.table.length > 0) {\n    // ensure insertTime is more recently modified than buildTime if\n    // a table is provided via the constructor\n    model.insertTime.modified();\n  }\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  numberOfColors: 256,\n  // table: null,\n  hueRange: [0.0, 0.66667],\n  saturationRange: [1.0, 1.0],\n  valueRange: [1.0, 1.0],\n  alphaRange: [1.0, 1.0],\n  nanColor: [0.5, 0.0, 0.0, 1.0],\n  belowRangeColor: [0.0, 0.0, 0.0, 1.0],\n  aboveRangeColor: [1.0, 1.0, 1.0, 1.0],\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n  alpha: 1.0 // buildTime: null,\n  // opaqueFlagBuildTime: null,\n  // insertTime: null,\n\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkScalarsToColors.extend(publicAPI, model, initialValues); // Internal objects initialization\n\n  if (!model.table) {\n    model.table = [];\n  }\n\n  model.buildTime = {};\n  macro.obj(model.buildTime);\n  model.opaqueFlagBuildTime = {};\n  macro.obj(model.opaqueFlagBuildTime, {\n    mtime: 0\n  });\n  model.insertTime = {};\n  macro.obj(model.insertTime, {\n    mtime: 0\n  }); // Create get-only macros\n\n  macro.get(publicAPI, model, ['buildTime']); // Create get-set macros\n\n  macro.setGet(publicAPI, model, ['numberOfColors', 'useAboveRangeColor', 'useBelowRangeColor']); // Create set macros for array (needs to know size)\n\n  macro.setArray(publicAPI, model, ['alphaRange', 'hueRange', 'saturationRange', 'valueRange'], 2);\n  macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4); // Create get macros for array\n\n  macro.getArray(publicAPI, model, ['hueRange', 'saturationRange', 'valueRange', 'alphaRange', 'nanColor', 'belowRangeColor', 'aboveRangeColor']); // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n\n  vtkLookupTable(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkLookupTable'); // ----------------------------------------------------------------------------\n\nvar vtkLookupTable$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkLookupTable$1 as default, extend, newInstance };\n", "var resolveCoincidentTopologyPolygonOffsetFaces = 1;\nvar resolveCoincidentTopology = 0;\nvar RESOLVE_COINCIDENT_TOPOLOGY_MODE = ['VTK_RESOLVE_OFF', 'VTK_RESOLVE_POLYGON_OFFSET'];\nfunction getResolveCoincidentTopologyPolygonOffsetFaces() {\n  return resolveCoincidentTopologyPolygonOffsetFaces;\n}\nfunction setResolveCoincidentTopologyPolygonOffsetFaces(value) {\n  resolveCoincidentTopologyPolygonOffsetFaces = value;\n}\nfunction getResolveCoincidentTopology() {\n  return resolveCoincidentTopology;\n}\nfunction setResolveCoincidentTopology() {\n  var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  resolveCoincidentTopology = mode;\n}\nfunction setResolveCoincidentTopologyToDefault() {\n  setResolveCoincidentTopology(0); // VTK_RESOLVE_OFF\n}\nfunction setResolveCoincidentTopologyToOff() {\n  setResolveCoincidentTopology(0); // VTK_RESOLVE_OFF\n}\nfunction setResolveCoincidentTopologyToPolygonOffset() {\n  setResolveCoincidentTopology(1); // VTK_RESOLVE_POLYGON_OFFSET\n}\nfunction getResolveCoincidentTopologyAsString() {\n  return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];\n}\nvar otherStaticMethods = {\n  getResolveCoincidentTopologyAsString: getResolveCoincidentTopologyAsString,\n  getResolveCoincidentTopologyPolygonOffsetFaces: getResolveCoincidentTopologyPolygonOffsetFaces,\n  getResolveCoincidentTopology: getResolveCoincidentTopology,\n  setResolveCoincidentTopology: setResolveCoincidentTopology,\n  setResolveCoincidentTopologyPolygonOffsetFaces: setResolveCoincidentTopologyPolygonOffsetFaces,\n  setResolveCoincidentTopologyToDefault: setResolveCoincidentTopologyToDefault,\n  setResolveCoincidentTopologyToOff: setResolveCoincidentTopologyToOff,\n  setResolveCoincidentTopologyToPolygonOffset: setResolveCoincidentTopologyToPolygonOffset\n};\n\nexport { RESOLVE_COINCIDENT_TOPOLOGY_MODE, otherStaticMethods as default, getResolveCoincidentTopology, getResolveCoincidentTopologyAsString, getResolveCoincidentTopologyPolygonOffsetFaces, setResolveCoincidentTopology, setResolveCoincidentTopologyPolygonOffsetFaces, setResolveCoincidentTopologyToDefault, setResolveCoincidentTopologyToOff, setResolveCoincidentTopologyToPolygonOffset };\n", "import otherStaticMethods from './Static.js';\nimport macro from '../../../macros.js';\n\n/* eslint-disable arrow-body-style */\n\nfunction addCoincidentTopologyMethods(publicAPI, model, nameList) {\n  nameList.forEach(function (item) {\n    publicAPI[\"get\".concat(item.method)] = function () {\n      return model[item.key];\n    };\n\n    publicAPI[\"set\".concat(item.method)] = function (factor, offset) {\n      model[item.key] = {\n        factor: factor,\n        offset: offset\n      };\n    };\n  });\n}\n\nvar CATEGORIES = ['Polygon', 'Line', 'Point']; // CoincidentTopology static methods ------------------------------------------\n\nvar staticOffsetModel = {\n  Polygon: {\n    factor: 2,\n    offset: 0\n  },\n  Line: {\n    factor: 1,\n    offset: -1\n  },\n  Point: {\n    factor: 0,\n    offset: -2\n  }\n};\nvar staticOffsetAPI = {};\naddCoincidentTopologyMethods(staticOffsetAPI, staticOffsetModel, CATEGORIES.map(function (key) {\n  return {\n    key: key,\n    method: \"ResolveCoincidentTopology\".concat(key, \"OffsetParameters\")\n  };\n}));\n\nfunction implementCoincidentTopologyMethods(publicAPI, model) {\n  if (model.resolveCoincidentTopology === undefined) {\n    model.resolveCoincidentTopology = false;\n  }\n\n  macro.setGet(publicAPI, model, ['resolveCoincidentTopology']); // Relative methods\n\n  model.topologyOffset = {\n    Polygon: {\n      factor: 0,\n      offset: 0\n    },\n    Line: {\n      factor: 0,\n      offset: 0\n    },\n    Point: {\n      factor: 0,\n      offset: 0\n    }\n  }; // Add Static methods to our instance\n\n  Object.keys(otherStaticMethods).forEach(function (methodName) {\n    publicAPI[methodName] = otherStaticMethods[methodName];\n  });\n  Object.keys(staticOffsetAPI).forEach(function (methodName) {\n    publicAPI[methodName] = staticOffsetAPI[methodName];\n  });\n  addCoincidentTopologyMethods(publicAPI, model.topologyOffset, CATEGORIES.map(function (key) {\n    return {\n      key: key,\n      method: \"RelativeCoincidentTopology\".concat(key, \"OffsetParameters\")\n    };\n  }));\n\n  publicAPI.getCoincidentTopologyPolygonOffsetParameters = function () {\n    var globalValue = staticOffsetAPI.getResolveCoincidentTopologyPolygonOffsetParameters();\n    var localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();\n    return {\n      factor: globalValue.factor + localValue.factor,\n      offset: globalValue.offset + localValue.offset\n    };\n  };\n\n  publicAPI.getCoincidentTopologyLineOffsetParameters = function () {\n    var globalValue = staticOffsetAPI.getResolveCoincidentTopologyLineOffsetParameters();\n    var localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();\n    return {\n      factor: globalValue.factor + localValue.factor,\n      offset: globalValue.offset + localValue.offset\n    };\n  };\n\n  publicAPI.getCoincidentTopologyPointOffsetParameter = function () {\n    var globalValue = staticOffsetAPI.getResolveCoincidentTopologyPointOffsetParameters();\n    var localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();\n    return {\n      factor: globalValue.factor + localValue.factor,\n      offset: globalValue.offset + localValue.offset\n    };\n  };\n}\n\nvar CoincidentTopologyHelper = {\n  implementCoincidentTopologyMethods: implementCoincidentTopologyMethods,\n  staticOffsetAPI: staticOffsetAPI,\n  otherStaticMethods: otherStaticMethods,\n  CATEGORIES: CATEGORIES\n};\n\nexport { CATEGORIES, CoincidentTopologyHelper as default };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport macro from '../../macros.js';\nimport vtkAbstractMapper3D from './AbstractMapper3D.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkLookupTable from '../../Common/Core/LookupTable.js';\nimport { O as createUninitializedBounds, i as isNan } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors/Constants.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\nimport Constants from './Mapper/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nimport { PassTypes } from '../OpenGL/HardwareSelector/Constants.js';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar FieldAssociations = vtkDataSet.FieldAssociations;\nvar staticOffsetAPI = CoincidentTopologyHelper.staticOffsetAPI,\n    otherStaticMethods = CoincidentTopologyHelper.otherStaticMethods;\nvar ColorMode = Constants.ColorMode,\n    ScalarMode = Constants.ScalarMode,\n    GetArray = Constants.GetArray;\nvar VectorMode = vtkScalarsToColors.VectorMode;\nvar VtkDataTypes = vtkDataArray.VtkDataTypes; // ----------------------------------------------------------------------------\n\nfunction notImplemented(method) {\n  return function () {\n    return macro.vtkErrorMacro(\"vtkMapper::\".concat(method, \" - NOT IMPLEMENTED\"));\n  };\n} // ----------------------------------------------------------------------------\n// vtkMapper methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMapper');\n\n  publicAPI.getBounds = function () {\n    var input = publicAPI.getInputData();\n\n    if (!input) {\n      model.bounds = createUninitializedBounds();\n    } else {\n      if (!model.static) {\n        publicAPI.update();\n      }\n\n      model.bounds = input.getBounds();\n    }\n\n    return model.bounds;\n  };\n\n  publicAPI.setForceCompileOnly = function (v) {\n    model.forceCompileOnly = v; // make sure we do NOT call modified()\n  };\n\n  publicAPI.createDefaultLookupTable = function () {\n    model.lookupTable = vtkLookupTable.newInstance();\n  };\n\n  publicAPI.getColorModeAsString = function () {\n    return macro.enumToString(ColorMode, model.colorMode);\n  };\n\n  publicAPI.setColorModeToDefault = function () {\n    return publicAPI.setColorMode(0);\n  };\n\n  publicAPI.setColorModeToMapScalars = function () {\n    return publicAPI.setColorMode(1);\n  };\n\n  publicAPI.setColorModeToDirectScalars = function () {\n    return publicAPI.setColorMode(2);\n  };\n\n  publicAPI.getScalarModeAsString = function () {\n    return macro.enumToString(ScalarMode, model.scalarMode);\n  };\n\n  publicAPI.setScalarModeToDefault = function () {\n    return publicAPI.setScalarMode(0);\n  };\n\n  publicAPI.setScalarModeToUsePointData = function () {\n    return publicAPI.setScalarMode(1);\n  };\n\n  publicAPI.setScalarModeToUseCellData = function () {\n    return publicAPI.setScalarMode(2);\n  };\n\n  publicAPI.setScalarModeToUsePointFieldData = function () {\n    return publicAPI.setScalarMode(3);\n  };\n\n  publicAPI.setScalarModeToUseCellFieldData = function () {\n    return publicAPI.setScalarMode(4);\n  };\n\n  publicAPI.setScalarModeToUseFieldData = function () {\n    return publicAPI.setScalarMode(5);\n  };\n\n  publicAPI.getAbstractScalars = function (input, scalarMode, arrayAccessMode, arrayId, arrayName) {\n    // make sure we have an input\n    if (!input || !model.scalarVisibility) {\n      return {\n        scalars: null,\n        cellFLag: false\n      };\n    }\n\n    var scalars = null;\n    var cellFlag = false; // get and scalar data according to scalar mode\n\n    if (scalarMode === ScalarMode.DEFAULT) {\n      scalars = input.getPointData().getScalars();\n\n      if (!scalars) {\n        scalars = input.getCellData().getScalars();\n        cellFlag = true;\n      }\n    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {\n      scalars = input.getPointData().getScalars();\n    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {\n      scalars = input.getCellData().getScalars();\n      cellFlag = true;\n    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {\n      var pd = input.getPointData();\n\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = pd.getArrayByIndex(arrayId);\n      } else {\n        scalars = pd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {\n      var cd = input.getCellData();\n      cellFlag = true;\n\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = cd.getArrayByIndex(arrayId);\n      } else {\n        scalars = cd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {\n      var fd = input.getFieldData();\n\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = fd.getArrayByIndex(arrayId);\n      } else {\n        scalars = fd.getArrayByName(arrayName);\n      }\n    }\n\n    return {\n      scalars: scalars,\n      cellFlag: cellFlag\n    };\n  };\n\n  publicAPI.mapScalars = function (input, alpha) {\n    var scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;\n\n    if (!scalars) {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      model.colorMapColors = null;\n      return;\n    } // we want to only recompute when something has changed\n\n\n    var toString = \"\".concat(publicAPI.getMTime()).concat(scalars.getMTime()).concat(alpha);\n    if (model.colorBuildString === toString) return;\n\n    if (!model.useLookupTableScalarRange) {\n      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);\n    } // Decide between texture color or vertex color.\n    // Cell data always uses vertex color.\n    // Only point data can use both texture and vertex coloring.\n\n\n    if (publicAPI.canUseTextureMapForColoring(input)) {\n      publicAPI.mapScalarsToTexture(scalars, alpha);\n    } else {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      var lut = publicAPI.getLookupTable();\n\n      if (lut) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);\n      }\n    }\n\n    model.colorBuildString = \"\".concat(publicAPI.getMTime()).concat(scalars.getMTime()).concat(alpha);\n  }; //-----------------------------------------------------------------------------\n\n\n  publicAPI.scalarToTextureCoordinate = function (scalarValue, // Input scalar\n  rangeMin, // range[0]\n  invRangeWidth) {\n    // 1/(range[1]-range[0])\n    var texCoordS = 0.5; // Scalar value is arbitrary when NaN\n\n    var texCoordT = 1.0; // 1.0 in t coordinate means NaN\n\n    if (!isNan(scalarValue)) {\n      // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?\n      // Because when you are mapping scalars and you have a NaN adjacent to\n      // anything else, the interpolation everywhere should be NaN.  Thus, I\n      // want the NaN color everywhere except right on the non-NaN neighbors.\n      // To simulate this, I set the t coord for the real numbers close to\n      // the threshold so that the interpolation almost immediately looks up\n      // the NaN value.\n      texCoordT = 0.49;\n      texCoordS = (scalarValue - rangeMin) * invRangeWidth; // Some implementations apparently don't handle relatively large\n      // numbers (compared to the range [0.0, 1.0]) very well. In fact,\n      // values above 1122.0f appear to cause texture wrap-around on\n      // some systems even when edge clamping is enabled. Why 1122.0f? I\n      // don't know. For safety, we'll clamp at +/- 1000. This will\n      // result in incorrect images when the texture value should be\n      // above or below 1000, but I don't have a better solution.\n\n      if (texCoordS > 1000.0) {\n        texCoordS = 1000.0;\n      } else if (texCoordS < -1000.0) {\n        texCoordS = -1000.0;\n      }\n    }\n\n    return {\n      texCoordS: texCoordS,\n      texCoordT: texCoordT\n    };\n  }; //-----------------------------------------------------------------------------\n\n\n  publicAPI.createColorTextureCoordinates = function (input, output, numScalars, numComps, component, range, tableRange, tableNumberOfColors, useLogScale) {\n    // We have to change the range used for computing texture\n    // coordinates slightly to accommodate the special above- and\n    // below-range colors that are the first and last texels,\n    // respectively.\n    var scalarTexelWidth = (range[1] - range[0]) / tableNumberOfColors;\n    var paddedRange = [];\n    paddedRange[0] = range[0] - scalarTexelWidth;\n    paddedRange[1] = range[1] + scalarTexelWidth;\n    var invRangeWidth = 1.0 / (paddedRange[1] - paddedRange[0]);\n    var outputV = output.getData();\n    var inputV = input.getData();\n    var count = 0;\n    var outputCount = 0;\n\n    if (component < 0 || component >= numComps) {\n      for (var scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n        var sum = 0;\n\n        for (var compIdx = 0; compIdx < numComps; ++compIdx) {\n          sum += inputV[count] * inputV[count];\n          count++;\n        }\n\n        var magnitude = Math.sqrt(sum);\n\n        if (useLogScale) {\n          magnitude = vtkLookupTable.applyLogScale(magnitude, tableRange, range);\n        }\n\n        var outputs = publicAPI.scalarToTextureCoordinate(magnitude, paddedRange[0], invRangeWidth);\n        outputV[outputCount] = outputs.texCoordS;\n        outputV[outputCount + 1] = outputs.texCoordT;\n        outputCount += 2;\n      }\n    } else {\n      count += component;\n\n      for (var _scalarIdx = 0; _scalarIdx < numScalars; ++_scalarIdx) {\n        var inputValue = inputV[count];\n\n        if (useLogScale) {\n          inputValue = vtkLookupTable.applyLogScale(inputValue, tableRange, range);\n        }\n\n        var _outputs = publicAPI.scalarToTextureCoordinate(inputValue, paddedRange[0], invRangeWidth);\n\n        outputV[outputCount] = _outputs.texCoordS;\n        outputV[outputCount + 1] = _outputs.texCoordT;\n        outputCount += 2;\n        count += numComps;\n      }\n    }\n  };\n\n  publicAPI.mapScalarsToTexture = function (scalars, alpha) {\n    var range = model.lookupTable.getRange();\n    var useLogScale = model.lookupTable.usingLogScale();\n\n    if (useLogScale) {\n      // convert range to log.\n      vtkLookupTable.getLogRange(range, range);\n    }\n\n    var origAlpha = model.lookupTable.getAlpha(); // Get rid of vertex color array.  Only texture or vertex coloring\n    // can be active at one time.  The existence of the array is the\n    // signal to use that technique.\n\n    model.colorMapColors = null; // If the lookup table has changed, then recreate the color texture map.\n    // Set a new lookup table changes this->MTime.\n\n    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {\n      model.lookupTable.setAlpha(alpha);\n      model.colorTextureMap = null; // Get the texture map from the lookup table.\n      // Create a dummy ramp of scalars.\n      // In the future, we could extend vtkScalarsToColors.\n\n      model.lookupTable.build();\n      var numberOfColors = model.lookupTable.getNumberOfAvailableColors();\n\n      if (numberOfColors > 4094) {\n        numberOfColors = 4094;\n      }\n\n      numberOfColors += 2;\n      var k = (range[1] - range[0]) / (numberOfColors - 1 - 2);\n      var newArray = new Float64Array(numberOfColors * 2);\n\n      for (var i = 0; i < numberOfColors; ++i) {\n        newArray[i] = range[0] + i * k - k; // minus k to start at below range color\n\n        if (useLogScale) {\n          newArray[i] = Math.pow(10.0, newArray[i]);\n        }\n      } // Dimension on NaN.\n\n\n      for (var _i = 0; _i < numberOfColors; ++_i) {\n        newArray[_i + numberOfColors] = NaN;\n      }\n\n      model.colorTextureMap = vtkImageData.newInstance();\n      model.colorTextureMap.setExtent(0, numberOfColors - 1, 0, 1, 0, 0);\n      var tmp = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: newArray\n      });\n      model.colorTextureMap.getPointData().setScalars(model.lookupTable.mapScalars(tmp, model.colorMode, 0));\n      model.lookupTable.setAlpha(origAlpha);\n    } // Create new coordinates if necessary.\n    // Need to compare lookup table in case the range has changed.\n\n\n    if (!model.colorCoordinates || publicAPI.getMTime() > model.colorCoordinates.getMTime() || publicAPI.getInputData(0).getMTime() > model.colorCoordinates.getMTime() || model.lookupTable.getMTime() > model.colorCoordinates.getMTime()) {\n      // Get rid of old colors\n      model.colorCoordinates = null; // Now create the color texture coordinates.\n\n      var numComps = scalars.getNumberOfComponents();\n      var num = scalars.getNumberOfTuples(); // const fArray = new FloatArray(num * 2);\n\n      model.colorCoordinates = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        values: new Float32Array(num * 2)\n      });\n      var scalarComponent = model.lookupTable.getVectorComponent(); // Although I like the feature of applying magnitude to single component\n      // scalars, it is not how the old MapScalars for vertex coloring works.\n\n      if (model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE && scalars.getNumberOfComponents() > 1) {\n        scalarComponent = -1;\n      }\n\n      publicAPI.createColorTextureCoordinates(scalars, model.colorCoordinates, num, numComps, scalarComponent, range, model.lookupTable.getRange(), model.colorTextureMap.getPointData().getScalars().getNumberOfTuples() / 2 - 2, useLogScale);\n    }\n  };\n\n  publicAPI.getIsOpaque = function () {\n    var lut = publicAPI.getLookupTable();\n\n    if (lut) {\n      // Ensure that the lookup table is built\n      lut.build();\n      return lut.isOpaque();\n    }\n\n    return true;\n  };\n\n  publicAPI.canUseTextureMapForColoring = function (input) {\n    if (!model.interpolateScalarsBeforeMapping) {\n      return false; // user doesn't want us to use texture maps at all.\n    } // index color does not use textures\n\n\n    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {\n      return false;\n    }\n\n    var gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    var scalars = gasResult.scalars;\n\n    if (!scalars) {\n      // no scalars on this dataset, we don't care if texture is used at all.\n      return false;\n    }\n\n    if (gasResult.cellFlag) {\n      return false; // cell data colors, don't use textures.\n    }\n\n    if (model.colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || model.colorMode === ColorMode.DIRECT_SCALARS) {\n      // Don't use texture is direct coloring using RGB unsigned chars is\n      // requested.\n      return false;\n    }\n\n    return true;\n  };\n\n  publicAPI.clearColorArrays = function () {\n    model.colorMapColors = null;\n    model.colorCoordinates = null;\n    model.colorTextureMap = null;\n  };\n\n  publicAPI.getLookupTable = function () {\n    if (!model.lookupTable) {\n      publicAPI.createDefaultLookupTable();\n    }\n\n    return model.lookupTable;\n  };\n\n  publicAPI.getMTime = function () {\n    var mt = model.mtime;\n\n    if (model.lookupTable !== null) {\n      var time = model.lookupTable.getMTime();\n      mt = time > mt ? time : mt;\n    }\n\n    return mt;\n  };\n\n  publicAPI.getPrimitiveCount = function () {\n    var input = publicAPI.getInputData();\n    var pcount = {\n      points: input.getPoints().getNumberOfValues() / 3,\n      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),\n      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),\n      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()\n    };\n    return pcount;\n  };\n\n  publicAPI.acquireInvertibleLookupTable = notImplemented('AcquireInvertibleLookupTable');\n  publicAPI.valueToColor = notImplemented('ValueToColor');\n  publicAPI.colorToValue = notImplemented('ColorToValue');\n  publicAPI.useInvertibleColorFor = notImplemented('UseInvertibleColorFor');\n  publicAPI.clearInvertibleColor = notImplemented('ClearInvertibleColor');\n\n  publicAPI.processSelectorPixelBuffers = function (selector, pixelOffsets) {\n    /* eslint-disable no-bitwise */\n    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {\n      return;\n    }\n\n    var rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);\n    var rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);\n    var currentPass = selector.getCurrentPass();\n    var fieldAssociation = selector.getFieldAssociation();\n    var idMap = null;\n\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      idMap = model.selectionWebGLIdsToVTKIds.points;\n    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {\n      idMap = model.selectionWebGLIdsToVTKIds.cells;\n    }\n\n    if (!idMap) {\n      return;\n    }\n\n    pixelOffsets.forEach(function (pos) {\n      if (currentPass === PassTypes.ID_LOW24) {\n        var inValue = 0;\n\n        if (rawHighData) {\n          inValue += rawHighData[pos];\n          inValue *= 256;\n        }\n\n        inValue += rawLowData[pos + 2];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        var outValue = idMap[inValue];\n        var lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);\n        lowData[pos] = outValue & 0xff;\n        lowData[pos + 1] = (outValue & 0xff00) >> 8;\n        lowData[pos + 2] = (outValue & 0xff0000) >> 16;\n      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {\n        var _inValue = 0;\n        _inValue += rawHighData[pos];\n        _inValue *= 256;\n        _inValue += rawLowData[pos];\n        _inValue *= 256;\n        _inValue += rawLowData[pos + 1];\n        _inValue *= 256;\n        _inValue += rawLowData[pos + 2];\n        var _outValue = idMap[_inValue];\n        var highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);\n        highData[pos] = (_outValue & 0xff000000) >> 24;\n      }\n    });\n    /* eslint-enable no-bitwise */\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  colorMapColors: null,\n  // Same as this->Colors\n  static: false,\n  lookupTable: null,\n  scalarVisibility: true,\n  scalarRange: [0, 1],\n  useLookupTableScalarRange: false,\n  colorMode: 0,\n  scalarMode: 0,\n  arrayAccessMode: 1,\n  // By_NAME\n  renderTime: 0,\n  colorByArrayName: null,\n  fieldDataTupleId: -1,\n  populateSelectionSettings: true,\n  selectionWebGLIdsToVTKIds: null,\n  interpolateScalarsBeforeMapping: false,\n  colorCoordinates: null,\n  colorTextureMap: null,\n  forceCompileOnly: 0,\n  useInvertibleColors: false,\n  invertibleScalars: null,\n  viewSpecificProperties: null,\n  customShaderAttributes: []\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance\n\n  vtkAbstractMapper3D.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['colorCoordinates', 'colorMapColors', 'colorTextureMap']);\n  macro.setGet(publicAPI, model, ['colorByArrayName', 'arrayAccessMode', 'colorMode', 'fieldDataTupleId', 'interpolateScalarsBeforeMapping', 'lookupTable', 'populateSelectionSettings', 'renderTime', 'scalarMode', 'scalarVisibility', 'selectionWebGLIdsToVTKIds', 'static', 'useLookupTableScalarRange', 'viewSpecificProperties', 'customShaderAttributes' // point data array names that will be transferred to the VBO\n  ]);\n  macro.setGetArray(publicAPI, model, ['scalarRange'], 2);\n\n  if (!model.viewSpecificProperties) {\n    model.viewSpecificProperties = {};\n  }\n\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model); // Object methods\n\n  vtkMapper(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkMapper'); // ----------------------------------------------------------------------------\n\nvar vtkMapper$1 = _objectSpread(_objectSpread(_objectSpread({\n  newInstance: newInstance,\n  extend: extend\n}, staticOffsetAPI), otherStaticMethods), Constants);\n\nexport { vtkMapper$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["DEFAULT_VALUES", "extend", "staticOffsetAPI", "otherStaticMethods", "VtkDataTypes", "DEFAULT_VALUES", "extend", "newInstance"]
}
