import "./chunk-B5BVLPZX.js";
import {
  DataAccessHelper
} from "./chunk-2MWAGLL3.js";
import {
  vtkPolyData$1
} from "./chunk-XT2DETPC.js";
import "./chunk-Z2LVQNSU.js";
import {
  vtkDataArray$1
} from "./chunk-Z5OKWKLG.js";
import "./chunk-SWDS6M4V.js";
import "./chunk-SXNZFZKA.js";
import "./chunk-FOWOP5PK.js";
import {
  macro
} from "./chunk-OTTIIP4A.js";
import "./chunk-HKWV5KNA.js";
import {
  _slicedToArray
} from "./chunk-XL65WI7U.js";
import "./chunk-HUBM7RA2.js";

// node_modules/@kitware/vtk.js/IO/Legacy/LegacyAsciiParser.js
var METHOD_MAPPING = {
  POINTS: "getPoints",
  VERTICES: "getVerts",
  LINES: "getLines",
  TRIANGLE_STRIPS: "getStrips",
  POLYGONS: "getPolys",
  POINT_DATA: "getPointData",
  CELL_DATA: "getCellData",
  FIELD: "getFieldData"
};
var DATATYPES = {
  bit: Uint8Array,
  unsigned_char: Uint8Array,
  char: Int8Array,
  unsigned_short: Uint16Array,
  short: Int16Array,
  unsigned_int: Uint32Array,
  int: Int32Array,
  unsigned_long: Uint32Array,
  long: Int32Array,
  float: Float32Array,
  double: Float64Array
};
var REGISTER_MAPPING = {
  SCALARS: "addArray",
  COLOR_SCALARS: "addArray",
  VECTORS: "setVectors",
  NORMALS: "setNormals",
  TEXTURE_COORDINATES: "setTCoords",
  TENSORS: "setTensors",
  FIELD: "addArray"
};
function createArrayHandler(array, setData, nbComponents) {
  var offset = 0;
  function fillWith(line) {
    line.split(" ").forEach(function(token) {
      if (token.length) {
        array[offset++] = Number(token);
      }
    });
    if (offset < array.length) {
      return true;
    }
    setData(array, nbComponents);
    return false;
  }
  return fillWith;
}
var GENERIC_CELL_HANDLER = {
  init: function init(line, dataModel) {
    var _line$split = line.split(" "), _line$split2 = _slicedToArray(_line$split, 3), name = _line$split2[0], nbCells = _line$split2[1], nbValues = _line$split2[2];
    var cellArray = dataModel.dataset[METHOD_MAPPING[name]]();
    cellArray.set({
      numberOfCells: Number(nbCells)
    }, true);
    dataModel.arrayHandler = createArrayHandler(new Uint32Array(Number(nbValues)), cellArray.setData, 1);
    return true;
  },
  parse: function parse(line, dataModel) {
    return dataModel.arrayHandler(line);
  }
};
var TYPE_PARSER = {
  DATASET: {
    init: function init2(line, datamodel) {
      var type = line.split(" ")[1];
      switch (type) {
        case "POLYDATA":
          datamodel.dataset = vtkPolyData$1.newInstance();
          break;
        default:
          console.error("Dataset of type ".concat(type, " not supported"));
      }
      return false;
    },
    parse: function parse2(line, datamodel) {
      return false;
    }
  },
  POINTS: {
    init: function init3(line, dataModel) {
      var _line$split3 = line.split(" "), _line$split4 = _slicedToArray(_line$split3, 3), name = _line$split4[0], size = _line$split4[1], type = _line$split4[2];
      var array = type === "float" ? new Float32Array(3 * Number(size)) : new Float64Array(3 * Number(size));
      var dataArray = dataModel.dataset.getPoints();
      dataArray.setName(name);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, 3);
      return true;
    },
    parse: function parse3(line, dataModel) {
      return dataModel.arrayHandler(line);
    }
  },
  METADATA: {
    init: function init4(line, dataModel) {
      return true;
    },
    parse: function parse4(line, dataModel) {
      return !!line.length;
    }
  },
  VERTICES: GENERIC_CELL_HANDLER,
  LINES: GENERIC_CELL_HANDLER,
  TRIANGLE_STRIPS: GENERIC_CELL_HANDLER,
  POLYGONS: GENERIC_CELL_HANDLER,
  POINT_DATA: {
    init: function init5(line, dataModel) {
      dataModel.POINT_DATA = Number(line.split(" ")[1]);
      dataModel.activeFieldLocation = "POINT_DATA";
      return false;
    },
    parse: function parse5(line, dataModel) {
      return false;
    }
  },
  CELL_DATA: {
    init: function init6(line, dataModel) {
      dataModel.CELL_DATA = Number(line.split(" ")[1]);
      dataModel.activeFieldLocation = "CELL_DATA";
      return false;
    },
    parse: function parse6(line, dataModel) {
      return false;
    }
  },
  SCALARS: {
    init: function init7(line, dataModel) {
      var _line$split5 = line.split(" "), _line$split6 = _slicedToArray(_line$split5, 4), type = _line$split6[0], name = _line$split6[1], dataType = _line$split6[2], numComp = _line$split6[3];
      var numOfComp = Number(numComp) > 0 ? Number(numComp) : 1;
      var size = dataModel[dataModel.activeFieldLocation] * numOfComp;
      var array = new DATATYPES[dataType](size);
      var dataArray = vtkDataArray$1.newInstance({
        name,
        empty: true
      });
      dataModel.dataset[METHOD_MAPPING[dataModel.activeFieldLocation]]()[REGISTER_MAPPING[type]](dataArray);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, numOfComp);
      return true;
    },
    parse: function parse7(line, dataModel) {
      if (line.split(" ")[0] === "LOOKUP_TABLE") {
        return true;
      }
      return dataModel.arrayHandler(line);
    }
  },
  COLOR_SCALARS: {
    init: function init8(line, dataModel) {
      var _line$split7 = line.split(" "), _line$split8 = _slicedToArray(_line$split7, 3), type = _line$split8[0], name = _line$split8[1], numComp = _line$split8[2];
      var numOfComp = Number(numComp) > 0 ? Number(numComp) : 1;
      var size = dataModel[dataModel.activeFieldLocation] * numOfComp;
      var array = new Uint8Array(size);
      var dataArray = vtkDataArray$1.newInstance({
        name,
        empty: true
      });
      dataModel.dataset[METHOD_MAPPING[dataModel.activeFieldLocation]]()[REGISTER_MAPPING[type]](dataArray);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, numOfComp);
      return true;
    },
    parse: function parse8(line, dataModel) {
      if (line.split(" ")[0] === "LOOKUP_TABLE") {
        return true;
      }
      return dataModel.arrayHandler(line);
    }
  },
  VECTORS: {
    init: function init9(line, dataModel) {
      var _line$split9 = line.split(" "), _line$split10 = _slicedToArray(_line$split9, 3), type = _line$split10[0], name = _line$split10[1], dataType = _line$split10[2];
      var size = dataModel[dataModel.activeFieldLocation] * 3;
      var array = new DATATYPES[dataType](size);
      var dataArray = vtkDataArray$1.newInstance({
        name,
        empty: true
      });
      dataModel.dataset[METHOD_MAPPING[dataModel.activeFieldLocation]]()[REGISTER_MAPPING[type]](dataArray);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, 3);
      return true;
    },
    parse: function parse9(line, dataModel) {
      return dataModel.arrayHandler(line);
    }
  },
  NORMALS: {
    init: function init10(line, dataModel) {
      var _line$split11 = line.split(" "), _line$split12 = _slicedToArray(_line$split11, 2), type = _line$split12[0], name = _line$split12[1];
      var size = dataModel[dataModel.activeFieldLocation] * 3;
      var array = new Float32Array(size);
      var dataArray = vtkDataArray$1.newInstance({
        name,
        empty: true
      });
      dataModel.dataset[METHOD_MAPPING[dataModel.activeFieldLocation]]()[REGISTER_MAPPING[type]](dataArray);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, 3);
      return true;
    },
    parse: function parse10(line, dataModel) {
      return dataModel.arrayHandler(line);
    }
  },
  TEXTURE_COORDINATES: {
    init: function init11(line, dataModel) {
      var _line$split13 = line.split(" "), _line$split14 = _slicedToArray(_line$split13, 4), type = _line$split14[0], name = _line$split14[1], numberOfComponents = _line$split14[2], dataType = _line$split14[3];
      var size = dataModel[dataModel.activeFieldLocation] * Number(numberOfComponents);
      var array = new DATATYPES[dataType](size);
      var dataArray = vtkDataArray$1.newInstance({
        name,
        empty: true
      });
      dataModel.dataset[METHOD_MAPPING[dataModel.activeFieldLocation]]()[REGISTER_MAPPING[type]](dataArray);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, 3);
      return true;
    },
    parse: function parse11(line, dataModel) {
      return dataModel.arrayHandler(line);
    }
  },
  TENSORS: {
    init: function init12(line, dataModel) {
      var _line$split15 = line.split(" "), _line$split16 = _slicedToArray(_line$split15, 3), type = _line$split16[0], name = _line$split16[1], dataType = _line$split16[2];
      var size = dataModel[dataModel.activeFieldLocation] * 9;
      var array = new DATATYPES[dataType](size);
      var dataArray = vtkDataArray$1.newInstance({
        name,
        empty: true
      });
      dataModel.dataset[METHOD_MAPPING[dataModel.activeFieldLocation]]()[REGISTER_MAPPING[type]](dataArray);
      dataModel.arrayHandler = createArrayHandler(array, dataArray.setData, 9);
      return true;
    },
    parse: function parse12(line, dataModel) {
      return dataModel.arrayHandler(line);
    }
  }
};
function getParser(line, dataModel) {
  var tokens = line.split(" ");
  return TYPE_PARSER[tokens[0]];
}
function parseLegacyASCII(content) {
  var dataModel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var parser = null;
  var separatorRegExp = /\r?\n/;
  var separatorRes = separatorRegExp.exec(content);
  var separator = separatorRes !== null ? separatorRes[0] : null;
  content.split(separator).forEach(function(line, index) {
    if (index < 2) {
      return;
    }
    if (!parser) {
      parser = getParser(line);
      if (!parser) {
        return;
      }
      parser = parser.init(line, dataModel) ? parser : null;
      return;
    }
    if (parser && !parser.parse(line, dataModel)) {
      parser = null;
    }
  });
  return dataModel;
}
var vtkLegacyAsciiParser = {
  parseLegacyASCII
};

// node_modules/@kitware/vtk.js/IO/Legacy/PolyDataReader.js
function vtkPolyDataReader(publicAPI, model) {
  model.classHierarchy.push("vtkPolyDataReader");
  if (!model.dataAccessHelper) {
    model.dataAccessHelper = DataAccessHelper.get("http");
  }
  function fetchData(url) {
    var compression = model.compression, progressCallback = model.progressCallback;
    return model.dataAccessHelper.fetchText(publicAPI, url, {
      compression,
      progressCallback
    });
  }
  publicAPI.setUrl = function(url) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    model.url = url;
    var path = url.split("/");
    path.pop();
    model.baseURL = path.join("/");
    model.compression = option.compression;
    return publicAPI.loadData({
      progressCallback: option.progressCallback
    });
  };
  publicAPI.loadData = function() {
    var promise = fetchData(model.url);
    promise.then(publicAPI.parseAsText);
    return promise;
  };
  publicAPI.parseAsText = function(content) {
    if (!content) {
      return;
    }
    if (content !== model.parseData) {
      publicAPI.modified();
    } else {
      return;
    }
    model.parseData = content;
    model.output[0] = vtkLegacyAsciiParser.parseLegacyASCII(model.parseData).dataset;
  };
  publicAPI.requestData = function(inData, outData) {
    publicAPI.parseAsText(model.parseData);
  };
}
var DEFAULT_VALUES = {};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["url", "baseURL"]);
  macro.setGet(publicAPI, model, ["dataAccessHelper"]);
  macro.algo(publicAPI, model, 0, 1);
  vtkPolyDataReader(publicAPI, model);
  if (!model.compression) {
    model.compression = null;
  }
  if (!model.progressCallback) {
    model.progressCallback = null;
  }
}
var newInstance = macro.newInstance(extend, "vtkPolyDataReader");
var vtkPolyDataReader$1 = {
  newInstance,
  extend
};

// dep:@kitware_vtk__js_IO_Legacy_PolyDataReader
var kitware_vtk_js_IO_Legacy_PolyDataReader_default = vtkPolyDataReader$1;
export {
  kitware_vtk_js_IO_Legacy_PolyDataReader_default as default,
  extend,
  newInstance
};
//# sourceMappingURL=@kitware_vtk__js_IO_Legacy_PolyDataReader.js.map
