import {
  Representation,
  vtkProperty$1
} from "./chunk-PIUKKK4M.js";
import {
  vtkDataArray$1
} from "./chunk-Z5OKWKLG.js";
import {
  mat4_exports,
  quat_exports,
  vec3_exports
} from "./chunk-GC37RKNO.js";
import {
  cross,
  isPowerOfTwo,
  nearestPowerOfTwo,
  normalize
} from "./chunk-FOWOP5PK.js";
import {
  _classCallCheck,
  _createClass,
  _toConsumableArray,
  get,
  macro,
  newInstance,
  newTypedArray,
  obj,
  set,
  setGet,
  vtkDebugMacro,
  vtkErrorMacro,
  vtkWarningMacro
} from "./chunk-OTTIIP4A.js";
import {
  _defineProperty
} from "./chunk-HKWV5KNA.js";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
var Wrap = {
  CLAMP_TO_EDGE: 0,
  REPEAT: 1,
  MIRRORED_REPEAT: 2
};
var Filter = {
  NEAREST: 0,
  LINEAR: 1,
  NEAREST_MIPMAP_NEAREST: 2,
  NEAREST_MIPMAP_LINEAR: 3,
  LINEAR_MIPMAP_NEAREST: 4,
  LINEAR_MIPMAP_LINEAR: 5
};
var Constants = {
  Wrap,
  Filter
};

// node_modules/@kitware/vtk.js/Common/Core/HalfFloat.js
var floatView = new Float32Array(1);
var int32View = new Int32Array(floatView.buffer);
function toHalf(val) {
  floatView[0] = val;
  var x = int32View[0];
  var bits = x >> 16 & 32768;
  var m = x >> 12 & 2047;
  var e = x >> 23 & 255;
  if (e < 103) {
    return bits;
  }
  if (e > 142) {
    bits |= 31744;
    bits |= (e === 255 ? 0 : 1) && x & 8388607;
    return bits;
  }
  if (e < 113) {
    m |= 2048;
    bits |= (m >> 114 - e) + (m >> 113 - e & 1);
    return bits;
  }
  bits |= e - 112 << 10 | m >> 1;
  bits += m & 1;
  return bits;
}
function fromHalf(h) {
  var s = (h & 32768) >> 15;
  var e = (h & 31744) >> 10;
  var f = h & 1023;
  if (e === 0) {
    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
  }
  if (e === 31) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
}
var HalfFloat = {
  fromHalf,
  toHalf
};

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var vtkErrorMacro2 = macro.vtkErrorMacro;
var PASS_TYPES = ["Build", "Render"];
function vtkViewNode(publicAPI, model) {
  model.classHierarchy.push("vtkViewNode");
  publicAPI.build = function(prepass) {
  };
  publicAPI.render = function(prepass) {
  };
  publicAPI.traverse = function(renderPass) {
    var passTraversal = renderPass.getTraverseOperation();
    var fn = publicAPI[passTraversal];
    if (fn) {
      fn(renderPass);
      return;
    }
    publicAPI.apply(renderPass, true);
    for (var index = 0; index < model.children.length; index++) {
      model.children[index].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.apply = function(renderPass, prepass) {
    var customRenderPass = publicAPI[renderPass.getOperation()];
    if (customRenderPass) {
      customRenderPass(prepass, renderPass);
    }
  };
  publicAPI.getViewNodeFor = function(dataObject) {
    if (model.renderable === dataObject) {
      return publicAPI;
    }
    for (var index = 0; index < model.children.length; ++index) {
      var child = model.children[index];
      var vn = child.getViewNodeFor(dataObject);
      if (vn) {
        return vn;
      }
    }
    return void 0;
  };
  publicAPI.getFirstAncestorOfType = function(type) {
    if (!model._parent) {
      return null;
    }
    if (model._parent.isA(type)) {
      return model._parent;
    }
    return model._parent.getFirstAncestorOfType(type);
  };
  publicAPI.addMissingNode = function(dobj) {
    if (!dobj) {
      return;
    }
    var result = model._renderableChildMap.get(dobj);
    if (result !== void 0) {
      result.setVisited(true);
    } else {
      var newNode = publicAPI.createViewNode(dobj);
      if (newNode) {
        newNode.setParent(publicAPI);
        newNode.setVisited(true);
        model._renderableChildMap.set(dobj, newNode);
        model.children.push(newNode);
      }
    }
  };
  publicAPI.addMissingNodes = function(dataObjs) {
    if (!dataObjs || !dataObjs.length) {
      return;
    }
    for (var index = 0; index < dataObjs.length; ++index) {
      var dobj = dataObjs[index];
      var result = model._renderableChildMap.get(dobj);
      if (result !== void 0) {
        result.setVisited(true);
      } else {
        var newNode = publicAPI.createViewNode(dobj);
        if (newNode) {
          newNode.setParent(publicAPI);
          newNode.setVisited(true);
          model._renderableChildMap.set(dobj, newNode);
          model.children.push(newNode);
        }
      }
    }
  };
  publicAPI.addMissingChildren = function(children) {
    if (!children || !children.length) {
      return;
    }
    for (var index = 0; index < children.length; ++index) {
      var child = children[index];
      var cindex = model.children.indexOf(child);
      if (cindex === -1) {
        child.setParent(publicAPI);
        model.children.push(child);
      }
      child.setVisited(true);
    }
  };
  publicAPI.prepareNodes = function() {
    for (var index = 0; index < model.children.length; ++index) {
      model.children[index].setVisited(false);
    }
  };
  publicAPI.setVisited = function(val) {
    model.visited = val;
  };
  publicAPI.removeUnusedNodes = function() {
    var deleted = null;
    for (var index = 0; index < model.children.length; ++index) {
      var child = model.children[index];
      var visited = child.getVisited();
      if (!visited) {
        var renderable = child.getRenderable();
        if (renderable) {
          model._renderableChildMap.delete(renderable);
        }
        if (!deleted) {
          deleted = [];
        }
        deleted.push(child);
      } else {
        child.setVisited(false);
      }
    }
    if (deleted) {
      model.children = model.children.filter(function(el) {
        return !deleted.includes(el);
      });
    }
  };
  publicAPI.createViewNode = function(dataObj) {
    if (!model.myFactory) {
      vtkErrorMacro2("Cannot create view nodes without my own factory");
      return null;
    }
    var ret = model.myFactory.createNode(dataObj);
    if (ret) {
      ret.setRenderable(dataObj);
    }
    return ret;
  };
}
var DEFAULT_VALUES = {
  renderable: null,
  myFactory: null,
  children: [],
  visited: false
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "event");
  model._renderableChildMap = /* @__PURE__ */ new Map();
  macro.get(publicAPI, model, ["visited"]);
  macro.setGet(publicAPI, model, ["_parent", "renderable", "myFactory"]);
  macro.getArray(publicAPI, model, ["children"]);
  macro.moveToProtected(publicAPI, model, ["parent"]);
  vtkViewNode(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend, "vtkViewNode");
var vtkViewNode$1 = {
  newInstance: newInstance2,
  extend,
  PASS_TYPES
};

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory.js
function vtkViewNodeFactory(publicAPI, model) {
  if (!model.overrides) {
    model.overrides = {};
  }
  model.classHierarchy.push("vtkViewNodeFactory");
  publicAPI.createNode = function(dataObject) {
    if (dataObject.isDeleted()) {
      return null;
    }
    var cpt = 0;
    var className = dataObject.getClassName(cpt++);
    var isObject = false;
    var keys = Object.keys(model.overrides);
    while (className && !isObject) {
      if (keys.indexOf(className) !== -1) {
        isObject = true;
      } else {
        className = dataObject.getClassName(cpt++);
      }
    }
    if (!isObject) {
      return null;
    }
    var vn = model.overrides[className]();
    vn.setMyFactory(publicAPI);
    return vn;
  };
  publicAPI.registerOverride = function(className, func) {
    model.overrides[className] = func;
  };
}
var DEFAULT_VALUES2 = {};
function extend2(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  macro.obj(publicAPI, model);
  vtkViewNodeFactory(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend2, "vtkViewNodeFactory");
var vtkViewNodeFactory$1 = {
  newInstance: newInstance3,
  extend: extend2
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var CLASS_MAPPING = /* @__PURE__ */ Object.create(null);
function registerOverride(className, fn) {
  CLASS_MAPPING[className] = fn;
}
function vtkOpenGLViewNodeFactory(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLViewNodeFactory");
}
var DEFAULT_VALUES3 = {};
function extend3(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  model.overrides = CLASS_MAPPING;
  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
  vtkOpenGLViewNodeFactory(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend3, "vtkOpenGLViewNodeFactory");
var vtkViewNodeFactory2 = {
  newInstance: newInstance4,
  extend: extend3
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var Wrap2 = Constants.Wrap;
var Filter2 = Constants.Filter;
var VtkDataTypes = vtkDataArray$1.VtkDataTypes;
var vtkDebugMacro2 = vtkDebugMacro;
var vtkErrorMacro3 = vtkErrorMacro;
var vtkWarningMacro2 = vtkWarningMacro;
function vtkOpenGLTexture(publicAPI, model) {
  var _this = this;
  model.classHierarchy.push("vtkOpenGLTexture");
  publicAPI.render = function() {
    var renWin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    if (renWin) {
      model._openGLRenderWindow = renWin;
    } else {
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model.openGLRenderer.getParent();
    }
    model.context = model._openGLRenderWindow.getContext();
    if (model.renderable.getInterpolate()) {
      if (model.generateMipmap) {
        publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
      } else {
        publicAPI.setMinificationFilter(Filter2.LINEAR);
      }
      publicAPI.setMagnificationFilter(Filter2.LINEAR);
    } else {
      publicAPI.setMinificationFilter(Filter2.NEAREST);
      publicAPI.setMagnificationFilter(Filter2.NEAREST);
    }
    if (model.renderable.getRepeat()) {
      publicAPI.setWrapR(Wrap2.REPEAT);
      publicAPI.setWrapS(Wrap2.REPEAT);
      publicAPI.setWrapT(Wrap2.REPEAT);
    }
    if (model.renderable.getInputData()) {
      model.renderable.setImage(null);
    }
    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {
      if (model.renderable.getImage() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {
          publicAPI.create2DFromImage(model.renderable.getImage());
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
      }
      if (model.renderable.getCanvas() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        var canvas = model.renderable.getCanvas();
        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes.UNSIGNED_CHAR, canvas, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      if (model.renderable.getJsImageData() !== null) {
        var jsid = model.renderable.getJsImageData();
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes.UNSIGNED_CHAR, jsid.data, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      var input = model.renderable.getInputData(0);
      if (input && input.getPointData().getScalars()) {
        var ext = input.getExtent();
        var inScalars = input.getPointData().getScalars();
        var data = [];
        for (var i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {
          var indata = model.renderable.getInputData(i);
          var scalars = indata ? indata.getPointData().getScalars().getData() : null;
          if (scalars) {
            data.push(scalars);
          }
        }
        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        if (data.length % 6 === 0) {
          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);
        } else {
          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());
        }
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
    }
    if (model.handle) {
      publicAPI.activate();
    }
  };
  publicAPI.destroyTexture = function() {
    publicAPI.deactivate();
    if (model.context && model.handle) {
      model.context.deleteTexture(model.handle);
    }
    model.handle = 0;
    model.numberOfDimensions = 0;
    model.target = 0;
    model.components = 0;
    model.width = 0;
    model.height = 0;
    model.depth = 0;
    publicAPI.resetFormatAndType();
  };
  publicAPI.createTexture = function() {
    if (!model.handle) {
      model.handle = model.context.createTexture();
      if (model.target) {
        model.context.bindTexture(model.target, model.handle);
        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
        if (model._openGLRenderWindow.getWebgl2()) {
          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
        }
        model.context.bindTexture(model.target, null);
      }
    }
  };
  publicAPI.getTextureUnit = function() {
    if (model._openGLRenderWindow) {
      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);
    }
    return -1;
  };
  publicAPI.activate = function() {
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.bind();
  };
  publicAPI.deactivate = function() {
    if (model._openGLRenderWindow) {
      model._openGLRenderWindow.deactivateTexture(publicAPI);
    }
  };
  publicAPI.releaseGraphicsResources = function(rwin) {
    if (rwin && model.handle) {
      rwin.activateTexture(publicAPI);
      rwin.deactivateTexture(publicAPI);
      model.context.deleteTexture(model.handle);
      model.handle = 0;
      model.numberOfDimensions = 0;
      model.target = 0;
      model.internalFormat = 0;
      model.format = 0;
      model.openGLDataType = 0;
      model.components = 0;
      model.width = 0;
      model.height = 0;
      model.depth = 0;
    }
    if (model.shaderProgram) {
      model.shaderProgram.releaseGraphicsResources(rwin);
      model.shaderProgram = null;
    }
  };
  publicAPI.bind = function() {
    model.context.bindTexture(model.target, model.handle);
    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {
      publicAPI.sendParameters();
    }
  };
  publicAPI.isBound = function() {
    var result = false;
    if (model.context && model.handle) {
      var target = 0;
      switch (model.target) {
        case model.context.TEXTURE_2D:
          target = model.context.TEXTURE_BINDING_2D;
          break;
        default:
          vtkWarningMacro2("impossible case");
          break;
      }
      var oid = model.context.getIntegerv(target);
      result = oid === model.handle;
    }
    return result;
  };
  publicAPI.sendParameters = function() {
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
    }
    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);
      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);
    }
    model.sendParametersTime.modified();
  };
  publicAPI.getInternalFormat = function(vtktype, numComps) {
    if (!model.internalFormat) {
      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);
    }
    if (!model.internalFormat) {
      vtkDebugMacro2("Unable to find suitable internal format for T=".concat(vtktype, " NC= ").concat(numComps));
    }
    return model.internalFormat;
  };
  publicAPI.getDefaultInternalFormat = function(vtktype, numComps) {
    var result = 0;
    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, false);
    if (result) {
      return result;
    }
    result = _this._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, true);
    if (!result) {
      vtkDebugMacro2("Unsupported internal texture type!");
      vtkDebugMacro2("Unable to find suitable internal format for T=".concat(vtktype, " NC= ").concat(numComps));
    }
    return result;
  };
  publicAPI.setInternalFormat = function(iFormat) {
    if (iFormat !== model.internalFormat) {
      model.internalFormat = iFormat;
      publicAPI.modified();
    }
  };
  publicAPI.getFormat = function(vtktype, numComps) {
    model.format = publicAPI.getDefaultFormat(vtktype, numComps);
    return model.format;
  };
  publicAPI.getDefaultFormat = function(vtktype, numComps) {
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (numComps) {
        case 1:
          return model.context.RED;
        case 2:
          return model.context.RG;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    } else {
      switch (numComps) {
        case 1:
          return model.context.LUMINANCE;
        case 2:
          return model.context.LUMINANCE_ALPHA;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    }
  };
  publicAPI.resetFormatAndType = function() {
    model.format = 0;
    model.internalFormat = 0;
    model.openGLDataType = 0;
  };
  publicAPI.getDefaultDataType = function(vtkScalarType) {
    var useHalfFloatType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (vtkScalarType) {
        case VtkDataTypes.UNSIGNED_CHAR:
          return model.context.UNSIGNED_BYTE;
        case (useHalfFloatType && VtkDataTypes.SHORT):
          return model.context.HALF_FLOAT;
        case (useHalfFloatType && VtkDataTypes.UNSIGNED_SHORT):
          return model.context.HALF_FLOAT;
        case VtkDataTypes.FLOAT:
        case VtkDataTypes.VOID:
        default:
          return model.context.FLOAT;
      }
    }
    switch (vtkScalarType) {
      case VtkDataTypes.UNSIGNED_CHAR:
        return model.context.UNSIGNED_BYTE;
      case VtkDataTypes.FLOAT:
      case VtkDataTypes.VOID:
      default:
        if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
          return model.context.FLOAT;
        }
        {
          var halfFloat = model.context.getExtension("OES_texture_half_float");
          if (halfFloat && model.context.getExtension("OES_texture_half_float_linear")) {
            return halfFloat.HALF_FLOAT_OES;
          }
        }
        return model.context.UNSIGNED_BYTE;
    }
  };
  publicAPI.getOpenGLDataType = function(vtkScalarType) {
    var useHalfFloatType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!model.openGLDataType) {
      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType, useHalfFloatType);
    }
    return model.openGLDataType;
  };
  publicAPI.getShiftAndScale = function() {
    var shift = 0;
    var scale = 1;
    switch (model.openGLDataType) {
      case model.context.BYTE:
        scale = 127.5;
        shift = scale - 128;
        break;
      case model.context.UNSIGNED_BYTE:
        scale = 255;
        shift = 0;
        break;
      case model.context.SHORT:
        scale = 32767.5;
        shift = scale - 32768;
        break;
      case model.context.UNSIGNED_SHORT:
        scale = 65536;
        shift = 0;
        break;
      case model.context.INT:
        scale = 21474836475e-1;
        shift = scale - 2147483648;
        break;
      case model.context.UNSIGNED_INT:
        scale = 4294967295;
        shift = 0;
        break;
      case model.context.FLOAT:
    }
    return {
      shift,
      scale
    };
  };
  publicAPI.getOpenGLFilterMode = function(emode) {
    switch (emode) {
      case Filter2.NEAREST:
        return model.context.NEAREST;
      case Filter2.LINEAR:
        return model.context.LINEAR;
      case Filter2.NEAREST_MIPMAP_NEAREST:
        return model.context.NEAREST_MIPMAP_NEAREST;
      case Filter2.NEAREST_MIPMAP_LINEAR:
        return model.context.NEAREST_MIPMAP_LINEAR;
      case Filter2.LINEAR_MIPMAP_NEAREST:
        return model.context.LINEAR_MIPMAP_NEAREST;
      case Filter2.LINEAR_MIPMAP_LINEAR:
        return model.context.LINEAR_MIPMAP_LINEAR;
      default:
        return model.context.NEAREST;
    }
  };
  publicAPI.getOpenGLWrapMode = function(vtktype) {
    switch (vtktype) {
      case Wrap2.CLAMP_TO_EDGE:
        return model.context.CLAMP_TO_EDGE;
      case Wrap2.REPEAT:
        return model.context.REPEAT;
      case Wrap2.MIRRORED_REPEAT:
        return model.context.MIRRORED_REPEAT;
      default:
        return model.context.CLAMP_TO_EDGE;
    }
  };
  function updateArrayDataType(dataType, data) {
    var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var pixData = [];
    var pixCount = model.width * model.height * model.components;
    if (depth) {
      pixCount *= model.depth;
    }
    if (dataType !== VtkDataTypes.FLOAT && model.openGLDataType === model.context.FLOAT) {
      for (var idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          var dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
          pixData.push(new Float32Array(dataArrayToCopy));
        } else {
          pixData.push(null);
        }
      }
    }
    if (dataType !== VtkDataTypes.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {
      for (var _idx = 0; _idx < data.length; _idx++) {
        if (data[_idx]) {
          var _dataArrayToCopy = data[_idx].length > pixCount ? data[_idx].subarray(0, pixCount) : data[_idx];
          pixData.push(new Uint8Array(_dataArrayToCopy));
        } else {
          pixData.push(null);
        }
      }
    }
    var halfFloatExt = model.context.getExtension("OES_texture_half_float");
    var halfFloat = model._openGLRenderWindow.getWebgl2() ? model.openGLDataType === model.context.HALF_FLOAT : halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    if (halfFloat) {
      for (var _idx2 = 0; _idx2 < data.length; _idx2++) {
        if (data[_idx2]) {
          var newArray = new Uint16Array(pixCount);
          for (var i = 0; i < pixCount; i++) {
            newArray[i] = HalfFloat.toHalf(data[_idx2][i]);
          }
          pixData.push(newArray);
        } else {
          pixData.push(null);
        }
      }
    }
    if (pixData.length === 0) {
      for (var _i = 0; _i < data.length; _i++) {
        pixData.push(data[_i]);
      }
    }
    return pixData;
  }
  function scaleTextureToHighestPowerOfTwo(data) {
    if (model._openGLRenderWindow.getWebgl2()) {
      return data;
    }
    var pixData = [];
    var width = model.width;
    var height = model.height;
    var numComps = model.components;
    if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {
      var halfFloat = model.context.getExtension("OES_texture_half_float");
      var newWidth = nearestPowerOfTwo(width);
      var newHeight = nearestPowerOfTwo(height);
      var pixCount = newWidth * newHeight * model.components;
      for (var idx = 0; idx < data.length; idx++) {
        if (data[idx] !== null) {
          var newArray = null;
          var jFactor = height / newHeight;
          var iFactor = width / newWidth;
          var usingHalf = false;
          if (model.openGLDataType === model.context.FLOAT) {
            newArray = new Float32Array(pixCount);
          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {
            newArray = new Uint16Array(pixCount);
            usingHalf = true;
          } else {
            newArray = new Uint8Array(pixCount);
          }
          for (var j = 0; j < newHeight; j++) {
            var joff = j * newWidth * numComps;
            var jidx = j * jFactor;
            var jlow = Math.floor(jidx);
            var jhi = Math.ceil(jidx);
            if (jhi >= height) {
              jhi = height - 1;
            }
            var jmix = jidx - jlow;
            var jmix1 = 1 - jmix;
            jlow = jlow * width * numComps;
            jhi = jhi * width * numComps;
            for (var i = 0; i < newWidth; i++) {
              var ioff = i * numComps;
              var iidx = i * iFactor;
              var ilow = Math.floor(iidx);
              var ihi = Math.ceil(iidx);
              if (ihi >= width) {
                ihi = width - 1;
              }
              var imix = iidx - ilow;
              ilow *= numComps;
              ihi *= numComps;
              for (var c = 0; c < numComps; c++) {
                if (usingHalf) {
                  newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);
                } else {
                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1 - imix) + data[idx][jhi + ihi + c] * jmix * imix;
                }
              }
            }
          }
          pixData.push(newArray);
          model.width = newWidth;
          model.height = newHeight;
        } else {
          pixData.push(null);
        }
      }
    }
    if (pixData.length === 0) {
      for (var _i2 = 0; _i2 < data.length; _i2++) {
        pixData.push(data[_i2]);
      }
    }
    return pixData;
  }
  publicAPI.create2DFromRaw = function(width, height, numComps, dataType, data) {
    var flip = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro3("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    var dataArray = [data];
    var pixData = updateArrayDataType(dataType, dataArray);
    var scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    if (flip) {
      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.createCubeFromRaw = function(width, height, numComps, dataType, data) {
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro3("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_CUBE_MAP;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    model.maxLevel = data.length / 6 - 1;
    publicAPI.createTexture();
    publicAPI.bind();
    var pixData = updateArrayDataType(dataType, data);
    var scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    var invertedData = [];
    var widthLevel = model.width;
    var heightLevel = model.height;
    for (var i = 0; i < scaledData.length; i++) {
      if (i % 6 === 0 && i !== 0) {
        widthLevel /= 2;
        heightLevel /= 2;
      }
      invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);
      for (var y = 0; y < heightLevel; ++y) {
        var row1 = y * widthLevel * model.components;
        var row2 = (heightLevel - y - 1) * widthLevel * model.components;
        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);
      }
    }
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    for (var _i3 = 0; _i3 < 6; _i3++) {
      var j = 0;
      var w = model.width;
      var h = model.height;
      while (w >= 1 && h >= 1) {
        var tempData = null;
        if (j <= model.maxLevel) {
          tempData = invertedData[6 * j + _i3];
        }
        model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + _i3, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);
        j++;
        w /= 2;
        h /= 2;
      }
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.createDepthFromRaw = function(width, height, dataType, data) {
    publicAPI.getOpenGLDataType(dataType);
    model.format = model.context.DEPTH_COMPONENT;
    if (model._openGLRenderWindow.getWebgl2()) {
      if (dataType === VtkDataTypes.FLOAT) {
        model.internalFormat = model.context.DEPTH_COMPONENT32F;
      } else {
        model.internalFormat = model.context.DEPTH_COMPONENT16;
      }
    } else {
      model.internalFormat = model.context.DEPTH_COMPONENT;
    }
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro3("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 1;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.create2DFromImage = function(image) {
    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);
    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);
    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro3("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 4;
    model.width = image.width;
    model.height = image.height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    var needNearestPowerOfTwo = !isPowerOfTwo(image.width) || !isPowerOfTwo(image.height);
    var canvas = document.createElement("canvas");
    canvas.width = needNearestPowerOfTwo ? nearestPowerOfTwo(image.width) : image.width;
    canvas.height = needNearestPowerOfTwo ? nearestPowerOfTwo(image.height) : image.height;
    var ctx = canvas.getContext("2d");
    ctx.translate(0, canvas.height);
    ctx.scale(1, -1);
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
    var safeImage = canvas;
    model.context.texImage2D(model.target, 0, model.internalFormat, model.format, model.openGLDataType, safeImage);
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    publicAPI.deactivate();
    return true;
  };
  function computeScaleOffsets(numComps, numPixelsIn, data) {
    var min = [];
    var max = [];
    for (var c = 0; c < numComps; ++c) {
      min[c] = data[c];
      max[c] = data[c];
    }
    var count = 0;
    for (var i = 0; i < numPixelsIn; ++i) {
      for (var _c = 0; _c < numComps; ++_c) {
        if (data[count] < min[_c]) {
          min[_c] = data[count];
        }
        if (data[count] > max[_c]) {
          max[_c] = data[count];
        }
        count++;
      }
    }
    var offset = [];
    var scale = [];
    for (var _c2 = 0; _c2 < numComps; ++_c2) {
      if (min[_c2] === max[_c2]) {
        max[_c2] = min[_c2] + 1;
      }
      offset[_c2] = min[_c2];
      scale[_c2] = max[_c2] - min[_c2];
    }
    return {
      scale,
      offset
    };
  }
  function hasExactHalfFloat(offset, scale) {
    for (var c = 0; c < offset.length; c++) {
      var min = offset[c];
      var max = scale[c] + min;
      if (min < -2048 || min > 2048 || max < -2048 || max > 2048) {
        return false;
      }
    }
    return true;
  }
  function checkUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {
    var useHalfFloatType = true;
    publicAPI.getOpenGLDataType(dataType, useHalfFloatType);
    var halfFloatExt = model.context.getExtension("OES_texture_half_float");
    var useHalfFloat = model._openGLRenderWindow.getWebgl2() ? model.openGLDataType === model.context.HALF_FLOAT : halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    if (!useHalfFloat) {
      return false;
    }
    if (!hasExactHalfFloat(offset, scale) && !preferSizeOverAccuracy) {
      return false;
    }
    return true;
  }
  publicAPI.create3DFromRaw = function(width, height, depth, numComps, dataType, data) {
    var useHalfFloatType = true;
    publicAPI.getOpenGLDataType(dataType, useHalfFloatType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro3("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_3D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = depth;
    model.numberOfDimensions = 3;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    var dataArray = [data];
    var is3DArray = true;
    var pixData = updateArrayDataType(dataType, dataArray, is3DArray);
    var scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.create3DFilterableFromRaw = function(width, height, depth, numComps, dataType, data) {
    var preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
    var numPixelsIn = width * height * depth;
    var offset = [];
    var scale = [];
    for (var c = 0; c < numComps; ++c) {
      offset[c] = 0;
      scale[c] = 1;
    }
    model.volumeInfo = {
      scale,
      offset,
      width,
      height,
      depth
    };
    var _computeScaleOffsets = computeScaleOffsets(numComps, numPixelsIn, data), computedOffset = _computeScaleOffsets.offset, computedScale = _computeScaleOffsets.scale;
    model.volumeInfo.dataComputedScale = computedScale;
    model.volumeInfo.dataComputedOffset = computedOffset;
    var useHalfFloat = checkUseHalfFloat(dataType, computedOffset, computedScale, preferSizeOverAccuracy);
    if (model._openGLRenderWindow.getWebgl2()) {
      if (dataType === VtkDataTypes.FLOAT || useHalfFloat && (dataType === VtkDataTypes.SHORT || dataType === VtkDataTypes.UNSIGNED_SHORT)) {
        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
      }
      if (dataType === VtkDataTypes.UNSIGNED_CHAR) {
        for (var _c3 = 0; _c3 < numComps; ++_c3) {
          model.volumeInfo.scale[_c3] = 255;
        }
        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
      }
      var _newArray = new Float32Array(numPixelsIn * numComps);
      model.volumeInfo.offset = computedOffset;
      model.volumeInfo.scale = computedScale;
      var count = 0;
      var scaleInverse = computedScale.map(function(s) {
        return 1 / s;
      });
      for (var i = 0; i < numPixelsIn; i++) {
        for (var nc = 0; nc < numComps; nc++) {
          _newArray[count] = (data[count] - computedOffset[nc]) * scaleInverse[nc];
          count++;
        }
      }
      return publicAPI.create3DFromRaw(width, height, depth, numComps, VtkDataTypes.FLOAT, _newArray);
    }
    var res = computeScaleOffsets(numComps, numPixelsIn, data);
    var volCopyData = function volCopyData2(outArray, outIdx2, inValue, smin, smax) {
      outArray[outIdx2] = inValue;
    };
    var dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;
    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {
      for (var _c4 = 0; _c4 < numComps; ++_c4) {
        res.offset[_c4] = 0;
        res.scale[_c4] = 255;
      }
    } else if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
      dataTypeToUse = VtkDataTypes.FLOAT;
      volCopyData = function volCopyData2(outArray, outIdx2, inValue, soffset, sscale) {
        outArray[outIdx2] = (inValue - soffset) / sscale;
      };
    } else {
      dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;
      volCopyData = function volCopyData2(outArray, outIdx2, inValue, soffset, sscale) {
        outArray[outIdx2] = 255 * (inValue - soffset) / sscale;
      };
    }
    publicAPI.getOpenGLDataType(dataTypeToUse);
    publicAPI.getInternalFormat(dataTypeToUse, numComps);
    publicAPI.getFormat(dataTypeToUse, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro3("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.depth = 1;
    model.numberOfDimensions = 2;
    var maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes.FLOAT || numComps >= 3)) {
      maxTexDim = 4096;
    }
    var xstride = 1;
    var ystride = 1;
    if (numPixelsIn > maxTexDim * maxTexDim) {
      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));
      ystride = xstride;
    }
    var targetWidth = Math.sqrt(numPixelsIn) / xstride;
    targetWidth = nearestPowerOfTwo(targetWidth);
    var xreps = Math.floor(targetWidth * xstride / width);
    var yreps = Math.ceil(depth / xreps);
    var targetHeight = nearestPowerOfTwo(height * yreps / ystride);
    model.width = targetWidth;
    model.height = targetHeight;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.volumeInfo.xreps = xreps;
    model.volumeInfo.yreps = yreps;
    model.volumeInfo.xstride = xstride;
    model.volumeInfo.ystride = ystride;
    model.volumeInfo.offset = res.offset;
    model.volumeInfo.scale = res.scale;
    var newArray;
    var pixCount = targetWidth * targetHeight * numComps;
    if (dataTypeToUse === VtkDataTypes.FLOAT) {
      newArray = new Float32Array(pixCount);
    } else {
      newArray = new Uint8Array(pixCount);
    }
    var outIdx = 0;
    var tileWidth = Math.floor(width / xstride);
    var tileHeight = Math.floor(height / ystride);
    for (var yRep = 0; yRep < yreps; yRep++) {
      var xrepsThisRow = Math.min(xreps, depth - yRep * xreps);
      var outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));
      for (var tileY = 0; tileY < tileHeight; tileY++) {
        for (var xRep = 0; xRep < xrepsThisRow; xRep++) {
          var inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);
          for (var tileX = 0; tileX < tileWidth; tileX++) {
            for (var _nc = 0; _nc < numComps; _nc++) {
              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + _nc], res.offset[_nc], res.scale[_nc]);
              outIdx++;
            }
          }
        }
        outIdx += outXContIncr;
      }
    }
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);
    publicAPI.deactivate();
    return true;
  };
  publicAPI.setOpenGLRenderWindow = function(rw) {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getMaximumTextureSize = function(ctx) {
    if (ctx && ctx.isCurrent()) {
      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);
    }
    return -1;
  };
}
var DEFAULT_VALUES4 = {
  _openGLRenderWindow: null,
  context: null,
  handle: 0,
  sendParametersTime: null,
  textureBuildTime: null,
  numberOfDimensions: 0,
  target: 0,
  format: 0,
  openGLDataType: 0,
  components: 0,
  width: 0,
  height: 0,
  depth: 0,
  autoParameters: true,
  wrapS: Wrap2.CLAMP_TO_EDGE,
  wrapT: Wrap2.CLAMP_TO_EDGE,
  wrapR: Wrap2.CLAMP_TO_EDGE,
  minificationFilter: Filter2.NEAREST,
  magnificationFilter: Filter2.NEAREST,
  minLOD: -1e3,
  maxLOD: 1e3,
  baseLevel: 0,
  maxLevel: 1e3,
  generateMipmap: false
};
function extend4(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.sendParametersTime = {};
  obj(model.sendParametersTime, {
    mtime: 0
  });
  model.textureBuildTime = {};
  obj(model.textureBuildTime, {
    mtime: 0
  });
  set(publicAPI, model, ["format", "openGLDataType"]);
  setGet(publicAPI, model, ["keyMatrixTime", "minificationFilter", "magnificationFilter", "wrapS", "wrapT", "wrapR", "generateMipmap"]);
  get(publicAPI, model, ["width", "height", "volumeInfo", "components", "handle", "target"]);
  vtkOpenGLTexture(publicAPI, model);
}
var newInstance5 = newInstance(extend4, "vtkOpenGLTexture");
var vtkOpenGLTexture$1 = _objectSpread({
  newInstance: newInstance5,
  extend: extend4
}, Constants);
registerOverride("vtkTexture", newInstance5);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Shader.js
var vtkErrorMacro4 = macro.vtkErrorMacro;
function vtkShader(publicAPI, model) {
  model.classHierarchy.push("vtkShader");
  publicAPI.compile = function() {
    var stype = model.context.VERTEX_SHADER;
    if (!model.source || !model.source.length || model.shaderType === "Unknown") {
      return false;
    }
    if (model.handle !== 0) {
      model.context.deleteShader(model.handle);
      model.handle = 0;
    }
    switch (model.shaderType) {
      case "Fragment":
        stype = model.context.FRAGMENT_SHADER;
        break;
      case "Vertex":
      default:
        stype = model.context.VERTEX_SHADER;
        break;
    }
    model.handle = model.context.createShader(stype);
    model.context.shaderSource(model.handle, model.source);
    model.context.compileShader(model.handle);
    var isCompiled = model.context.getShaderParameter(model.handle, model.context.COMPILE_STATUS);
    if (!isCompiled) {
      var lastError = model.context.getShaderInfoLog(model.handle);
      vtkErrorMacro4("Error compiling shader '".concat(model.source, "': ").concat(lastError));
      model.context.deleteShader(model.handle);
      model.handle = 0;
      return false;
    }
    return true;
  };
  publicAPI.cleanup = function() {
    if (model.shaderType === "Unknown" || model.handle === 0) {
      return;
    }
    model.context.deleteShader(model.handle);
    model.handle = 0;
    model.dirty = true;
  };
}
var DEFAULT_VALUES5 = {
  shaderType: "Unknown",
  source: "",
  error: "",
  handle: 0,
  dirty: false,
  context: null
};
function extend5(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["shaderType", "source", "error", "handle", "context"]);
  vtkShader(publicAPI, model);
}
var newInstance6 = macro.newInstance(extend5, "vtkShader");
var vtkShader$1 = {
  newInstance: newInstance6,
  extend: extend5
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js
var vtkErrorMacro5 = macro.vtkErrorMacro;
function substitute(source, search, replace) {
  var all = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var replaceStr = Array.isArray(replace) ? replace.join("\n") : replace;
  var replaced = false;
  if (source.search(search) !== -1) {
    replaced = true;
  }
  var gflag = "";
  if (all) {
    gflag = "g";
  }
  var regex = new RegExp(search, gflag);
  var resultstr = source.replace(regex, replaceStr);
  return {
    replace: replaced,
    result: resultstr
  };
}
function vtkShaderProgram(publicAPI, model) {
  model.classHierarchy.push("vtkShaderProgram");
  publicAPI.compileShader = function() {
    if (!model.vertexShader.compile()) {
      vtkErrorMacro5(model.vertexShader.getSource().split("\n").map(function(line, index) {
        return "".concat(index, ": ").concat(line);
      }).join("\n"));
      vtkErrorMacro5(model.vertexShader.getError());
      return 0;
    }
    if (!model.fragmentShader.compile()) {
      vtkErrorMacro5(model.fragmentShader.getSource().split("\n").map(function(line, index) {
        return "".concat(index, ": ").concat(line);
      }).join("\n"));
      vtkErrorMacro5(model.fragmentShader.getError());
      return 0;
    }
    if (!publicAPI.attachShader(model.vertexShader)) {
      vtkErrorMacro5(model.error);
      return 0;
    }
    if (!publicAPI.attachShader(model.fragmentShader)) {
      vtkErrorMacro5(model.error);
      return 0;
    }
    if (!publicAPI.link()) {
      vtkErrorMacro5("Links failed: ".concat(model.error));
      return 0;
    }
    publicAPI.setCompiled(true);
    return 1;
  };
  publicAPI.cleanup = function() {
    if (model.shaderType === "Unknown" || model.handle === 0) {
      return;
    }
    model.context.deleteShader(model.handle);
    model.handle = 0;
  };
  publicAPI.bind = function() {
    if (!model.linked && !publicAPI.link()) {
      return false;
    }
    model.context.useProgram(model.handle);
    publicAPI.setBound(true);
    return true;
  };
  publicAPI.isBound = function() {
    return !!model.bound;
  };
  publicAPI.release = function() {
    model.context.useProgram(null);
    publicAPI.setBound(false);
  };
  publicAPI.setContext = function(ctx) {
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.link = function() {
    if (model.inked) {
      return true;
    }
    if (model.handle === 0) {
      model.error = "Program has not been initialized, and/or does not have shaders.";
      return false;
    }
    model.uniformLocs = {};
    model.context.linkProgram(model.handle);
    var isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);
    if (!isCompiled) {
      var lastError = model.context.getProgramInfoLog(model.handle);
      vtkErrorMacro5("Error linking shader ".concat(lastError));
      model.handle = 0;
      return false;
    }
    publicAPI.setLinked(true);
    model.attributeLocs = {};
    return true;
  };
  publicAPI.setUniformMatrix = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    var f32 = new Float32Array(v);
    model.context.uniformMatrix4fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformMatrix3x3 = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    var f32 = new Float32Array(v);
    model.context.uniformMatrix3fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformf = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform1f(location, v);
    return true;
  };
  publicAPI.setUniformfv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform1fv(location, v);
    return true;
  };
  publicAPI.setUniformi = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform1i(location, v);
    return true;
  };
  publicAPI.setUniformiv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform1iv(location, v);
    return true;
  };
  publicAPI.setUniform2f = function(name, v1, v2) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    if (v2 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform2f(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2fv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform2fv(location, v);
    return true;
  };
  publicAPI.setUniform2i = function(name, v1, v2) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    if (v2 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform2i(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2iv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform2iv(location, v);
    return true;
  };
  publicAPI.setUniform3f = function(name, a1, a2, a3) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    if (a3 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3f(location, a1, a2, a3);
    return true;
  };
  publicAPI.setUniform3fArray = function(name, a) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    if (!Array.isArray(a) || a.length !== 3) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3f(location, a[0], a[1], a[2]);
    return true;
  };
  publicAPI.setUniform3fv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform3fv(location, v);
    return true;
  };
  publicAPI.setUniform3i = function(name) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 3) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3i(location, array[0], array[1], array[2]);
    return true;
  };
  publicAPI.setUniform3iv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform3iv(location, v);
    return true;
  };
  publicAPI.setUniform4f = function(name) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    var array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform4f(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4fv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform4fv(location, v);
    return true;
  };
  publicAPI.setUniform4i = function(name) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    var array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform4i(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4iv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform4iv(location, v);
    return true;
  };
  publicAPI.findUniform = function(name) {
    if (!name || !model.linked) {
      return -1;
    }
    var loc = model.uniformLocs[name];
    if (loc !== void 0) {
      return loc;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    if (loc === null) {
      model.error = "Uniform ".concat(name, " not found in current shader program.");
      model.uniformLocs[name] = -1;
      return -1;
    }
    model.uniformLocs[name] = loc;
    return loc;
  };
  publicAPI.isUniformUsed = function(name) {
    if (!name) {
      return false;
    }
    var loc = model.uniformLocs[name];
    if (loc !== void 0) {
      return loc !== null;
    }
    if (!model.linked) {
      vtkErrorMacro5("attempt to find uniform when the shader program is not linked");
      return false;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    model.uniformLocs[name] = loc;
    if (loc === null) {
      return false;
    }
    return true;
  };
  publicAPI.isAttributeUsed = function(name) {
    if (!name) {
      return false;
    }
    if (name in model.attributeLocs) {
      return true;
    }
    if (!model.linked) {
      vtkErrorMacro5("attempt to find uniform when the shader program is not linked");
      return false;
    }
    var loc = model.context.getAttribLocation(model.handle, name);
    if (loc === -1) {
      return false;
    }
    model.attributeLocs[name] = loc;
    return true;
  };
  publicAPI.attachShader = function(shader) {
    if (shader.getHandle() === 0) {
      model.error = "Shader object was not initialized, cannot attach it.";
      return false;
    }
    if (shader.getShaderType() === "Unknown") {
      model.error = "Shader object is of type Unknown and cannot be used.";
      return false;
    }
    if (model.handle === 0) {
      var thandle = model.context.createProgram();
      if (thandle === 0) {
        model.error = "Could not create shader program.";
        return false;
      }
      model.handle = thandle;
      model.linked = false;
    }
    if (shader.getShaderType() === "Vertex") {
      if (model.vertexShaderHandle !== 0) {
        model.comntext.detachShader(model.handle, model.vertexShaderHandle);
      }
      model.vertexShaderHandle = shader.getHandle();
    }
    if (shader.getShaderType() === "Fragment") {
      if (model.fragmentShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.fragmentShaderHandle);
      }
      model.fragmentShaderHandle = shader.getHandle();
    }
    model.context.attachShader(model.handle, shader.getHandle());
    publicAPI.setLinked(false);
    return true;
  };
  publicAPI.detachShader = function(shader) {
    if (shader.getHandle() === 0) {
      model.error = "shader object was not initialized, cannot attach it.";
      return false;
    }
    if (shader.getShaderType() === "Unknown") {
      model.error = "Shader object is of type Unknown and cannot be used.";
      return false;
    }
    if (model.handle === 0) {
      model.error = "This shader program has not been initialized yet.";
    }
    switch (shader.getShaderType()) {
      case "Vertex":
        if (model.vertexShaderHandle !== shader.getHandle()) {
          model.error = "The supplied shader was not attached to this program.";
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.vertexShaderHandle = 0;
        model.linked = false;
        return true;
      case "Fragment":
        if (model.fragmentShaderHandle !== shader.getHandle()) {
          model.error = "The supplied shader was not attached to this program.";
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.fragmentShaderHandle = 0;
        model.linked = false;
        return true;
      default:
        return false;
    }
  };
  publicAPI.setContext = function(ctx) {
    model.context = ctx;
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.setLastCameraMTime = function(mtime) {
    model.lastCameraMTime = mtime;
  };
}
var DEFAULT_VALUES6 = {
  vertexShaderHandle: 0,
  fragmentShaderHandle: 0,
  geometryShaderHandle: 0,
  vertexShader: null,
  fragmentShader: null,
  geometryShader: null,
  linked: false,
  bound: false,
  compiled: false,
  error: "",
  handle: 0,
  numberOfOutputs: 0,
  attributesLocs: null,
  uniformLocs: null,
  md5Hash: 0,
  context: null,
  lastCameraMTime: null
};
function extend6(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  model.attributesLocs = {};
  model.uniformLocs = {};
  model.vertexShader = vtkShader$1.newInstance();
  model.vertexShader.setShaderType("Vertex");
  model.fragmentShader = vtkShader$1.newInstance();
  model.fragmentShader.setShaderType("Fragment");
  model.geometryShader = vtkShader$1.newInstance();
  model.geometryShader.setShaderType("Geometry");
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["lastCameraMTime"]);
  macro.setGet(publicAPI, model, ["error", "handle", "compiled", "bound", "md5Hash", "vertexShader", "fragmentShader", "geometryShader", "linked"]);
  vtkShaderProgram(publicAPI, model);
}
var newInstance7 = macro.newInstance(extend6, "vtkShaderProgram");
var vtkShaderProgram$1 = {
  newInstance: newInstance7,
  extend: extend6,
  substitute
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject/Constants.js
var ObjectType = {
  ARRAY_BUFFER: 0,
  ELEMENT_ARRAY_BUFFER: 1,
  TEXTURE_BUFFER: 2
};
var Constants2 = {
  ObjectType
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js
function vtkOpenGLVertexArrayObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVertexArrayObject");
  publicAPI.exposedMethod = function() {
  };
  publicAPI.initialize = function() {
    model.instancingExtension = null;
    if (!model._openGLRenderWindow.getWebgl2()) {
      model.instancingExtension = model.context.getExtension("ANGLE_instanced_arrays");
    }
    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {
      model.extension = null;
      model.supported = true;
      model.handleVAO = model.context.createVertexArray();
    } else {
      model.extension = model.context.getExtension("OES_vertex_array_object");
      if (!model.forceEmulation && model.extension) {
        model.supported = true;
        model.handleVAO = model.extension.createVertexArrayOES();
      } else {
        model.supported = false;
      }
    }
  };
  publicAPI.isReady = function() {
    return model.handleVAO !== 0 || model.supported === false;
  };
  publicAPI.bind = function() {
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(model.handleVAO);
      } else {
        model.context.bindVertexArray(model.handleVAO);
      }
    } else if (publicAPI.isReady()) {
      var gl = model.context;
      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        var buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {
          var attrIt = buff.attributes[iatt];
          var matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (var i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 1);
              }
            }
          }
        }
      }
    }
  };
  publicAPI.release = function() {
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(null);
      } else {
        model.context.bindVertexArray(null);
      }
    } else if (publicAPI.isReady()) {
      var gl = model.context;
      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        var buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {
          var attrIt = buff.attributes[iatt];
          var matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (var i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 0);
              }
            }
            gl.disableVertexAttribArray(attrIt.index + i);
          }
        }
      }
    }
  };
  publicAPI.shaderProgramChanged = function() {
    publicAPI.release();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.handleProgram = 0;
  };
  publicAPI.releaseGraphicsResources = function() {
    publicAPI.shaderProgramChanged();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.supported = true;
    model.handleProgram = 0;
  };
  publicAPI.addAttributeArray = function(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2) {
    return publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2, 0, false);
  };
  publicAPI.addAttributeArrayWithDivisor = function(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2, divisor, isMatrix) {
    if (!program) {
      return false;
    }
    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType.ARRAY_BUFFER) {
      return false;
    }
    if (model.handleProgram === 0) {
      model.handleProgram = program.getHandle();
    }
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {
      return false;
    }
    var gl = model.context;
    var attribs = {};
    attribs.name = name;
    attribs.index = gl.getAttribLocation(model.handleProgram, name);
    attribs.offset = offset;
    attribs.stride = stride;
    attribs.type = elementType;
    attribs.size = elementTupleSize;
    attribs.normalize = normalize2;
    attribs.isMatrix = isMatrix;
    attribs.divisor = divisor;
    if (attribs.Index === -1) {
      return false;
    }
    buffer.bind();
    gl.enableVertexAttribArray(attribs.index);
    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);
    if (divisor > 0) {
      if (model.instancingExtension) {
        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);
      } else {
        gl.vertexAttribDivisor(attribs.index, 1);
      }
    }
    attribs.buffer = buffer.getHandle();
    if (!model.supported) {
      var buffFound = false;
      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        var buff = model.buffers[ibuff];
        if (buff.buffer === attribs.buffer) {
          buffFound = true;
          var found = false;
          for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {
            var attrIt = buff.attributes[iatt];
            if (attrIt.name === name) {
              found = true;
              buff.attributes[iatt] = attribs;
            }
          }
          if (!found) {
            buff.attributes.push(attribs);
          }
        }
      }
      if (!buffFound) {
        model.buffers.push({
          buffer: attribs.buffer,
          attributes: [attribs]
        });
      }
    }
    return true;
  };
  publicAPI.addAttributeMatrixWithDivisor = function(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2, divisor) {
    var result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2, divisor, true);
    if (!result) {
      return result;
    }
    var gl = model.context;
    var index = gl.getAttribLocation(model.handleProgram, name);
    for (var i = 1; i < elementTupleSize; i++) {
      gl.enableVertexAttribArray(index + i);
      gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize2, stride, offset + stride * i / elementTupleSize);
      if (divisor > 0) {
        if (model.instancingExtension) {
          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);
        } else {
          gl.vertexAttribDivisor(index + i, 1);
        }
      }
    }
    return true;
  };
  publicAPI.removeAttributeArray = function(name) {
    if (!publicAPI.isReady() || model.handleProgram === 0) {
      return false;
    }
    if (!model.supported) {
      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        var buff = model.buffers[ibuff];
        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {
          var attrIt = buff.attributes[iatt];
          if (attrIt.name === name) {
            buff.attributes.splice(iatt, 1);
            if (!buff.attributes.length) {
              model.buffers.splice(ibuff, 1);
            }
            return true;
          }
        }
      }
    }
    return true;
  };
  publicAPI.setOpenGLRenderWindow = function(rw) {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}
var DEFAULT_VALUES7 = {
  forceEmulation: false,
  handleVAO: 0,
  handleProgram: 0,
  supported: true,
  buffers: null,
  context: null
};
function extend7(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES7, initialValues);
  model.buffers = [];
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["supported"]);
  macro.setGet(publicAPI, model, ["forceEmulation"]);
  vtkOpenGLVertexArrayObject(publicAPI, model);
}
var newInstance8 = macro.newInstance(extend7, "vtkOpenGLVertexArrayObject");
var vtkVertexArrayObject = {
  newInstance: newInstance8,
  extend: extend7
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var ObjectType2 = Constants2.ObjectType;
var STATIC = {};
function vtkOpenGLBufferObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLBufferObject");
  function convertType(type) {
    switch (type) {
      case ObjectType2.ELEMENT_ARRAY_BUFFER:
        return model.context.ELEMENT_ARRAY_BUFFER;
      case ObjectType2.TEXTURE_BUFFER:
        if ("TEXTURE_BUFFER" in model.context) {
          return model.context.TEXTURE_BUFFER;
        }
      case ObjectType2.ARRAY_BUFFER:
      default:
        return model.context.ARRAY_BUFFER;
    }
  }
  var internalType = null;
  var internalHandle = null;
  var dirty = true;
  var error = "";
  publicAPI.getType = function() {
    return internalType;
  };
  publicAPI.setType = function(value) {
    internalType = value;
  };
  publicAPI.getHandle = function() {
    return internalHandle;
  };
  publicAPI.isReady = function() {
    return dirty === false;
  };
  publicAPI.generateBuffer = function(type) {
    var objectTypeGL = convertType(type);
    if (internalHandle === null) {
      internalHandle = model.context.createBuffer();
      internalType = type;
    }
    return convertType(internalType) === objectTypeGL;
  };
  publicAPI.upload = function(data, type) {
    var alreadyGenerated = publicAPI.generateBuffer(type);
    if (!alreadyGenerated) {
      error = "Trying to upload array buffer to incompatible buffer.";
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    model.context.bufferData(convertType(internalType), data, model.context.STATIC_DRAW);
    dirty = false;
    return true;
  };
  publicAPI.bind = function() {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    return true;
  };
  publicAPI.release = function() {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), null);
    return true;
  };
  publicAPI.releaseGraphicsResources = function() {
    if (internalHandle !== null) {
      model.context.bindBuffer(convertType(internalType), null);
      model.context.deleteBuffer(internalHandle);
      internalHandle = null;
    }
  };
  publicAPI.setOpenGLRenderWindow = function(rw) {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getError = function() {
    return error;
  };
}
var DEFAULT_VALUES8 = {
  objectType: ObjectType2.ARRAY_BUFFER,
  context: null
};
function extend8(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES8, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["_openGLRenderWindow"]);
  macro.moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLBufferObject(publicAPI, model);
}
var newInstance9 = macro.newInstance(extend8);
var vtkBufferObject = _objectSpread2(_objectSpread2({
  newInstance: newInstance9,
  extend: extend8
}, STATIC), Constants2);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js
var vtkErrorMacro6 = macro.vtkErrorMacro;
function computeInverseShiftAndScaleMatrix(coordShift, coordScale) {
  var inverseScale = new Float64Array(3);
  vec3_exports.inverse(inverseScale, coordScale);
  var matrix = new Float64Array(16);
  mat4_exports.fromRotationTranslationScale(matrix, quat_exports.create(), coordShift, inverseScale);
  return matrix;
}
function shouldApplyCoordShiftAndScale(coordShift, coordScale) {
  if (coordShift === null || coordScale === null) {
    return false;
  }
  return !(vec3_exports.exactEquals(coordShift, [0, 0, 0]) && vec3_exports.exactEquals(coordScale, [1, 1, 1]));
}
function vtkOpenGLCellArrayBufferObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCellArrayBufferObject");
  publicAPI.setType(ObjectType.ARRAY_BUFFER);
  publicAPI.createVBO = function(cellArray, inRep, outRep, options) {
    var selectionMaps = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
    if (!cellArray.getData() || !cellArray.getData().length) {
      model.elementCount = 0;
      return 0;
    }
    model.blockSize = 3;
    model.vertexOffset = 0;
    model.normalOffset = 0;
    model.tCoordOffset = 0;
    model.tCoordComponents = 0;
    model.colorComponents = 0;
    model.colorOffset = 0;
    model.customData = [];
    var pointData = options.points.getData();
    var normalData = null;
    var tcoordData = null;
    var colorData = null;
    var colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;
    var textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;
    if (options.normals) {
      model.normalOffset = 4 * model.blockSize;
      model.blockSize += 3;
      normalData = options.normals.getData();
    }
    if (options.customAttributes) {
      options.customAttributes.forEach(function(a) {
        if (a) {
          model.customData.push({
            data: a.getData(),
            offset: 4 * model.blockSize,
            components: a.getNumberOfComponents(),
            name: a.getName()
          });
          model.blockSize += a.getNumberOfComponents();
        }
      });
    }
    if (options.tcoords) {
      model.tCoordOffset = 4 * model.blockSize;
      model.tCoordComponents = textureComponents;
      model.blockSize += textureComponents;
      tcoordData = options.tcoords.getData();
    }
    if (options.colors) {
      model.colorComponents = options.colors.getNumberOfComponents();
      model.colorOffset = 0;
      colorData = options.colors.getData();
      if (!model.colorBO) {
        model.colorBO = vtkBufferObject.newInstance();
      }
      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);
    } else {
      model.colorBO = null;
    }
    model.stride = 4 * model.blockSize;
    var pointIdx = 0;
    var normalIdx = 0;
    var tcoordIdx = 0;
    var colorIdx = 0;
    var custIdx = 0;
    var cellCount = 0;
    var addAPoint;
    var cellBuilders = {
      anythingToPoints: function anythingToPoints2(numPoints, cellPts, offset) {
        for (var i2 = 0; i2 < numPoints; ++i2) {
          addAPoint(cellPts[offset + i2]);
        }
      },
      linesToWireframe: function linesToWireframe2(numPoints, cellPts, offset) {
        for (var i2 = 0; i2 < numPoints - 1; ++i2) {
          addAPoint(cellPts[offset + i2]);
          addAPoint(cellPts[offset + i2 + 1]);
        }
      },
      polysToWireframe: function polysToWireframe2(numPoints, cellPts, offset) {
        if (numPoints > 2) {
          for (var i2 = 0; i2 < numPoints; ++i2) {
            addAPoint(cellPts[offset + i2]);
            addAPoint(cellPts[offset + (i2 + 1) % numPoints]);
          }
        }
      },
      stripsToWireframe: function stripsToWireframe2(numPoints, cellPts, offset) {
        if (numPoints > 2) {
          for (var i2 = 0; i2 < numPoints - 1; ++i2) {
            addAPoint(cellPts[offset + i2]);
            addAPoint(cellPts[offset + i2 + 1]);
          }
          for (var _i = 0; _i < numPoints - 2; _i++) {
            addAPoint(cellPts[offset + _i]);
            addAPoint(cellPts[offset + _i + 2]);
          }
        }
      },
      polysToSurface: function polysToSurface2(npts, cellPts, offset) {
        for (var i2 = 0; i2 < npts - 2; i2++) {
          addAPoint(cellPts[offset + 0]);
          addAPoint(cellPts[offset + i2 + 1]);
          addAPoint(cellPts[offset + i2 + 2]);
        }
      },
      stripsToSurface: function stripsToSurface2(npts, cellPts, offset) {
        for (var i2 = 0; i2 < npts - 2; i2++) {
          addAPoint(cellPts[offset + i2]);
          addAPoint(cellPts[offset + i2 + 1 + i2 % 2]);
          addAPoint(cellPts[offset + i2 + 1 + (i2 + 1) % 2]);
        }
      }
    };
    var cellCounters = {
      anythingToPoints: function anythingToPoints2(numPoints, cellPts) {
        return numPoints;
      },
      linesToWireframe: function linesToWireframe2(numPoints, cellPts) {
        if (numPoints > 1) {
          return (numPoints - 1) * 2;
        }
        return 0;
      },
      polysToWireframe: function polysToWireframe2(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 2;
        }
        return 0;
      },
      stripsToWireframe: function stripsToWireframe2(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 4 - 6;
        }
        return 0;
      },
      polysToSurface: function polysToSurface2(npts, cellPts) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      },
      stripsToSurface: function stripsToSurface2(npts, cellPts, offset) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      }
    };
    var func = null;
    var countFunc = null;
    if (outRep === Representation.POINTS || inRep === "verts") {
      func = cellBuilders.anythingToPoints;
      countFunc = cellCounters.anythingToPoints;
    } else if (outRep === Representation.WIREFRAME || inRep === "lines") {
      func = cellBuilders["".concat(inRep, "ToWireframe")];
      countFunc = cellCounters["".concat(inRep, "ToWireframe")];
    } else {
      func = cellBuilders["".concat(inRep, "ToSurface")];
      countFunc = cellCounters["".concat(inRep, "ToSurface")];
    }
    var array = cellArray.getData();
    var size = array.length;
    var caboCount = 0;
    for (var index = 0; index < size; ) {
      caboCount += countFunc(array[index], array);
      index += array[index] + 1;
    }
    var packedUCVBO = null;
    var packedVBO = new Float32Array(caboCount * model.blockSize);
    if (colorData) {
      packedUCVBO = new Uint8Array(caboCount * 4);
    }
    var vboidx = 0;
    var ucidx = 0;
    var diagSq = 0;
    var distSq = 0;
    for (var i = 0; i < 3; ++i) {
      var range = options.points.getRange(i);
      var delta = range[1] - range[0];
      diagSq += delta * delta;
      var distShift = 0.5 * (range[1] + range[0]);
      distSq += distShift * distShift;
    }
    var useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1e6 || Math.abs(Math.log10(diagSq)) > 3 || diagSq === 0 && distSq > 1e6);
    if (useShiftAndScale) {
      var coordShift = new Float64Array(3);
      var coordScale = new Float64Array(3);
      for (var _i2 = 0; _i2 < 3; ++_i2) {
        var _range = options.points.getRange(_i2);
        var _delta = _range[1] - _range[0];
        coordShift[_i2] = 0.5 * (_range[1] + _range[0]);
        coordScale[_i2] = _delta > 0 ? 1 / _delta : 1;
      }
      publicAPI.setCoordShiftAndScale(coordShift, coordScale);
    } else if (model.coordShiftAndScaleEnabled === true) {
      publicAPI.setCoordShiftAndScale(null, null);
    }
    if (selectionMaps) {
      if (!selectionMaps.points && !selectionMaps.cells) {
        selectionMaps.points = new Int32Array(caboCount);
        selectionMaps.cells = new Int32Array(caboCount);
      } else {
        var newPoints = new Int32Array(caboCount + selectionMaps.points.length);
        newPoints.set(selectionMaps.points);
        selectionMaps.points = newPoints;
        var newCells = new Int32Array(caboCount + selectionMaps.points.length);
        newCells.set(selectionMaps.cells);
        selectionMaps.cells = newCells;
      }
    }
    var pointCount = options.vertexOffset;
    addAPoint = function addAPointFunc(i2) {
      if (selectionMaps) {
        selectionMaps.points[pointCount] = i2;
        selectionMaps.cells[pointCount] = cellCount;
      }
      ++pointCount;
      pointIdx = i2 * 3;
      if (!model.coordShiftAndScaleEnabled) {
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
      } else {
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];
      }
      if (normalData !== null) {
        if (options.haveCellNormals) {
          normalIdx = (cellCount + options.cellOffset) * 3;
        } else {
          normalIdx = i2 * 3;
        }
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
      }
      model.customData.forEach(function(attr) {
        custIdx = i2 * attr.components;
        for (var j2 = 0; j2 < attr.components; ++j2) {
          packedVBO[vboidx++] = attr.data[custIdx++];
        }
      });
      if (tcoordData !== null) {
        tcoordIdx = i2 * textureComponents;
        for (var j = 0; j < textureComponents; ++j) {
          packedVBO[vboidx++] = tcoordData[tcoordIdx++];
        }
      }
      if (colorData !== null) {
        if (options.haveCellScalars) {
          colorIdx = (cellCount + options.cellOffset) * colorComponents;
        } else {
          colorIdx = i2 * colorComponents;
        }
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;
      }
    };
    for (var _index = 0; _index < size; ) {
      func(array[_index], array, _index + 1);
      _index += array[_index] + 1;
      cellCount++;
    }
    model.elementCount = caboCount;
    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);
    if (model.colorBO) {
      model.colorBOStride = 4;
      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);
    }
    return cellCount;
  };
  publicAPI.setCoordShiftAndScale = function(coordShift, coordScale) {
    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {
      vtkErrorMacro6("Wrong type for coordShift, expected vec3 or null");
      return;
    }
    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {
      vtkErrorMacro6("Wrong type for coordScale, expected vec3 or null");
      return;
    }
    if (model.coordShift === null || coordShift === null || !vec3_exports.equals(coordShift, model.coordShift)) {
      model.coordShift = coordShift;
    }
    if (model.coordScale === null || coordScale === null || !vec3_exports.equals(coordScale, model.coordScale)) {
      model.coordScale = coordScale;
    }
    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);
    if (model.coordShiftAndScaleEnabled) {
      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);
    } else {
      model.inverseShiftAndScaleMatrix = null;
    }
  };
}
var DEFAULT_VALUES9 = {
  elementCount: 0,
  stride: 0,
  colorBOStride: 0,
  vertexOffset: 0,
  normalOffset: 0,
  tCoordOffset: 0,
  tCoordComponents: 0,
  colorOffset: 0,
  colorComponents: 0,
  tcoordBO: null,
  customData: [],
  coordShift: null,
  coordScale: null,
  coordShiftAndScaleEnabled: false,
  inverseShiftAndScaleMatrix: null
};
function extend9(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES9, initialValues);
  vtkBufferObject.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["colorBO", "elementCount", "stride", "colorBOStride", "vertexOffset", "normalOffset", "tCoordOffset", "tCoordComponents", "colorOffset", "colorComponents", "customData"]);
  macro.get(publicAPI, model, ["coordShift", "coordScale", "coordShiftAndScaleEnabled", "inverseShiftAndScaleMatrix"]);
  vtkOpenGLCellArrayBufferObject(publicAPI, model);
}
var newInstance10 = macro.newInstance(extend9);
var vtkCellArrayBufferObject = {
  newInstance: newInstance10,
  extend: extend9
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js
var primTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Tris: 2,
  TriStrips: 3,
  TrisEdges: 4,
  TriStripsEdges: 5,
  End: 6
};
function vtkOpenGLHelper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLHelper");
  publicAPI.setOpenGLRenderWindow = function(win) {
    model.context = win.getContext();
    model.program.setContext(model.context);
    model.VAO.setOpenGLRenderWindow(win);
    model.CABO.setOpenGLRenderWindow(win);
  };
  publicAPI.releaseGraphicsResources = function(oglwin) {
    model.VAO.releaseGraphicsResources();
    model.CABO.releaseGraphicsResources();
    model.CABO.setElementCount(0);
  };
  publicAPI.drawArrays = function(ren, actor, rep, oglMapper) {
    if (model.CABO.getElementCount()) {
      var mode = publicAPI.getOpenGLMode(rep);
      var wideLines = publicAPI.haveWideLines(ren, actor);
      var gl = model.context;
      var depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
      if (model.pointPicking) {
        gl.depthMask(false);
      }
      var drawingLines = mode === gl.LINES;
      if (drawingLines && wideLines) {
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArraysInstanced(mode, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));
      } else {
        gl.lineWidth(actor.getProperty().getLineWidth());
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArrays(mode, 0, model.CABO.getElementCount());
        gl.lineWidth(1);
      }
      var stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);
      if (model.pointPicking) {
        gl.depthMask(depthMask);
      }
      return model.CABO.getElementCount() / stride;
    }
    return 0;
  };
  publicAPI.getOpenGLMode = function(rep) {
    if (model.pointPicking) {
      return model.context.POINTS;
    }
    var type = model.primitiveType;
    if (rep === Representation.POINTS || type === primTypes.Points) {
      return model.context.POINTS;
    }
    if (rep === Representation.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {
      return model.context.LINES;
    }
    return model.context.TRIANGLES;
  };
  publicAPI.haveWideLines = function(ren, actor) {
    if (actor.getProperty().getLineWidth() > 1) {
      if (model.CABO.getOpenGLRenderWindow()) {
        if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  publicAPI.getNeedToRebuildShaders = function(ren, actor, oglMapper) {
    if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = function(ren, actor, oglMapper) {
    if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {
      var shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      oglMapper.buildShaders(shaders, ren, actor);
      var newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== publicAPI.getProgram()) {
        publicAPI.setProgram(newShader);
        publicAPI.getVAO().releaseGraphicsResources();
      }
      publicAPI.getShaderSourceTime().modified();
    } else {
      model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());
    }
    publicAPI.getVAO().bind();
    oglMapper.setMapperShaderParameters(publicAPI, ren, actor);
    oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);
    oglMapper.setCameraShaderParameters(publicAPI, ren, actor);
    oglMapper.setLightingShaderParameters(publicAPI, ren, actor);
    oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);
  };
  publicAPI.setMapperShaderParameters = function(ren, actor, size) {
    if (publicAPI.haveWideLines(ren, actor)) {
      publicAPI.getProgram().setUniform2f("viewportSize", size.usize, size.vsize);
      var lineWidth = parseFloat(actor.getProperty().getLineWidth());
      var halfLineWidth = lineWidth / 2;
      publicAPI.getProgram().setUniformf("lineWidthStepSize", lineWidth / Math.ceil(lineWidth));
      publicAPI.getProgram().setUniformf("halfLineWidth", halfLineWidth);
    }
    if (model.primitiveType === primTypes.Points || actor.getProperty().getRepresentation() === Representation.POINTS) {
      publicAPI.getProgram().setUniformf("pointSize", actor.getProperty().getPointSize());
    } else if (model.pointPicking) {
      publicAPI.getProgram().setUniformf("pointSize", publicAPI.getPointPickingPrimitiveSize());
    }
  };
  publicAPI.replaceShaderPositionVC = function(shaders, ren, actor) {
    var VSSource = shaders.Vertex;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["//VTK::PositionVC::Dec", "uniform float pointSize;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["//VTK::PositionVC::Impl", "  gl_PointSize = pointSize;"], false).result;
    if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["//VTK::PositionVC::Dec", "uniform vec2 viewportSize;", "uniform float lineWidthStepSize;", "uniform float halfLineWidth;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["//VTK::PositionVC::Impl", " if (halfLineWidth > 0.0)", "   {", "   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;", "   vec4 tmpPos = gl_Position;", "   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;", "   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];", "   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];", "   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);", "   }"]).result;
    }
    shaders.Vertex = VSSource;
  };
  publicAPI.getPointPickingPrimitiveSize = function() {
    if (model.primitiveType === primTypes.Points) {
      return 2;
    }
    if (model.primitiveType === primTypes.Lines) {
      return 4;
    }
    return 6;
  };
}
var DEFAULT_VALUES10 = {
  context: null,
  program: null,
  shaderSourceTime: null,
  VAO: null,
  attributeUpdateTime: null,
  CABO: null,
  primitiveType: 0,
  pointPicking: false
};
function extend10(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES10, initialValues);
  macro.obj(publicAPI, model);
  model.shaderSourceTime = {};
  macro.obj(model.shaderSourceTime);
  model.attributeUpdateTime = {};
  macro.obj(model.attributeUpdateTime);
  macro.setGet(publicAPI, model, ["program", "shaderSourceTime", "VAO", "attributeUpdateTime", "CABO", "primitiveType", "pointPicking"]);
  model.program = vtkShaderProgram$1.newInstance();
  model.VAO = vtkVertexArrayObject.newInstance();
  model.CABO = vtkCellArrayBufferObject.newInstance();
  vtkOpenGLHelper(publicAPI, model);
}
var newInstance11 = macro.newInstance(extend10);
var vtkHelper = {
  newInstance: newInstance11,
  extend: extend10,
  primTypes
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderModule.js
function vtkWebGPUShaderModule(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderModule");
  publicAPI.initialize = function(device, shaderDesc) {
    model.device = device;
    model.handle = model.device.getHandle().createShaderModule({
      code: shaderDesc.getCode()
    });
  };
}
var DEFAULT_VALUES11 = {
  device: null,
  handle: null
};
function extend11(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES11, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["lastCameraMTime"]);
  macro.setGet(publicAPI, model, ["device", "handle"]);
  vtkWebGPUShaderModule(publicAPI, model);
}
var newInstance12 = macro.newInstance(extend11, "vtkWebGPUShaderModule");
var vtkWebGPUShaderModule$1 = {
  newInstance: newInstance12,
  extend: extend11
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js
function substitute2(source, search, replace) {
  var all = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var replaceStr = Array.isArray(replace) ? replace.join("\n") : replace;
  var replaced = false;
  if (source.search(search) !== -1) {
    replaced = true;
  }
  var gflag = "";
  if (all) {
    gflag = "g";
  }
  var regex = new RegExp(search, gflag);
  var resultstr = source.replace(regex, replaceStr);
  return {
    replace: replaced,
    result: resultstr
  };
}
function vtkWebGPUShaderCache(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderCache");
  publicAPI.getShaderModule = function(shaderDesc) {
    var sType = shaderDesc.getType();
    var sHash = shaderDesc.getHash();
    var keys = model._shaderModules.keys();
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (key.getHash() === sHash && key.getType() === sType) {
        return model._shaderModules.get(key);
      }
    }
    var sm = vtkWebGPUShaderModule$1.newInstance();
    sm.initialize(model.device, shaderDesc);
    model._shaderModules.set(shaderDesc, sm);
    return sm;
  };
}
var DEFAULT_VALUES12 = {
  shaderModules: null,
  device: null,
  window: null
};
function extend12(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES12, initialValues);
  model._shaderModules = /* @__PURE__ */ new Map();
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["device", "window"]);
  vtkWebGPUShaderCache(publicAPI, model);
}
var newInstance13 = macro.newInstance(extend12, "vtkWebGPUShaderCache");
var vtkWebGPUShaderCache$1 = {
  newInstance: newInstance13,
  extend: extend12,
  substitute: substitute2
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/BindGroup.js
function vtkWebGPUBindGroup(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBindGroup");
  publicAPI.setBindables = function(bindables) {
    if (model.bindables.length === bindables.length) {
      var allMatch = true;
      for (var i = 0; i < model.bindables.length; i++) {
        if (model.bindables[i] !== bindables[i]) {
          allMatch = false;
        }
      }
      if (allMatch) {
        return;
      }
    }
    model.bindables = bindables;
    publicAPI.modified();
  };
  publicAPI.getBindGroupLayout = function(device) {
    var entries = [];
    for (var i = 0; i < model.bindables.length; i++) {
      var entry = model.bindables[i].getBindGroupLayoutEntry();
      entry.binding = i;
      entries.push(entry);
    }
    return device.getBindGroupLayout({
      entries
    });
  };
  publicAPI.getBindGroup = function(device) {
    var mtime = publicAPI.getMTime();
    for (var i = 0; i < model.bindables.length; i++) {
      var tm = model.bindables[i].getBindGroupTime().getMTime();
      mtime = tm > mtime ? tm : mtime;
    }
    if (mtime < model.bindGroupTime.getMTime()) {
      return model.bindGroup;
    }
    var entries = [];
    for (var _i = 0; _i < model.bindables.length; _i++) {
      var entry = model.bindables[_i].getBindGroupEntry();
      entry.binding = _i;
      entries.push(entry);
    }
    model.bindGroup = device.getHandle().createBindGroup({
      layout: publicAPI.getBindGroupLayout(device),
      entries,
      label: model.label
    });
    model.bindGroupTime.modified();
    return model.bindGroup;
  };
  publicAPI.getShaderCode = function(pipeline) {
    var lines = [];
    var bgroup = pipeline.getBindGroupLayoutCount(model.label);
    for (var i = 0; i < model.bindables.length; i++) {
      lines.push(model.bindables[i].getShaderCode(i, bgroup));
    }
    return lines.join("\n");
  };
}
var DEFAULT_VALUES13 = {
  device: null,
  handle: null,
  label: null
};
function extend13(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES13, initialValues);
  macro.obj(publicAPI, model);
  model.bindables = [];
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "handle", "sizeInBytes", "usage"]);
  macro.setGet(publicAPI, model, ["label", "device", "arrayInformation"]);
  vtkWebGPUBindGroup(publicAPI, model);
}
var newInstance14 = macro.newInstance(extend13);
var vtkWebGPUBindGroup$1 = {
  newInstance: newInstance14,
  extend: extend13
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
var textureDetails = {
  r8unorm: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "float"
  },
  r8snorm: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "float"
  },
  r8uint: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "uint"
  },
  r8sint: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "sint"
  },
  r16uint: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "uint"
  },
  r16sint: {
    numComponents: 1,
    nativeType: Int16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "sint"
  },
  r16float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 2,
    elementSize: 2,
    sampleType: "float"
  },
  rg8unorm: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "float"
  },
  rg8snorm: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "float"
  },
  rg8uint: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "uint"
  },
  rg8sint: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "sint"
  },
  r32uint: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "uint"
  },
  r32sint: {
    numComponents: 1,
    nativeType: Int32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "sint"
  },
  r32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  rg16uint: {
    numComponents: 2,
    nativeType: Uint16Array,
    stride: 4,
    elementSize: 2,
    sampleType: "uint"
  },
  rg16sint: {
    numComponents: 2,
    nativeType: Int16Array,
    stride: 4,
    elementSize: 2,
    sampleType: "sint"
  },
  rg16float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 2,
    sampleType: "float"
  },
  rgba8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  "rgba8unorm-srgb": {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  rgba8snorm: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  rgba8uint: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "uint"
  },
  rgba8sint: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "sint"
  },
  bgra8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  "bgra8unorm-srgb": {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  rgb9e5ufloat: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "float"
  },
  rgb10a2unorm: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "float"
  },
  rg11b10ufloat: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 4,
    sampleType: "float"
  },
  rg32uint: {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "uint"
  },
  rg32sint: {
    numComponents: 2,
    nativeType: Int32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "sint"
  },
  rg32float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  rgba16uint: {
    numComponents: 4,
    nativeType: Uint16Array,
    stride: 8,
    elementSize: 2,
    sampleType: "uint"
  },
  rgba16sint: {
    numComponents: 4,
    nativeType: Int16Array,
    stride: 8,
    elementSize: 2,
    sampleType: "sint"
  },
  rgba16float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 2,
    sampleType: "float"
  },
  rgba32uint: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "uint"
  },
  rgba32sint: {
    numComponents: 4,
    nativeType: Int32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "sint"
  },
  rgba32float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  stencil8: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "uint"
  },
  depth16unorm: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "depth"
  },
  depth24plus: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 3,
    sampleType: "depth"
  },
  "depth24plus-stencil8": {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "mixed"
  },
  depth32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "depth"
  }
};
function getDetailsFromTextureFormat(format) {
  if (!format || format.length < 6)
    return 0;
  if (format in textureDetails === true) {
    return textureDetails[format];
  }
  vtkErrorMacro("unknown format ".concat(format));
  return null;
}
function getByteStrideFromBufferFormat(format) {
  if (!format || format.length < 5)
    return 0;
  var numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = Number(format[format.length - 1]);
  }
  var sizeStart = numComp === 1 ? format.length - 1 : format.length - 3;
  var num = Number(format[sizeStart]);
  if (Number.isNaN(num)) {
    vtkErrorMacro("unknown format ".concat(format));
    return 0;
  }
  var typeSize = 5 - num / 2;
  return numComp * typeSize;
}
function getNumberOfComponentsFromBufferFormat(format) {
  if (!format || format.length < 5)
    return 0;
  var numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = Number(format[format.length - 1]);
  }
  return numComp;
}
function getNativeTypeFromBufferFormat(format) {
  if (!format || format.length < 5)
    return 0;
  var result;
  if (format[0] === "f") {
    result = "Float";
  } else if (format[0] === "s") {
    result = "Int";
  } else if (format[0] === "u") {
    result = "Uint";
  } else {
    vtkErrorMacro("unknown format ".concat(format));
    return void 0;
  }
  var base = format.split("x")[0];
  var num = Number(base[base.length - 1]);
  if (Number.isNaN(num)) {
    vtkErrorMacro("unknown format ".concat(format));
    return void 0;
  }
  result += 8 * (5 - num / 2);
  result += "Array";
  return result;
}
function getShaderTypeFromBufferFormat(format) {
  var dataType;
  if (format[0] === "f" || format[1] === "n") {
    dataType = "f32";
  } else if (format[0] === "s" && format[1] === "i") {
    dataType = "i32";
  } else if (format[0] === "u" && format[1] === "i") {
    dataType = "u32";
  } else {
    vtkErrorMacro("unknown format ".concat(format));
    return void 0;
  }
  var numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = Number(format[format.length - 1]);
  }
  if (numComp === 4)
    return "vec4<".concat(dataType, ">");
  if (numComp === 3)
    return "vec3<".concat(dataType, ">");
  if (numComp === 2)
    return "vec2<".concat(dataType, ">");
  return dataType;
}
function getByteStrideFromShaderFormat(format) {
  if (!format)
    return 0;
  var numComp = 1;
  if (format.substring(0, 3) === "vec") {
    numComp = Number(format[3]);
  } else if (format.substring(0, 3) === "mat") {
    numComp = format[3] * format[5];
  }
  var typeSize = 4;
  return numComp * typeSize;
}
function getNativeTypeFromShaderFormat(format) {
  if (!format)
    return void 0;
  if (format.includes("f32"))
    return "Float32Array";
  if (format.includes("i32"))
    return "Int32Array";
  if (format.includes("u32"))
    return "Uint32Array";
  vtkErrorMacro("unknown format ".concat(format));
  return void 0;
}
var vtkWebGPUTypes = {
  getDetailsFromTextureFormat,
  getByteStrideFromBufferFormat,
  getNumberOfComponentsFromBufferFormat,
  getNativeTypeFromBufferFormat,
  getShaderTypeFromBufferFormat,
  getByteStrideFromShaderFormat,
  getNativeTypeFromShaderFormat
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Pipeline.js
function vtkWebGPUPipeline(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPipeline");
  publicAPI.getShaderDescriptions = function() {
    return model.shaderDescriptions;
  };
  publicAPI.initialize = function(device, hash) {
    model.pipelineDescription = model.renderEncoder.getPipelineSettings();
    model.pipelineDescription.primitive.topology = model.topology;
    model.pipelineDescription.vertex = model.vertexState;
    model.pipelineDescription.label = hash;
    var bindGroupLayouts = [];
    for (var i = 0; i < model.layouts.length; i++) {
      bindGroupLayouts.push(model.layouts[i].layout);
    }
    model.pipelineLayout = device.getHandle().createPipelineLayout({
      bindGroupLayouts
    });
    model.pipelineDescription.layout = model.pipelineLayout;
    for (var _i = 0; _i < model.shaderDescriptions.length; _i++) {
      var sd = model.shaderDescriptions[_i];
      var sm = device.getShaderModule(sd);
      if (sd.getType() === "vertex") {
        model.pipelineDescription.vertex.module = sm.getHandle();
        model.pipelineDescription.vertex.entryPoint = "main";
      }
      if (sd.getType() === "fragment") {
        model.pipelineDescription.fragment.module = sm.getHandle();
        model.pipelineDescription.fragment.entryPoint = "main";
      }
    }
    model.handle = device.getHandle().createRenderPipeline(model.pipelineDescription);
  };
  publicAPI.getShaderDescription = function(stype) {
    for (var i = 0; i < model.shaderDescriptions.length; i++) {
      if (model.shaderDescriptions[i].getType() === stype)
        return model.shaderDescriptions[i];
    }
    return null;
  };
  publicAPI.addBindGroupLayout = function(bindGroup) {
    if (!bindGroup) {
      return;
    }
    model.layouts.push({
      layout: bindGroup.getBindGroupLayout(model.device),
      label: bindGroup.getLabel()
    });
  };
  publicAPI.getBindGroupLayout = function(idx) {
    return model.layouts[idx].layout;
  };
  publicAPI.getBindGroupLayoutCount = function(llabel) {
    for (var i = 0; i < model.layouts.length; i++) {
      if (model.layouts[i].label === llabel) {
        return i;
      }
    }
    return 0;
  };
  publicAPI.bindVertexInput = function(renderEncoder, vInput) {
    vInput.bindBuffers(renderEncoder);
  };
}
var DEFAULT_VALUES14 = {
  handle: null,
  layouts: null,
  renderEncoder: null,
  shaderDescriptions: null,
  vertexState: null,
  topology: null,
  pipelineDescription: null
};
function extend14(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES14, initialValues);
  obj(publicAPI, model);
  model.layouts = [];
  model.shaderDescriptions = [];
  get(publicAPI, model, ["handle", "pipelineDescription"]);
  setGet(publicAPI, model, ["device", "renderEncoder", "topology", "vertexState"]);
  vtkWebGPUPipeline(publicAPI, model);
}
var newInstance15 = newInstance(extend14, "vtkWebGPUPipeline");
var vtkWebGPUPipeline$1 = {
  newInstance: newInstance15,
  extend: extend14
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderDescription.js
function vtkWebGPUShaderDescription(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderDescription");
  publicAPI.hasOutput = function(name) {
    return model.outputNames.includes(name);
  };
  publicAPI.addOutput = function(type, name) {
    var interpolation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    model.outputTypes.push(type);
    model.outputNames.push(name);
    model.outputInterpolations.push(interpolation);
  };
  publicAPI.addBuiltinOutput = function(type, name) {
    model.builtinOutputTypes.push(type);
    model.builtinOutputNames.push(name);
  };
  publicAPI.addBuiltinInput = function(type, name) {
    model.builtinInputTypes.push(type);
    model.builtinInputNames.push(name);
  };
  publicAPI.replaceShaderCode = function(priorStage, vertexInput) {
    var inputImpl = [];
    var iodec = [];
    if (vertexInput) {
      inputImpl.push(vertexInput.getShaderCode());
    }
    if (priorStage || model.builtinInputNames.length) {
      var inputStruct = [];
      inputStruct.push("struct ".concat(model.type, "Input\n{"));
      if (priorStage) {
        var inputNames = priorStage.getOutputNamesByReference();
        var inputTypes = priorStage.getOutputTypesByReference();
        var inputInterpolations = priorStage.getOutputInterpolationsByReference();
        for (var i = 0; i < inputNames.length; i++) {
          if (inputInterpolations[i] !== void 0) {
            inputStruct.push("  @location(".concat(i, ") @interpolate(").concat(inputInterpolations[i], ") ").concat(inputNames[i], " : ").concat(inputTypes[i], ","));
          } else {
            inputStruct.push("  @location(".concat(i, ") ").concat(inputNames[i], " : ").concat(inputTypes[i], ","));
          }
        }
      }
      for (var _i = 0; _i < model.builtinInputNames.length; _i++) {
        inputStruct.push("  ".concat(model.builtinInputNames[_i], " : ").concat(model.builtinInputTypes[_i], ","));
      }
      if (inputStruct.length > 1) {
        inputStruct.push("};");
        iodec = inputStruct;
        inputImpl[inputImpl.length - 1] += ",";
        inputImpl.push("input: ".concat(model.type, "Input"));
      }
    }
    if (inputImpl.length) {
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Input", inputImpl).result;
    }
    if (model.outputNames.length + model.builtinOutputNames.length) {
      var outputStruct = ["struct ".concat(model.type, "Output\n{")];
      for (var _i2 = 0; _i2 < model.outputNames.length; _i2++) {
        if (model.outputInterpolations[_i2] !== void 0) {
          outputStruct.push("  @location(".concat(_i2, ") @interpolate(").concat(model.outputInterpolations[_i2], ") ").concat(model.outputNames[_i2], " : ").concat(model.outputTypes[_i2], ","));
        } else {
          outputStruct.push("  @location(".concat(_i2, ") ").concat(model.outputNames[_i2], " : ").concat(model.outputTypes[_i2], ","));
        }
      }
      for (var _i3 = 0; _i3 < model.builtinOutputNames.length; _i3++) {
        outputStruct.push("  ".concat(model.builtinOutputNames[_i3], " : ").concat(model.builtinOutputTypes[_i3], ","));
      }
      outputStruct.push("};");
      iodec = iodec.concat(outputStruct);
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Output", ["-> ".concat(model.type, "Output")]).result;
    }
    model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Dec", iodec).result;
  };
}
var DEFAULT_VALUES15 = {
  type: null,
  hash: null,
  code: null,
  outputNames: null,
  outputTypes: null
};
function extend15(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES15, initialValues);
  model.outputNames = [];
  model.outputTypes = [];
  model.outputInterpolations = [];
  model.builtinOutputNames = [];
  model.builtinOutputTypes = [];
  model.builtinInputNames = [];
  model.builtinInputTypes = [];
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["type", "hash", "code"]);
  macro.getArray(publicAPI, model, ["outputTypes", "outputNames", "outputInterpolations"]);
  vtkWebGPUShaderDescription(publicAPI, model);
}
var newInstance16 = macro.newInstance(extend15, "vtkWebGPUShaderDescription");
var vtkWebGPUShaderDescription$1 = {
  newInstance: newInstance16,
  extend: extend15
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/VertexInput.js
function arraysEqual(a, b) {
  if (a === b)
    return true;
  if (a == null || b == null)
    return false;
  if (a.length !== b.length)
    return false;
  for (var i = 0; i < a.length; ++i) {
    if (!b.includes(a[i]))
      return false;
  }
  return true;
}
function vtkWebGPUVertexInput(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVertexInput");
  publicAPI.addBuffer = function(buffer, inames) {
    var stepMode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "vertex";
    var names = inames;
    if (!Array.isArray(names)) {
      names = [names];
    }
    for (var i = 0; i < model.inputs.length; i++) {
      if (arraysEqual(model.inputs[i].names, names)) {
        if (model.inputs[i].buffer === buffer) {
          return;
        }
        model.inputs[i].buffer = buffer;
        return;
      }
    }
    model.inputs.push({
      buffer,
      stepMode,
      names
    });
    model.inputs = model.inputs.sort(function(v1, v2) {
      if (v1.names[0] < v2.names[0]) {
        return -1;
      }
      if (v1.names[0] > v2.names[0]) {
        return 1;
      }
      return 0;
    });
  };
  publicAPI.removeBufferIfPresent = function(name) {
    for (var i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        model.inputs.splice(i, 1);
      }
    }
  };
  publicAPI.getBuffer = function(name) {
    for (var i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer;
      }
    }
    return null;
  };
  publicAPI.hasAttribute = function(name) {
    for (var i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getAttributeTime = function(name) {
    for (var i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer.getSourceTime();
      }
    }
    return 0;
  };
  publicAPI.getShaderCode = function() {
    var result = "";
    var nameCount = 0;
    for (var i = 0; i < model.inputs.length; i++) {
      for (var nm = 0; nm < model.inputs[i].names.length; nm++) {
        var arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];
        var type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);
        if (nameCount > 0) {
          result += ",\n";
        }
        result = "".concat(result, "  @location(").concat(nameCount, ") ").concat(model.inputs[i].names[nm], " : ").concat(type);
        nameCount++;
      }
    }
    return result;
  };
  publicAPI.getVertexInputInformation = function() {
    var info = {};
    if (model.inputs.length) {
      var vertexBuffers = [];
      var nameCount = 0;
      for (var i = 0; i < model.inputs.length; i++) {
        var buf = model.inputs[i].buffer;
        var buffer = {
          arrayStride: buf.getStrideInBytes(),
          stepMode: model.inputs[i].stepMode,
          attributes: []
        };
        var arrayInfo = buf.getArrayInformation();
        for (var nm = 0; nm < model.inputs[i].names.length; nm++) {
          buffer.attributes.push({
            shaderLocation: nameCount,
            offset: arrayInfo[nm].offset,
            format: arrayInfo[nm].format
          });
          nameCount++;
        }
        vertexBuffers.push(buffer);
      }
      info.buffers = vertexBuffers;
    }
    return info;
  };
  publicAPI.bindBuffers = function(renderEncoder) {
    for (var i = 0; i < model.inputs.length; i++) {
      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());
    }
    if (model.indexBuffer) {
      renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);
    }
  };
  publicAPI.getReady = function() {
  };
  publicAPI.releaseGraphicsResources = function() {
    if (model.created) {
      model.inputs = [];
      model.bindingDescriptions = [];
      model.attributeDescriptions = [];
    }
  };
}
var DEFAULT_VALUES16 = {
  inputs: null,
  bindingDescriptions: false,
  attributeDescriptions: null,
  indexBuffer: null
};
function extend16(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES16, initialValues);
  obj(publicAPI, model);
  model.bindingDescriptions = [];
  model.attributeDescriptions = [];
  model.inputs = [];
  setGet(publicAPI, model, ["created", "device", "handle", "indexBuffer"]);
  vtkWebGPUVertexInput(publicAPI, model);
}
var newInstance17 = newInstance(extend16, "vtkWebGPUVertexInput");
var vtkWebGPUVertexInput$1 = {
  newInstance: newInstance17,
  extend: extend16
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/SimpleMapper.js
var vtkWebGPUSimpleMapperVS = "\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n";
var vtkWebGPUSimpleMapperFS = "\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";
function vtkWebGPUSimpleMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUSimpleMapper");
  publicAPI.generateShaderDescriptions = function(hash, pipeline, vertexInput) {
    var vDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: "vertex",
      hash,
      code: model.vertexShaderTemplate
    });
    var fDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: "fragment",
      hash,
      code: model.fragmentShaderTemplate
    });
    var sdrs = pipeline.getShaderDescriptions();
    sdrs.push(vDesc);
    sdrs.push(fDesc);
    var scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;
    var re = new RegExp("//VTK::[^:]*::", "g");
    var unique = scode.match(re).filter(function(v, i2, a) {
      return a.indexOf(v) === i2;
    });
    var fnames = unique.map(function(v) {
      return "replaceShader".concat(v.substring(7, v.length - 2));
    });
    for (var i = 0; i < fnames.length; i++) {
      var fname = fnames[i];
      if (fname !== "replaceShaderIOStructs" && model.shaderReplacements.has(fname)) {
        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);
      }
    }
    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);
  };
  publicAPI.replaceShaderIOStructs = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.replaceShaderCode(null, vertexInput);
    var fDesc = pipeline.getShaderDescription("fragment");
    fDesc.replaceShaderCode(vDesc);
  };
  publicAPI.replaceShaderRenderEncoder = function(hash, pipeline, vertexInput) {
    model.renderEncoder.replaceShaderCode(pipeline);
  };
  model.shaderReplacements.set("replaceShaderRenderEncoder", publicAPI.replaceShaderRenderEncoder);
  publicAPI.replaceShaderRenderer = function(hash, pipeline, vertexInput) {
    if (!model.WebGPURenderer) {
      return;
    }
    var ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);
    var vDesc = pipeline.getShaderDescription("vertex");
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
    vDesc.setCode(code);
    var fDesc = pipeline.getShaderDescription("fragment");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderRenderer", publicAPI.replaceShaderRenderer);
  publicAPI.replaceShaderMapper = function(hash, pipeline, vertexInput) {
    var ubocode = model.bindGroup.getShaderCode(pipeline);
    var vDesc = pipeline.getShaderDescription("vertex");
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
    vDesc.setCode(code);
    var fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinInput("bool", "@builtin(front_facing) frontFacing");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderMapper", publicAPI.replaceShaderMapper);
  publicAPI.replaceShaderPosition = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addOutput("vec2<f32>", "tcoordVS");
  };
  model.shaderReplacements.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.addTextureView = function(view) {
    if (model.textureViews.includes(view)) {
      return;
    }
    model.textureViews.push(view);
  };
  publicAPI.prepareToDraw = function(renderEncoder) {
    model.renderEncoder = renderEncoder;
    publicAPI.updateInput();
    publicAPI.updateBuffers();
    publicAPI.updateBindings();
    publicAPI.updatePipeline();
  };
  publicAPI.updateInput = function() {
  };
  publicAPI.updateBuffers = function() {
  };
  publicAPI.updateBindings = function() {
    model.bindGroup.setBindables(publicAPI.getBindables());
  };
  publicAPI.computePipelineHash = function() {
  };
  publicAPI.registerDrawCallback = function(encoder) {
    encoder.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.prepareAndDraw = function(encoder) {
    publicAPI.prepareToDraw(encoder);
    encoder.setPipeline(model.pipeline);
    publicAPI.draw(encoder);
  };
  publicAPI.draw = function(renderEncoder) {
    var pipeline = renderEncoder.getBoundPipeline();
    renderEncoder.activateBindGroup(model.bindGroup);
    if (model.WebGPURenderer) {
      model.WebGPURenderer.bindUBO(renderEncoder);
    }
    pipeline.bindVertexInput(renderEncoder, model.vertexInput);
    var indexBuffer = model.vertexInput.getIndexBuffer();
    if (indexBuffer) {
      renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);
    } else {
      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);
    }
  };
  publicAPI.getBindables = function() {
    var bindables = _toConsumableArray(model.additionalBindables);
    if (model.UBO) {
      bindables.push(model.UBO);
    }
    if (model.SSBO) {
      bindables.push(model.SSBO);
    }
    for (var t = 0; t < model.textureViews.length; t++) {
      bindables.push(model.textureViews[t]);
      var samp = model.textureViews[t].getSampler();
      if (samp) {
        bindables.push(samp);
      }
    }
    return bindables;
  };
  publicAPI.updatePipeline = function() {
    publicAPI.computePipelineHash();
    model.pipeline = model.device.getPipeline(model.pipelineHash);
    if (!model.pipeline) {
      model.pipeline = vtkWebGPUPipeline$1.newInstance();
      model.pipeline.setDevice(model.device);
      if (model.WebGPURenderer) {
        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());
      }
      model.pipeline.addBindGroupLayout(model.bindGroup);
      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);
      model.pipeline.setTopology(model.topology);
      model.pipeline.setRenderEncoder(model.renderEncoder);
      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());
      model.device.createPipeline(model.pipelineHash, model.pipeline);
    }
  };
}
var DEFAULT_VALUES17 = {
  additionalBindables: void 0,
  bindGroup: null,
  device: null,
  fragmentShaderTemplate: null,
  numberOfInstances: 1,
  numberOfVertices: 0,
  pipelineHash: null,
  shaderReplacements: null,
  SSBO: null,
  textureViews: null,
  topology: "triangle-list",
  UBO: null,
  vertexShaderTemplate: null,
  WebGPURenderer: null
};
function extend17(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES17, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.textureViews = [];
  model.vertexInput = vtkWebGPUVertexInput$1.newInstance();
  model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
    label: "mapperBG"
  });
  model.additionalBindables = [];
  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;
  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;
  model.shaderReplacements = /* @__PURE__ */ new Map();
  macro.get(publicAPI, model, ["pipeline", "vertexInput"]);
  macro.setGet(publicAPI, model, ["additionalBindables", "device", "fragmentShaderTemplate", "interpolate", "numberOfInstances", "numberOfVertices", "pipelineHash", "shaderReplacements", "SSBO", "textureViews", "topology", "UBO", "vertexShaderTemplate", "WebGPURenderer"]);
  vtkWebGPUSimpleMapper(publicAPI, model);
}
var newInstance18 = macro.newInstance(extend17, "vtkWebGPUSimpleMapper");
var vtkWebGPUSimpleMapper$1 = {
  newInstance: newInstance18,
  extend: extend17
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/FullScreenQuad.js
function vtkWebGPUFullScreenQuad(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUFullScreenQuad");
  publicAPI.replaceShaderPosition = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    vDesc.addOutput("vec4<f32>", "vertexVC");
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);", "output.Position = vec4<f32>(vertexBC, 1.0);", "output.vertexVC = vec4<f32>(vertexBC, 1);"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.updateBuffers = function() {
    var buff = model.device.getBufferManager().getFullScreenQuadBuffer();
    model.vertexInput.addBuffer(buff, ["vertexBC"]);
    model.numberOfVertices = 6;
  };
}
var DEFAULT_VALUES18 = {};
function extend18(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES18, initialValues);
  vtkWebGPUSimpleMapper$1.extend(publicAPI, model, initialValues);
  vtkWebGPUFullScreenQuad(publicAPI, model);
}
var newInstance19 = macro.newInstance(extend18, "vtkWebGPUFullScreenQuad");
var vtkWebGPUFullScreenQuad$1 = {
  newInstance: newInstance19,
  extend: extend18
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager/Constants.js
var BufferUsage = {
  Verts: 0,
  Lines: 1,
  Triangles: 2,
  Strips: 3,
  LinesFromStrips: 4,
  LinesFromTriangles: 5,
  Points: 6,
  UniformArray: 7,
  PointArray: 8,
  NormalsFromPoints: 9,
  Texture: 10,
  RawVertex: 11,
  Storage: 12,
  Index: 13
};
var PrimitiveTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Triangles: 2,
  TriangleStrips: 3,
  TriangleEdges: 4,
  TriangleStripEdges: 5,
  End: 6
};
var Constants3 = {
  BufferUsage,
  PrimitiveTypes
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Buffer.js
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var forwarded = ["getMappedRange", "mapAsync", "unmap"];
function bufferSubData(device, destBuffer, destOffset, srcArrayBuffer) {
  var byteCount = srcArrayBuffer.byteLength;
  var srcBuffer = device.createBuffer({
    size: byteCount,
    usage: GPUBufferUsage.COPY_SRC,
    mappedAtCreation: true
  });
  var arrayBuffer = srcBuffer.getMappedRange(0, byteCount);
  new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer));
  srcBuffer.unmap();
  var encoder = device.createCommandEncoder();
  encoder.copyBufferToBuffer(srcBuffer, 0, destBuffer, destOffset, byteCount);
  var commandBuffer = encoder.finish();
  var queue = device.queue;
  queue.submit([commandBuffer]);
  srcBuffer.destroy();
}
function vtkWebGPUBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBuffer");
  publicAPI.create = function(sizeInBytes, usage) {
    model.handle = model.device.getHandle().createBuffer({
      size: sizeInBytes,
      usage,
      label: model.label
    });
    model.sizeInBytes = sizeInBytes;
    model.usage = usage;
  };
  publicAPI.write = function(data) {
    bufferSubData(model.device.getHandle(), model.handle, 0, data.buffer);
  };
  publicAPI.createAndWrite = function(data, usage) {
    model.handle = model.device.getHandle().createBuffer({
      size: data.byteLength,
      usage,
      mappedAtCreation: true,
      label: model.label
    });
    model.sizeInBytes = data.byteLength;
    model.usage = usage;
    new Uint8Array(model.handle.getMappedRange()).set(new Uint8Array(data.buffer));
    model.handle.unmap();
  };
  var _loop = function _loop2(i2) {
    publicAPI[forwarded[i2]] = function() {
      var _model$handle;
      return (_model$handle = model.handle)[forwarded[i2]].apply(_model$handle, arguments);
    };
  };
  for (var i = 0; i < forwarded.length; i++) {
    _loop(i);
  }
}
var DEFAULT_VALUES19 = {
  device: null,
  handle: null,
  sizeInBytes: 0,
  strideInBytes: 0,
  arrayInformation: null,
  usage: null,
  label: null,
  sourceTime: null
};
function extend19(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES19, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["handle", "sizeInBytes", "usage"]);
  macro.setGet(publicAPI, model, ["strideInBytes", "device", "arrayInformation", "label", "sourceTime"]);
  vtkWebGPUBuffer(publicAPI, model);
}
var newInstance20 = macro.newInstance(extend19);
var vtkWebGPUBuffer$1 = _objectSpread3({
  newInstance: newInstance20,
  extend: extend19
}, Constants3);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/IndexBuffer.js
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys4(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var Representation2 = vtkProperty$1.Representation;
var PrimitiveTypes2 = Constants3.PrimitiveTypes;
var _LimitedMap = function() {
  function _LimitedMap2() {
    _classCallCheck(this, _LimitedMap2);
    this.keys = new Uint32Array(10);
    this.values = new Uint32Array(10);
    this.count = 0;
  }
  _createClass(_LimitedMap2, [{
    key: "clear",
    value: function clear() {
      this.count = 0;
    }
  }, {
    key: "has",
    value: function has(key) {
      for (var i = 0; i < this.count; i++) {
        if (this.keys[i] === key) {
          return true;
        }
      }
      return void 0;
    }
  }, {
    key: "get",
    value: function get2(key) {
      for (var i = 0; i < this.count; i++) {
        if (this.keys[i] === key) {
          return this.values[i];
        }
      }
      return void 0;
    }
  }, {
    key: "set",
    value: function set2(key, value) {
      if (this.count < 9) {
        this.keys[this.count] = key;
        this.values[this.count++] = value;
      }
    }
  }]);
  return _LimitedMap2;
}();
function getPrimitiveName(primType) {
  switch (primType) {
    case PrimitiveTypes2.Points:
      return "points";
    case PrimitiveTypes2.Lines:
      return "lines";
    case PrimitiveTypes2.Triangles:
    case PrimitiveTypes2.TriangleEdges:
      return "polys";
    case PrimitiveTypes2.TriangleStripEdges:
    case PrimitiveTypes2.TriangleStrips:
      return "strips";
    default:
      return "";
  }
}
function _getOrAddFlatId(state, ptId, cellId) {
  var flatId = state.pointIdToFlatId[ptId];
  if (flatId < 0) {
    flatId = state.flatId;
    state.pointIdToFlatId[ptId] = flatId;
    state.flatIdToPointId[state.flatId] = ptId;
    state.flatIdToCellId[state.flatId] = cellId;
    state.flatId++;
  }
  return flatId;
}
function fillCell(ptIds, cellId, state) {
  var numPtIds = ptIds.length;
  for (var ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    var _ptId = ptIds[ptIdx];
    if (state.cellProvokedMap.has(_ptId)) {
      state.ibo[state.iboId++] = state.cellProvokedMap.get(_ptId);
      for (var ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
        _ptId = ptIds[ptIdx2 % numPtIds];
        var _flatId = _getOrAddFlatId(state, _ptId, cellId);
        state.ibo[state.iboId++] = _flatId;
      }
      return;
    }
  }
  for (var _ptIdx = 0; _ptIdx < numPtIds; _ptIdx++) {
    var _ptId2 = ptIds[_ptIdx];
    if (!state.provokedPointIds[_ptId2]) {
      var _flatId2 = _getOrAddFlatId(state, _ptId2, cellId);
      state.provokedPointIds[_ptId2] = 1;
      state.cellProvokedMap.set(_ptId2, _flatId2);
      state.flatIdToCellId[_flatId2] = cellId;
      state.ibo[state.iboId++] = _flatId2;
      for (var _ptIdx2 = _ptIdx + 1; _ptIdx2 < _ptIdx + numPtIds; _ptIdx2++) {
        _ptId2 = ptIds[_ptIdx2 % numPtIds];
        _flatId2 = _getOrAddFlatId(state, _ptId2, cellId);
        state.ibo[state.iboId++] = _flatId2;
      }
      return;
    }
  }
  var ptId = ptIds[0];
  var flatId = state.flatId;
  state.cellProvokedMap.set(ptId, flatId);
  state.flatIdToPointId[state.flatId] = ptId;
  state.flatIdToCellId[state.flatId] = cellId;
  state.flatId++;
  state.ibo[state.iboId++] = flatId;
  for (var _ptIdx3 = 1; _ptIdx3 < numPtIds; _ptIdx3++) {
    ptId = ptIds[_ptIdx3];
    flatId = _getOrAddFlatId(state, ptId, cellId);
    state.ibo[state.iboId++] = flatId;
  }
}
function countCell(ptIds, cellId, state) {
  var numPtIds = ptIds.length;
  state.iboSize += numPtIds;
  for (var ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    var ptId = ptIds[ptIdx];
    if (state.cellProvokedMap.has(ptId)) {
      return;
    }
  }
  for (var _ptIdx4 = 0; _ptIdx4 < numPtIds; _ptIdx4++) {
    var _ptId3 = ptIds[_ptIdx4];
    if (!state.provokedPointIds[_ptId3]) {
      state.provokedPointIds[_ptId3] = 1;
      state.cellProvokedMap.set(_ptId3, 1);
      return;
    }
  }
  state.cellProvokedMap.set(ptIds[0], 1);
  state.extraPoints++;
}
var processCell;
var _single = new Uint32Array(1);
var _double = new Uint32Array(2);
var _triple = new Uint32Array(3);
var _indexCellBuilders = {
  anythingToPoints: function anythingToPoints(numPoints, cellPts, offset, cellId, state) {
    for (var i = 0; i < numPoints; ++i) {
      _single[0] = cellPts[offset + i];
      processCell(_single, cellId, state);
    }
  },
  linesToWireframe: function linesToWireframe(numPoints, cellPts, offset, cellId, state) {
    for (var i = 0; i < numPoints - 1; ++i) {
      _double[0] = cellPts[offset + i];
      _double[1] = cellPts[offset + i + 1];
      processCell(_double, cellId, state);
    }
  },
  polysToWireframe: function polysToWireframe(numPoints, cellPts, offset, cellId, state) {
    if (numPoints > 2) {
      for (var i = 0; i < numPoints; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + (i + 1) % numPoints];
        processCell(_double, cellId, state);
      }
    }
  },
  stripsToWireframe: function stripsToWireframe(numPoints, cellPts, offset, cellId, state) {
    if (numPoints > 2) {
      for (var i = 0; i < numPoints - 1; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + i + 1];
        processCell(_double, cellId, state);
      }
      for (var _i = 0; _i < numPoints - 2; _i++) {
        _double[0] = cellPts[offset + _i];
        _double[1] = cellPts[offset + _i + 2];
        processCell(_double, cellId, state);
      }
    }
  },
  polysToSurface: function polysToSurface(npts, cellPts, offset, cellId, state) {
    for (var i = 0; i < npts - 2; i++) {
      _triple[0] = cellPts[offset];
      _triple[1] = cellPts[offset + i + 1];
      _triple[2] = cellPts[offset + i + 2];
      processCell(_triple, cellId, state);
    }
  },
  stripsToSurface: function stripsToSurface(npts, cellPts, offset, cellId, state) {
    for (var i = 0; i < npts - 2; i++) {
      _triple[0] = cellPts[offset + i];
      _triple[1] = cellPts[offset + i + 1 + i % 2];
      _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];
      processCell(_triple, cellId, state);
    }
  }
};
function vtkWebGPUIndexBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUIndexBuffer");
  publicAPI.buildIndexBuffer = function(req) {
    var cellArray = req.cells;
    var primitiveType = req.primitiveType;
    var representation = req.representation;
    var cellOffset = req.cellOffset;
    var array = cellArray.getData();
    var cellArraySize = array.length;
    var inRepName = getPrimitiveName(primitiveType);
    var numPts = req.numberOfPoints;
    var state = {
      provokedPointIds: new Uint8Array(numPts),
      extraPoints: 0,
      iboSize: 0,
      flatId: 0,
      iboId: 0,
      cellProvokedMap: new _LimitedMap()
    };
    var func = null;
    if (representation === Representation2.POINTS || primitiveType === PrimitiveTypes2.Points) {
      func = _indexCellBuilders.anythingToPoints;
    } else if (representation === Representation2.WIREFRAME || primitiveType === PrimitiveTypes2.Lines) {
      func = _indexCellBuilders["".concat(inRepName, "ToWireframe")];
    } else {
      func = _indexCellBuilders["".concat(inRepName, "ToSurface")];
    }
    processCell = countCell;
    var cellId = cellOffset || 0;
    for (var cellArrayIndex = 0; cellArrayIndex < cellArraySize; ) {
      state.cellProvokedMap.clear();
      func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);
      cellArrayIndex += array[cellArrayIndex] + 1;
      cellId++;
    }
    if (numPts <= 65535) {
      state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);
    } else {
      state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);
    }
    if (numPts + state.extraPoints < 36863) {
      state.pointIdToFlatId = new Int16Array(numPts);
    } else {
      state.pointIdToFlatId = new Int32Array(numPts);
    }
    if (numPts + state.extraPoints <= 65535) {
      state.ibo = new Uint16Array(state.iboSize);
      req.format = "uint16";
    } else {
      state.ibo = new Uint32Array(state.iboSize);
      req.format = "uint32";
    }
    if (cellId <= 65535) {
      state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);
    } else {
      state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);
    }
    state.pointIdToFlatId.fill(-1);
    state.provokedPointIds.fill(0);
    processCell = fillCell;
    cellId = cellOffset || 0;
    for (var _cellArrayIndex = 0; _cellArrayIndex < cellArraySize; ) {
      state.cellProvokedMap.clear();
      func(array[_cellArrayIndex], array, _cellArrayIndex + 1, cellId, state);
      _cellArrayIndex += array[_cellArrayIndex] + 1;
      cellId++;
    }
    delete state.provokedPointIds;
    delete state.pointIdToFlatId;
    req.nativeArray = state.ibo;
    model.flatIdToPointId = state.flatIdToPointId;
    model.flatIdToCellId = state.flatIdToCellId;
    model.flatSize = state.flatId;
    model.indexCount = state.iboId;
  };
}
var DEFAULT_VALUES20 = {
  flatIdToPointId: null,
  flatIdToCellId: null,
  flatSize: 0,
  indexCount: 0
};
function extend20(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES20, initialValues);
  vtkWebGPUBuffer$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["flatIdToPointId", "flatIdToCellId", "flatSize", "indexCount"]);
  vtkWebGPUIndexBuffer(publicAPI, model);
}
var newInstance21 = macro.newInstance(extend20);
var vtkWebGPUIndexBuffer$1 = _objectSpread4({
  newInstance: newInstance21,
  extend: extend20
}, Constants3);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager.js
function ownKeys5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys5(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var BufferUsage2 = Constants3.BufferUsage;
var vtkErrorMacro7 = vtkErrorMacro;
var VtkDataTypes2 = vtkDataArray$1.VtkDataTypes;
var STATIC2 = {};
function _getFormatForDataArray(dataArray) {
  var format;
  switch (dataArray.getDataType()) {
    case VtkDataTypes2.UNSIGNED_CHAR:
      format = "uint8";
      break;
    case VtkDataTypes2.FLOAT:
      format = "float32";
      break;
    case VtkDataTypes2.UNSIGNED_INT:
      format = "uint32";
      break;
    case VtkDataTypes2.INT:
      format = "sint32";
      break;
    case VtkDataTypes2.DOUBLE:
      format = "float32";
      break;
    case VtkDataTypes2.UNSIGNED_SHORT:
      format = "uint16";
      break;
    case VtkDataTypes2.SHORT:
      format = "sin16";
      break;
    default:
      format = "float32";
      break;
  }
  switch (dataArray.getNumberOfComponents()) {
    case 2:
      format += "x2";
      break;
    case 3:
      if (!format.includes("32")) {
        vtkErrorMacro7("unsupported x3 type for ".concat(format));
      }
      format += "x3";
      break;
    case 4:
      format += "x4";
      break;
  }
  return format;
}
function packArray(indexBuffer, inArrayData, numComp, outputType, options) {
  var result = {};
  var flatSize = indexBuffer.getFlatSize();
  if (!flatSize) {
    return result;
  }
  var shift = [0, 0, 0, 0];
  if (options.shift) {
    if (options.shift.length) {
      shift = options.shift;
    } else {
      shift.fill(options.shift);
    }
  }
  var scale = [1, 1, 1, 1];
  if (options.scale) {
    if (options.scale.length) {
      scale = options.scale;
    } else {
      scale.fill(options.scale);
    }
  }
  var packExtra = Object.prototype.hasOwnProperty.call(options, "packExtra") ? options.packExtra : false;
  var addAPoint;
  var vboidx = 0;
  var stride = numComp + (packExtra ? 1 : 0);
  var packedVBO = newTypedArray(outputType, flatSize * stride);
  var flatIdMap = indexBuffer.getFlatIdToPointId();
  if (options.cellData) {
    flatIdMap = indexBuffer.getFlatIdToCellId();
  }
  if (numComp === 1) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
    };
  } else if (numComp === 2) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
    };
  } else if (numComp === 3 && !packExtra) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];
    };
  } else if (numComp === 3 && packExtra) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];
      packedVBO[vboidx++] = scale[3] * 1 + shift[3];
    };
  } else if (numComp === 4) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];
      packedVBO[vboidx++] = scale[3] * inArrayData[i + 3] + shift[3];
    };
  }
  for (var index = 0; index < flatSize; index++) {
    var inArrayId = numComp * flatIdMap[index];
    addAPoint(inArrayId);
  }
  result.nativeArray = packedVBO;
  return result;
}
function getNormal(pointData, i0, i1, i2) {
  var v1 = [pointData[i2 * 3] - pointData[i1 * 3], pointData[i2 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i2 * 3 + 2] - pointData[i1 * 3 + 2]];
  var v2 = [pointData[i0 * 3] - pointData[i1 * 3], pointData[i0 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i0 * 3 + 2] - pointData[i1 * 3 + 2]];
  var result = [];
  cross(v1, v2, result);
  normalize(result);
  return result;
}
function generateNormals(cellArray, pointArray) {
  var pointData = pointArray.getData();
  var cellArrayData = cellArray.getData();
  if (!cellArrayData || !pointData) {
    return null;
  }
  var packedVBO = new Int8Array(cellArray.getNumberOfCells() * 4);
  var size = cellArrayData.length;
  var vboidx = 0;
  for (var index = 0; index < size; ) {
    var normal = getNormal(pointData, cellArrayData[index + 1], cellArrayData[index + 2], cellArrayData[index + 3]);
    packedVBO[vboidx++] = 127 * normal[0];
    packedVBO[vboidx++] = 127 * normal[1];
    packedVBO[vboidx++] = 127 * normal[2];
    packedVBO[vboidx++] = 127;
    index += cellArrayData[index] + 1;
  }
  return packedVBO;
}
function vtkWebGPUBufferManager(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBufferManager");
  function _createBuffer(req) {
    if (req.dataArray && !req.nativeArray) {
      req.nativeArray = req.dataArray.getData();
    }
    var buffer;
    var gpuUsage;
    if (req.usage === BufferUsage2.Index) {
      buffer = vtkWebGPUIndexBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
      gpuUsage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST;
      buffer.buildIndexBuffer(req);
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setArrayInformation([{
        format: req.format
      }]);
    }
    if (!buffer) {
      buffer = vtkWebGPUBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
    }
    if (req.usage === BufferUsage2.UniformArray) {
      gpuUsage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.Storage) {
      gpuUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.Texture) {
      gpuUsage = GPUBufferUsage.COPY_SRC;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.PointArray) {
      gpuUsage = GPUBufferUsage.VERTEX;
      var arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
      var result = packArray(req.indexBuffer, req.dataArray.getData(), req.dataArray.getNumberOfComponents(), arrayType, {
        packExtra: req.packExtra,
        shift: req.shift,
        scale: req.scale,
        cellData: req.cellData,
        cellOffset: req.cellOffset
      });
      buffer.createAndWrite(result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: req.cellData ? "flat" : "perspective"
      }]);
    }
    if (req.usage === BufferUsage2.NormalsFromPoints) {
      gpuUsage = GPUBufferUsage.VERTEX;
      var _arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
      var normals = generateNormals(req.cells, req.dataArray);
      var _result = packArray(req.indexBuffer, normals, 4, _arrayType, {
        cellData: true
      });
      buffer.createAndWrite(_result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: "flat"
      }]);
    }
    if (req.usage === BufferUsage2.RawVertex) {
      gpuUsage = GPUBufferUsage.VERTEX;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format
      }]);
    }
    buffer.setSourceTime(req.time);
    return buffer;
  }
  publicAPI.hasBuffer = function(hash) {
    return model.device.hasCachedObject(hash);
  };
  publicAPI.getBuffer = function(req) {
    if (req.hash) {
      return model.device.getCachedObject(req.hash, _createBuffer, req);
    }
    return _createBuffer(req);
  };
  publicAPI.getBufferForPointArray = function(dataArray, indexBuffer) {
    var format = _getFormatForDataArray(dataArray);
    var buffRequest = {
      hash: "".concat(dataArray.getMTime(), "I").concat(indexBuffer.getMTime()).concat(format),
      usage: BufferUsage2.PointArray,
      format,
      dataArray,
      indexBuffer
    };
    return publicAPI.getBuffer(buffRequest);
  };
  publicAPI.getFullScreenQuadBuffer = function() {
    if (model.fullScreenQuadBuffer) {
      return model.fullScreenQuadBuffer;
    }
    model.fullScreenQuadBuffer = vtkWebGPUBuffer$1.newInstance();
    model.fullScreenQuadBuffer.setDevice(model.device);
    var array = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0]);
    model.fullScreenQuadBuffer.createAndWrite(array, GPUBufferUsage.VERTEX);
    model.fullScreenQuadBuffer.setStrideInBytes(12);
    model.fullScreenQuadBuffer.setArrayInformation([{
      offset: 0,
      format: "float32x3"
    }]);
    return model.fullScreenQuadBuffer;
  };
}
var DEFAULT_VALUES21 = {
  device: null,
  fullScreenQuadBuffer: null
};
function extend21(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES21, initialValues);
  obj(publicAPI, model);
  setGet(publicAPI, model, ["device"]);
  vtkWebGPUBufferManager(publicAPI, model);
}
var newInstance22 = newInstance(extend21);
var vtkWebGPUBufferManager$1 = _objectSpread5(_objectSpread5({
  newInstance: newInstance22,
  extend: extend21
}, STATIC2), Constants3);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Sampler.js
function vtkWebGPUSampler(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUSampler");
  publicAPI.create = function(device) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    model.device = device;
    model.options.addressModeU = options.addressModeU ? options.addressModeU : "clamp-to-edge";
    model.options.addressModeV = options.addressModeV ? options.addressModeV : "clamp-to-edge";
    model.options.addressModeW = options.addressModeW ? options.addressModeW : "clamp-to-edge";
    model.options.magFilter = options.magFilter ? options.magFilter : "nearest";
    model.options.minFilter = options.minFilter ? options.minFilter : "nearest";
    model.options.mipmapFilter = options.mipmapFilter ? options.mipmapFilter : "nearest";
    model.options.label = model.label;
    model.handle = model.device.getHandle().createSampler(model.options);
    model.bindGroupTime.modified();
  };
  publicAPI.getShaderCode = function(binding, group) {
    var result = "@binding(".concat(binding, ") @group(").concat(group, ") var ").concat(model.label, ": sampler;");
    return result;
  };
  publicAPI.getBindGroupEntry = function() {
    var foo = {
      resource: model.handle
    };
    return foo;
  };
}
var DEFAULT_VALUES22 = {
  device: null,
  handle: null,
  label: null,
  options: null
};
function extend22(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES22, initialValues);
  macro.obj(publicAPI, model);
  model.options = {};
  model.bindGroupLayoutEntry = {
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    sampler: {}
  };
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "handle", "options"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label"]);
  vtkWebGPUSampler(publicAPI, model);
}
var newInstance23 = macro.newInstance(extend22);
var vtkWebGPUSampler$1 = {
  newInstance: newInstance23,
  extend: extend22
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js
var BufferUsage3 = vtkWebGPUBufferManager$1.BufferUsage;
var vtkErrorMacro8 = macro.vtkErrorMacro;
function vtkWebGPUUniformBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUUniformBuffer");
  publicAPI.addEntry = function(name, type) {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro8("entry named ".concat(name, " already exists"));
      return;
    }
    model.sortDirty = true;
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),
      offset: -1,
      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),
      packed: false
    });
  };
  publicAPI.sortBufferEntries = function() {
    if (!model.sortDirty) {
      return;
    }
    var currOffset = 0;
    var newEntries = [];
    var maxAlignment = 4;
    for (var i = 0; i < model.bufferEntries.length; i++) {
      var entry = model.bufferEntries[i];
      if (entry.sizeInBytes % 16 === 0) {
        maxAlignment = Math.max(16, maxAlignment);
      }
      if (entry.sizeInBytes % 8 === 0) {
        maxAlignment = Math.max(8, maxAlignment);
      }
    }
    for (var _i = 0; _i < model.bufferEntries.length; _i++) {
      var _entry = model.bufferEntries[_i];
      if (_entry.packed === false && _entry.sizeInBytes % 16 === 0) {
        _entry.packed = true;
        _entry.offset = currOffset;
        newEntries.push(_entry);
        currOffset += _entry.sizeInBytes;
      }
    }
    for (var _i2 = 0; _i2 < model.bufferEntries.length; _i2++) {
      var _entry2 = model.bufferEntries[_i2];
      if (_entry2.packed === false && _entry2.sizeInBytes === 12) {
        for (var i2 = 0; i2 < model.bufferEntries.length; i2++) {
          var entry2 = model.bufferEntries[i2];
          if (entry2.packed === false && entry2.sizeInBytes === 4) {
            _entry2.packed = true;
            _entry2.offset = currOffset;
            newEntries.push(_entry2);
            currOffset += _entry2.sizeInBytes;
            entry2.packed = true;
            entry2.offset = currOffset;
            newEntries.push(entry2);
            currOffset += entry2.sizeInBytes;
            break;
          }
        }
      }
    }
    for (var _i3 = 0; _i3 < model.bufferEntries.length; _i3++) {
      var _entry3 = model.bufferEntries[_i3];
      if (!_entry3.packed && _entry3.sizeInBytes % 8 === 0) {
        for (var _i4 = _i3 + 1; _i4 < model.bufferEntries.length; _i4++) {
          var _entry4 = model.bufferEntries[_i4];
          if (!_entry4.packed && _entry4.sizeInBytes % 8 === 0) {
            _entry3.packed = true;
            _entry3.offset = currOffset;
            newEntries.push(_entry3);
            currOffset += _entry3.sizeInBytes;
            _entry4.packed = true;
            _entry4.offset = currOffset;
            newEntries.push(_entry4);
            currOffset += _entry4.sizeInBytes;
            break;
          }
        }
      }
    }
    for (var _i5 = 0; _i5 < model.bufferEntries.length; _i5++) {
      var _entry5 = model.bufferEntries[_i5];
      if (!_entry5.packed && _entry5.sizeInBytes % 8 === 0) {
        var found = false;
        for (var _i6 = 0; !found && _i6 < model.bufferEntries.length; _i6++) {
          var _entry6 = model.bufferEntries[_i6];
          if (!_entry6.packed && _entry6.sizeInBytes === 4) {
            for (var i3 = _i6 + 1; i3 < model.bufferEntries.length; i3++) {
              var entry3 = model.bufferEntries[i3];
              if (!entry3.packed && entry3.sizeInBytes === 4) {
                _entry5.packed = true;
                _entry5.offset = currOffset;
                newEntries.push(_entry5);
                currOffset += _entry5.sizeInBytes;
                _entry6.packed = true;
                _entry6.offset = currOffset;
                newEntries.push(_entry6);
                currOffset += _entry6.sizeInBytes;
                entry3.packed = true;
                entry3.offset = currOffset;
                newEntries.push(entry3);
                currOffset += entry3.sizeInBytes;
                found = true;
                break;
              }
            }
          }
        }
      }
    }
    for (var _i7 = 0; _i7 < model.bufferEntries.length; _i7++) {
      var _entry7 = model.bufferEntries[_i7];
      if (!_entry7.packed && _entry7.sizeInBytes > 4) {
        _entry7.packed = true;
        _entry7.offset = currOffset;
        newEntries.push(_entry7);
        currOffset += _entry7.sizeInBytes;
      }
    }
    for (var _i8 = 0; _i8 < model.bufferEntries.length; _i8++) {
      var _entry8 = model.bufferEntries[_i8];
      if (!_entry8.packed) {
        _entry8.packed = true;
        _entry8.offset = currOffset;
        newEntries.push(_entry8);
        currOffset += _entry8.sizeInBytes;
      }
    }
    model.bufferEntries = newEntries;
    model._bufferEntryNames.clear();
    for (var _i9 = 0; _i9 < model.bufferEntries.length; _i9++) {
      model._bufferEntryNames.set(model.bufferEntries[_i9].name, _i9);
    }
    model.sizeInBytes = currOffset;
    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);
    model.sortDirty = false;
  };
  publicAPI.sendIfNeeded = function(device) {
    if (!model.UBO) {
      var req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage3.UniformArray,
        label: model.label
      };
      model.UBO = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model.sendDirty = false;
    }
    if (model.sendDirty) {
      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);
      model.sendDirty = false;
    }
    model.sendTime.modified();
  };
  publicAPI.createView = function(type) {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);
      }
      model[type] = macro.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = function(name, val) {
    publicAPI.sortBufferEntries();
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro8("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    if (entry.lastValue !== val) {
      view[entry.offset / view.BYTES_PER_ELEMENT] = val;
      model.sendDirty = true;
    }
    entry.lastValue = val;
  };
  publicAPI.setArray = function(name, arr) {
    publicAPI.sortBufferEntries();
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro8("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var changed = false;
    for (var i = 0; i < arr.length; i++) {
      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {
        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];
        changed = true;
      }
    }
    if (changed) {
      model.sendDirty = true;
      entry.lastValue = _toConsumableArray(arr);
    }
  };
  publicAPI.getBindGroupEntry = function() {
    var foo = {
      resource: {
        buffer: model.UBO.getHandle()
      }
    };
    return foo;
  };
  publicAPI.getSendTime = function() {
    return model.sendTime.getMTime();
  };
  publicAPI.getShaderCode = function(binding, group) {
    publicAPI.sortBufferEntries();
    var lines = ["struct ".concat(model.label, "Struct\n{")];
    for (var i = 0; i < model.bufferEntries.length; i++) {
      var entry = model.bufferEntries[i];
      lines.push("  ".concat(entry.name, ": ").concat(entry.type, ","));
    }
    lines.push("};\n@binding(".concat(binding, ") @group(").concat(group, ") var<uniform> ").concat(model.label, ": ").concat(model.label, "Struct;"));
    return lines.join("\n");
  };
}
var DEFAULT_VALUES23 = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  bindGroupLayoutEntry: null,
  bindGroupEntry: null
};
function extend23(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES23, initialValues);
  macro.obj(publicAPI, model);
  model._bufferEntryNames = /* @__PURE__ */ new Map();
  model.bufferEntries = [];
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: "uniform"
    }
  };
  model.sendTime = {};
  macro.obj(model.sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.sendDirty = true;
  model.sortDirty = true;
  macro.get(publicAPI, model, ["binding", "bindGroupTime"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label", "sizeInBytes"]);
  vtkWebGPUUniformBuffer(publicAPI, model);
}
var newInstance24 = macro.newInstance(extend23, "vtkWebGPUUniformBuffer");
var vtkWebGPUUniformBuffer$1 = {
  newInstance: newInstance24,
  extend: extend23
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/StorageBuffer.js
var BufferUsage4 = vtkWebGPUBufferManager$1.BufferUsage;
var vtkErrorMacro9 = macro.vtkErrorMacro;
function vtkWebGPUStorageBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUStorageBuffer");
  publicAPI.addEntry = function(name, type) {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro9("entry named ".concat(name, " already exists"));
      return;
    }
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    var sizeInBytes = vtkWebGPUTypes.getByteStrideFromShaderFormat(type);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes,
      offset: model.sizeInBytes,
      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type)
    });
    model.sizeInBytes += sizeInBytes;
  };
  publicAPI.send = function(device) {
    if (!model._buffer) {
      var req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage4.Storage,
        label: model.label
      };
      model._buffer = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model._sendTime.modified();
      return;
    }
    device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);
    model._sendTime.modified();
  };
  publicAPI.createView = function(type) {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);
      }
      model[type] = macro.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = function(name, instance, val) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro9("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;
  };
  publicAPI.setArray = function(name, instance, arr) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro9("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
    for (var i = 0; i < arr.length; i++) {
      view[ioffset + i] = arr[i];
    }
  };
  publicAPI.setAllInstancesFromArray = function(name, arr) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro9("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var numComponents = arr.length / model.numberOfInstances;
    for (var inst = 0; inst < model.numberOfInstances; inst++) {
      var ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (var i = 0; i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i];
      }
    }
  };
  publicAPI.setAllInstancesFromArrayColorToFloat = function(name, arr) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro9("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var numComponents = arr.length / model.numberOfInstances;
    for (var inst = 0; inst < model.numberOfInstances; inst++) {
      var ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (var i = 0; i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i] / 255;
      }
    }
  };
  publicAPI.setAllInstancesFromArray3x3To4x4 = function(name, arr) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro9("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var numComponents = 9;
    for (var inst = 0; inst < model.numberOfInstances; inst++) {
      var ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (var j = 0; j < 3; j++) {
        for (var i = 0; i < 3; i++) {
          view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];
        }
      }
    }
  };
  publicAPI.getSendTime = function() {
    return model._sendTime.getMTime();
  };
  publicAPI.getShaderCode = function(binding, group) {
    var lines = ["struct ".concat(model.label, "StructEntry\n{")];
    for (var i = 0; i < model.bufferEntries.length; i++) {
      var entry = model.bufferEntries[i];
      lines.push("  ".concat(entry.name, ": ").concat(entry.type, ","));
    }
    lines.push("\n};\nstruct ".concat(model.label, "Struct\n{\n  values: array<").concat(model.label, "StructEntry>,\n};\n@binding(").concat(binding, ") @group(").concat(group, ") var<storage, read> ").concat(model.label, ": ").concat(model.label, "Struct;\n"));
    return lines.join("\n");
  };
  publicAPI.getBindGroupEntry = function() {
    var foo = {
      resource: {
        buffer: model._buffer.getHandle()
      }
    };
    return foo;
  };
  publicAPI.clearData = function() {
    model.numberOfInstances = 0;
    model.sizeInBytes = 0;
    model.bufferEntries = [];
    model._bufferEntryNames = /* @__PURE__ */ new Map();
    model._buffer = null;
    delete model.arrayBuffer;
    delete model.Float32Array;
  };
}
var DEFAULT_VALUES24 = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  numberOfInstances: 1
};
function extend24(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES24, initialValues);
  macro.obj(publicAPI, model);
  model._bufferEntryNames = /* @__PURE__ */ new Map();
  model.bufferEntries = [];
  model._sendTime = {};
  macro.obj(model._sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: "read-only-storage"
    }
  };
  macro.get(publicAPI, model, ["bindGroupTime"]);
  macro.setGet(publicAPI, model, ["device", "bindGroupLayoutEntry", "label", "numberOfInstances", "sizeInBytes"]);
  vtkWebGPUStorageBuffer(publicAPI, model);
}
var newInstance25 = macro.newInstance(extend24, "vtkWebGPUStorageBuffer");
var vtkWebGPUStorageBuffer$1 = {
  newInstance: newInstance25,
  extend: extend24
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js
var CLASS_MAPPING2 = /* @__PURE__ */ Object.create(null);
function registerOverride2(className, fn) {
  CLASS_MAPPING2[className] = fn;
}
function vtkWebGPUViewNodeFactory(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUViewNodeFactory");
}
var DEFAULT_VALUES25 = {};
function extend25(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES25, initialValues);
  model.overrides = CLASS_MAPPING2;
  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
  vtkWebGPUViewNodeFactory(publicAPI, model);
}
var newInstance26 = macro.newInstance(extend25, "vtkWebGPUViewNodeFactory");
var vtkWebGPUViewNodeFactory$1 = {
  newInstance: newInstance26,
  extend: extend25
};

export {
  Wrap,
  Filter,
  HalfFloat,
  vtkViewNode$1,
  registerOverride,
  vtkViewNodeFactory2 as vtkViewNodeFactory,
  vtkOpenGLTexture$1,
  vtkShaderProgram$1,
  vtkVertexArrayObject,
  vtkHelper,
  vtkWebGPUShaderCache$1,
  vtkWebGPUBindGroup$1,
  vtkWebGPUTypes,
  vtkWebGPUSimpleMapper$1,
  vtkWebGPUFullScreenQuad$1,
  vtkWebGPUBuffer$1,
  vtkWebGPUBufferManager$1,
  vtkWebGPUSampler$1,
  vtkWebGPUUniformBuffer$1,
  vtkWebGPUStorageBuffer$1,
  registerOverride2,
  vtkWebGPUViewNodeFactory$1
};
//# sourceMappingURL=chunk-WDDAGUM6.js.map
