import {
  styleInject
} from "./chunk-XK2Y52IZ.js";
import {
  arrayRange
} from "./chunk-FOWOP5PK.js";
import {
  _toConsumableArray,
  macro
} from "./chunk-OTTIIP4A.js";
import {
  _defineProperty
} from "./chunk-HKWV5KNA.js";
import {
  _slicedToArray
} from "./chunk-XL65WI7U.js";
import {
  __commonJS,
  __toESM
} from "./chunk-HUBM7RA2.js";

// node_modules/webworker-promise/src/tiny-emitter.js
var require_tiny_emitter = __commonJS({
  "node_modules/webworker-promise/src/tiny-emitter.js"(exports, module) {
    var TinyEmitter = class {
      constructor() {
        Object.defineProperty(this, "__listeners", {
          value: {},
          enumerable: false,
          writable: false
        });
      }
      emit(eventName, ...args) {
        if (!this.__listeners[eventName])
          return this;
        for (const handler of this.__listeners[eventName]) {
          handler(...args);
        }
        return this;
      }
      once(eventName, handler) {
        const once = (...args) => {
          this.off(eventName, once);
          handler(...args);
        };
        return this.on(eventName, once);
      }
      on(eventName, handler) {
        if (!this.__listeners[eventName])
          this.__listeners[eventName] = [];
        this.__listeners[eventName].push(handler);
        return this;
      }
      off(eventName, handler) {
        if (handler)
          this.__listeners[eventName] = this.__listeners[eventName].filter((h) => h !== handler);
        else
          this.__listeners[eventName] = [];
        return this;
      }
    };
    module.exports = TinyEmitter;
  }
});

// node_modules/webworker-promise/src/index.js
var require_src = __commonJS({
  "node_modules/webworker-promise/src/index.js"(exports, module) {
    var TinyEmitter = require_tiny_emitter();
    var MESSAGE_RESULT = 0;
    var MESSAGE_EVENT = 1;
    var RESULT_SUCCESS = 1;
    var Worker2 = class extends TinyEmitter {
      constructor(worker) {
        super();
        this._messageId = 1;
        this._messages = /* @__PURE__ */ new Map();
        this._worker = worker;
        this._worker.onmessage = this._onMessage.bind(this);
        this._id = Math.ceil(Math.random() * 1e7);
      }
      terminate() {
        this._worker.terminate();
      }
      isFree() {
        return this._messages.size === 0;
      }
      jobsLength() {
        return this._messages.size;
      }
      exec(operationName, data = null, transferable = [], onEvent) {
        return new Promise((res, rej) => {
          const messageId = this._messageId++;
          this._messages.set(messageId, [res, rej, onEvent]);
          this._worker.postMessage([messageId, data, operationName], transferable || []);
        });
      }
      postMessage(data = null, transferable = [], onEvent) {
        return new Promise((res, rej) => {
          const messageId = this._messageId++;
          this._messages.set(messageId, [res, rej, onEvent]);
          this._worker.postMessage([messageId, data], transferable || []);
        });
      }
      emit(eventName, ...args) {
        this._worker.postMessage({ eventName, args });
      }
      _onMessage(e) {
        if (!Array.isArray(e.data) && e.data.eventName) {
          return super.emit(e.data.eventName, ...e.data.args);
        }
        const [type, ...args] = e.data;
        if (type === MESSAGE_EVENT)
          this._onEvent(...args);
        else if (type === MESSAGE_RESULT)
          this._onResult(...args);
        else
          throw new Error(`Wrong message type '${type}'`);
      }
      _onResult(messageId, success, payload) {
        const [res, rej] = this._messages.get(messageId);
        this._messages.delete(messageId);
        return success === RESULT_SUCCESS ? res(payload) : rej(payload);
      }
      _onEvent(messageId, eventName, data) {
        const [, , onEvent] = this._messages.get(messageId);
        if (onEvent) {
          onEvent(eventName, data);
        }
      }
    };
    module.exports = Worker2;
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/LiteColorMaps.json.js
var vtkColorMaps = [
  {
    ColorSpace: "Diverging",
    Name: "Cool to Warm",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.23137254902,
      0.298039215686,
      0.752941176471,
      0.5,
      0.865,
      0.865,
      0.865,
      1,
      0.705882352941,
      0.0156862745098,
      0.149019607843
    ]
  },
  {
    ColorSpace: "Diverging",
    Name: "Warm to Cool",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.705882352941,
      0.0156862745098,
      0.149019607843,
      0.5,
      0.865,
      0.865,
      0.865,
      1,
      0.23137254902,
      0.298039215686,
      0.752941176471
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Rainbow Desaturated",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0.278431372549,
      0.278431372549,
      0.858823529412,
      0.143,
      0,
      0,
      0.360784313725,
      0.285,
      0,
      1,
      1,
      0.429,
      0,
      0.501960784314,
      0,
      0.571,
      1,
      1,
      0,
      0.714,
      1,
      0.380392156863,
      0,
      0.857,
      0.419607843137,
      0,
      0,
      1,
      0.878431372549,
      0.301960784314,
      0.301960784314
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Cold and Hot",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      1,
      1,
      0.45,
      0,
      0,
      1,
      0.5,
      0,
      0,
      0.501960784314,
      0.55,
      1,
      0,
      0,
      1,
      1,
      1,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Black-Body Radiation",
    NanColor: [
      0,
      0.498039215686,
      1
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.4,
      0.901960784314,
      0,
      0,
      0.8,
      0.901960784314,
      0.901960784314,
      0,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "X Ray",
    NanColor: [
      1,
      0,
      0
    ],
    RGBPoints: [
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Grayscale",
    NanColor: [
      1,
      0,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Black, Blue and White",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.333,
      0,
      0,
      0.501960784314,
      0.666,
      0,
      0.501960784314,
      1,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "RGB",
    Name: "Black, Orange and White",
    NanColor: [
      1,
      1,
      0
    ],
    RGBPoints: [
      0,
      0,
      0,
      0,
      0.333,
      0.501960784314,
      0,
      0,
      0.666,
      1,
      0.501960784314,
      0,
      1,
      1,
      1,
      1
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_rainbow_bright",
    RGBPoints: [
      -1,
      0.32549,
      0.14902,
      0.960784,
      -0.866221,
      0.297047,
      0.375586,
      0.963836,
      -0.732441,
      0.180302,
      0.536818,
      0.964627,
      -0.598662,
      0.1302,
      0.649207,
      0.929647,
      -0.464883,
      0.0445143,
      0.749654,
      0.855998,
      -0.331104,
      0.0271325,
      0.830713,
      0.721527,
      -0.197324,
      0.259504,
      0.866145,
      0.543555,
      -0.0635452,
      0.428364,
      0.890725,
      0.329819,
      0.0702341,
      0.568503,
      0.898508,
      0.187623,
      0.204013,
      0.738259,
      0.890317,
      0.0825461,
      0.337793,
      0.84546,
      0.86136,
      0.0147555,
      0.471572,
      0.912191,
      0.808018,
      0,
      0.605351,
      0.962848,
      0.710445,
      0,
      0.73913,
      0.999469,
      0.600258,
      0.0176284,
      0.87291,
      0.994156,
      0.445975,
      0.193912,
      1,
      0.980407,
      0.247105,
      0.262699
    ]
  },
  {
    ColorSpace: "Lab",
    Name: "erdc_rainbow_dark",
    RGBPoints: [
      -1,
      0,
      0,
      0.423499,
      -0.866221,
      0,
      0.119346,
      0.529237,
      -0.732441,
      0,
      0.238691,
      0.634976,
      -0.598662,
      0,
      0.346852,
      0.68788,
      -0.464883,
      0,
      0.45022,
      0.718141,
      -0.331104,
      0,
      0.553554,
      0.664839,
      -0.197324,
      0,
      0.651082,
      0.519303,
      -0.0635452,
      0.115841,
      0.72479,
      0.352857,
      0.0702341,
      0.326771,
      0.781195,
      0.140187,
      0.204013,
      0.522765,
      0.798524,
      0.0284624,
      0.337793,
      0.703162,
      0.788685,
      885756e-8,
      0.471572,
      0.845118,
      0.751133,
      0,
      0.605351,
      0.955734,
      0.690825,
      0,
      0.73913,
      0.995402,
      0.567916,
      0.0618524,
      0.87291,
      0.987712,
      0.403398,
      0.164851,
      1,
      0.980407,
      0.247105,
      0.262699
    ]
  }
];

// node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMapsLite.js
var presetMap = /* @__PURE__ */ Object.create(null);
vtkColorMaps.filter(function(p) {
  return p.RGBPoints;
}).filter(function(p) {
  return p.ColorSpace !== "CIELAB";
}).forEach(function(p) {
  presetMap[p.Name] = p;
});
var rgbPresetNames = Object.keys(presetMap);
rgbPresetNames.sort();
function getPresetByName(name) {
  return presetMap[name];
}
function addPreset(preset) {
  if (!preset.RGBPoints || preset.ColorSpace === "CIELAB") {
    return;
  }
  if (!presetMap[preset.Name]) {
    rgbPresetNames.push(preset.Name);
    rgbPresetNames.sort();
  }
  presetMap[preset.Name] = preset;
}
function removePresetByName(name) {
  var index = rgbPresetNames.indexOf(name);
  if (index > -1) {
    rgbPresetNames.splice(index, 1);
  }
  delete presetMap[name];
}
var vtkColorMaps2 = {
  addPreset,
  removePresetByName,
  getPresetByName,
  rgbPresetNames
};

// node_modules/@kitware/vtk.js/Interaction/Widgets/PiecewiseGaussianWidget.js
var import_webworker_promise = __toESM(require_src());

// node_modules/@kitware/vtk.js/_virtual/rollup-plugin-web-worker-loader__helper__funcToSource.js
function funcToSource(fn, sourcemapArg) {
  var sourcemap = sourcemapArg === void 0 ? null : sourcemapArg;
  var regex = /(['"])__worker_loader_strict__(['"])/g;
  var lines = [];
  var source = fn.toString();
  source = source.replace(regex, "$1use strict$2");
  lines.push("(" + source + ")()");
  if (sourcemap) {
    lines.push("//# sourceMappingURL=" + sourcemap + "\n");
  }
  return lines;
}

// node_modules/@kitware/vtk.js/_virtual/rollup-plugin-web-worker-loader__helper__browser__createInlineWorkerFactory.js
function createURL(fn, sourcemapArg) {
  var lines = funcToSource(fn, sourcemapArg);
  var blob = new Blob(lines, { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function createInlineWorkerFactory(fn, sourcemapArg) {
  var url;
  return function WorkerFactory2(options) {
    url = url || createURL(fn, sourcemapArg);
    return new Worker(url, options);
  };
}

// node_modules/@kitware/vtk.js/_virtual/rollup-plugin-worker-loader__module_Sources/Interaction/Widgets/PiecewiseGaussianWidget/ComputeHistogram.worker.js
var WorkerFactory = createInlineWorkerFactory(function() {
  (function() {
    "__worker_loader_strict__";
    var register = { exports: {} };
    var _createClass$1 = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var TinyEmitter$1 = function() {
      function TinyEmitter2() {
        _classCallCheck$1(this, TinyEmitter2);
        Object.defineProperty(this, "__listeners", {
          value: {},
          enumerable: false,
          writable: false
        });
      }
      _createClass$1(TinyEmitter2, [{
        key: "emit",
        value: function emit(eventName) {
          if (!this.__listeners[eventName])
            return this;
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = this.__listeners[eventName][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var handler = _step.value;
              handler.apply(void 0, args);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return this;
        }
      }, {
        key: "once",
        value: function once(eventName, handler) {
          var _this = this;
          var once2 = function once3() {
            _this.off(eventName, once3);
            handler.apply(void 0, arguments);
          };
          return this.on(eventName, once2);
        }
      }, {
        key: "on",
        value: function on(eventName, handler) {
          if (!this.__listeners[eventName])
            this.__listeners[eventName] = [];
          this.__listeners[eventName].push(handler);
          return this;
        }
      }, {
        key: "off",
        value: function off(eventName, handler) {
          if (handler)
            this.__listeners[eventName] = this.__listeners[eventName].filter(function(h) {
              return h !== handler;
            });
          else
            this.__listeners[eventName] = [];
          return this;
        }
      }]);
      return TinyEmitter2;
    }();
    var tinyEmitter = TinyEmitter$1;
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _get = function get(object, property, receiver) {
      if (object === null)
        object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);
      if (desc === void 0) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return void 0;
        } else {
          return get(parent, property, receiver);
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === void 0) {
          return void 0;
        }
        return getter.call(receiver);
      }
    };
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    function _toConsumableArray2(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var TinyEmitter = tinyEmitter;
    var MESSAGE_RESULT = 0;
    var MESSAGE_EVENT = 1;
    var RESULT_ERROR = 0;
    var RESULT_SUCCESS = 1;
    var DEFAULT_HANDLER = "main";
    var isPromise = function isPromise2(o) {
      return (typeof o === "undefined" ? "undefined" : _typeof(o)) === "object" && o !== null && typeof o.then === "function" && typeof o.catch === "function";
    };
    function RegisterPromise(fn) {
      var handlers = _defineProperty2({}, DEFAULT_HANDLER, fn);
      var sendPostMessage = self.postMessage.bind(self);
      var server = new (function(_TinyEmitter) {
        _inherits(WorkerRegister, _TinyEmitter);
        function WorkerRegister() {
          _classCallCheck(this, WorkerRegister);
          return _possibleConstructorReturn(this, (WorkerRegister.__proto__ || Object.getPrototypeOf(WorkerRegister)).apply(this, arguments));
        }
        _createClass(WorkerRegister, [{
          key: "emit",
          value: function emit(eventName) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            if (args.length == 1 && args[0] instanceof TransferableResponse) {
              sendPostMessage({ eventName, args }, args[0].transferable);
            } else {
              sendPostMessage({ eventName, args });
            }
            return this;
          }
        }, {
          key: "emitLocally",
          value: function emitLocally(eventName) {
            var _get2;
            for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            (_get2 = _get(WorkerRegister.prototype.__proto__ || Object.getPrototypeOf(WorkerRegister.prototype), "emit", this)).call.apply(_get2, [this, eventName].concat(args));
          }
        }, {
          key: "operation",
          value: function operation(name, handler) {
            handlers[name] = handler;
            return this;
          }
        }]);
        return WorkerRegister;
      }(TinyEmitter))();
      var run = function run2(messageId, payload, handlerName) {
        var onSuccess = function onSuccess2(result2) {
          if (result2 && result2 instanceof TransferableResponse) {
            sendResult(messageId, RESULT_SUCCESS, result2.payload, result2.transferable);
          } else {
            sendResult(messageId, RESULT_SUCCESS, result2);
          }
        };
        var onError = function onError2(e) {
          sendResult(messageId, RESULT_ERROR, {
            message: e.message,
            stack: e.stack
          });
        };
        try {
          var result = runFn(messageId, payload, handlerName);
          if (isPromise(result)) {
            result.then(onSuccess).catch(onError);
          } else {
            onSuccess(result);
          }
        } catch (e) {
          onError(e);
        }
      };
      var runFn = function runFn2(messageId, payload, handlerName) {
        var handler = handlers[handlerName || DEFAULT_HANDLER];
        if (!handler)
          throw new Error("Not found handler for this request");
        return handler(payload, sendEvent.bind(null, messageId));
      };
      var sendResult = function sendResult2(messageId, success, payload) {
        var transferable = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
        sendPostMessage([MESSAGE_RESULT, messageId, success, payload], transferable);
      };
      var sendEvent = function sendEvent2(messageId, eventName, payload) {
        if (!eventName)
          throw new Error("eventName is required");
        if (typeof eventName !== "string")
          throw new Error("eventName should be string");
        sendPostMessage([MESSAGE_EVENT, messageId, eventName, payload]);
      };
      self.addEventListener("message", function(_ref) {
        var data = _ref.data;
        if (Array.isArray(data)) {
          run.apply(void 0, _toConsumableArray2(data));
        } else if (data && data.eventName) {
          server.emitLocally.apply(server, [data.eventName].concat(_toConsumableArray2(data.args)));
        }
      });
      return server;
    }
    var TransferableResponse = function TransferableResponse2(payload, transferable) {
      _classCallCheck(this, TransferableResponse2);
      this.payload = payload;
      this.transferable = transferable;
    };
    register.exports = RegisterPromise;
    register.exports.TransferableResponse = TransferableResponse;
    var registerWebworker = register.exports;
    registerWebworker(function(message, emit) {
      var array = message.array;
      var min = message.min;
      var max = message.max;
      var offset = message.component || 0;
      var step = message.numberOfComponents || 1;
      var numberOfBins = message.numberOfBins;
      var delta = max - min;
      var histogram = new Float32Array(numberOfBins);
      histogram.fill(0);
      var len = array.length;
      for (var i = offset; i < len; i += step) {
        var idx = Math.floor((numberOfBins - 1) * (Number(array[i]) - min) / delta);
        histogram[idx] += 1;
      }
      return Promise.resolve(new registerWebworker.TransferableResponse(histogram, [histogram.buffer]));
    });
  })();
}, null);

// node_modules/@kitware/vtk.js/Interaction/Widgets/PiecewiseGaussianWidget.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var MIN_GAUSSIAN_WIDTH = 1e-3;
var ACTION_TO_CURSOR = {
  adjustPosition: "-webkit-grab",
  adjustHeight: "row-resize",
  adjustBias: "crosshair",
  adjustWidth: "col-resize",
  adjustZoom: "col-resize"
};
var TOUCH_CLICK = [];
var ACTIONS = {
  adjustPosition: function adjustPosition(x, y, _ref) {
    var originalXY = _ref.originalXY, gaussian = _ref.gaussian, originalGaussian = _ref.originalGaussian;
    var xOffset = originalGaussian.position - originalXY[0];
    gaussian.position = x + xOffset;
    return true;
  },
  adjustHeight: function adjustHeight(x, y, _ref2) {
    var model = _ref2.model, gaussian = _ref2.gaussian;
    gaussian.height = 1 - y;
    gaussian.height = Math.min(1, Math.max(model.gaussianMinimumHeight, gaussian.height));
    return true;
  },
  adjustBias: function adjustBias(x, y, _ref3) {
    var originalXY = _ref3.originalXY, gaussian = _ref3.gaussian, originalGaussian = _ref3.originalGaussian;
    gaussian.xBias = originalGaussian.xBias - (originalXY[0] - x) / gaussian.height;
    gaussian.yBias = originalGaussian.yBias + 4 * (originalXY[1] - y) / gaussian.height;
    gaussian.xBias = Math.max(-1, Math.min(1, gaussian.xBias));
    gaussian.yBias = Math.max(0, Math.min(2, gaussian.yBias));
    return true;
  },
  adjustWidth: function adjustWidth(x, y, _ref4) {
    var originalXY = _ref4.originalXY, gaussian = _ref4.gaussian, originalGaussian = _ref4.originalGaussian, gaussianSide = _ref4.gaussianSide;
    gaussian.width = gaussianSide < 0 ? originalGaussian.width - (originalXY[0] - x) : originalGaussian.width + (originalXY[0] - x);
    if (gaussian.width < MIN_GAUSSIAN_WIDTH) {
      gaussian.width = MIN_GAUSSIAN_WIDTH;
    }
    return true;
  },
  adjustZoom: function adjustZoom(x, y, _ref5) {
    var rangeZoom = _ref5.rangeZoom, publicAPI = _ref5.publicAPI;
    var delta = rangeZoom[1] - rangeZoom[0];
    var absNormX = (x - rangeZoom[0]) / delta;
    var minDelta = Math.abs(absNormX - rangeZoom[0]);
    var maxDelta = Math.abs(absNormX - rangeZoom[1]);
    var meanDelta = Math.abs(absNormX - 0.5 * (rangeZoom[0] + rangeZoom[1]));
    if (meanDelta < Math.min(minDelta, maxDelta)) {
      var halfDelta = delta * 0.5;
      rangeZoom[0] = Math.min(Math.max(absNormX - halfDelta, 0), rangeZoom[1] - 0.1);
      rangeZoom[1] = Math.max(Math.min(absNormX + halfDelta, 1), rangeZoom[0] + 0.1);
    } else if (minDelta < maxDelta) {
      rangeZoom[0] = Math.min(Math.max(absNormX, 0), rangeZoom[1] - 0.1);
    } else {
      rangeZoom[1] = Math.max(Math.min(absNormX, 1), rangeZoom[0] + 0.1);
    }
    publicAPI.invokeZoomChange(rangeZoom);
    return false;
  }
};
function computeOpacities(gaussians) {
  var sampling = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 256;
  var opacities = [];
  while (opacities.length < sampling) {
    opacities.push(0);
  }
  var count = gaussians.length;
  while (count--) {
    var _gaussians$count = gaussians[count], position = _gaussians$count.position, height = _gaussians$count.height, width = _gaussians$count.width, xBias = _gaussians$count.xBias, yBias = _gaussians$count.yBias;
    for (var i = 0; i < sampling; i++) {
      var x = i / (sampling - 1);
      if (x > position + width || x < position - width) {
        if (opacities[i] < 0) {
          opacities[i] = 0;
        }
        continue;
      }
      var correctedWidth = width < MIN_GAUSSIAN_WIDTH ? MIN_GAUSSIAN_WIDTH : width;
      var x0 = 0;
      if (xBias === 0 || x === position + xBias) {
        x0 = x;
      } else if (x > position + xBias) {
        if (correctedWidth === xBias) {
          x0 = position;
        } else {
          x0 = position + (x - position - xBias) * (correctedWidth / (correctedWidth - xBias));
        }
      } else if (-correctedWidth === xBias) {
        x0 = position;
      } else {
        x0 = position - (x - position - xBias) * (correctedWidth / (correctedWidth + xBias));
      }
      var x1 = (x0 - position) / correctedWidth;
      var h0a = Math.exp(-(4 * x1 * x1));
      var h0b = 1 - x1 * x1;
      var h0c = 1;
      var h1 = void 0;
      if (yBias < 1) {
        h1 = yBias * h0b + (1 - yBias) * h0a;
      } else {
        h1 = (2 - yBias) * h0b + (yBias - 1) * h0c;
      }
      var h2 = height * h1;
      if (h2 > opacities[i]) {
        opacities[i] = h2;
      }
    }
  }
  return opacities;
}
function applyGaussianToPiecewiseFunction(gaussians, sampling, rangeToUse, piecewiseFunction) {
  var opacities = computeOpacities(gaussians, sampling);
  var nodes = [];
  var delta = (rangeToUse[1] - rangeToUse[0]) / (opacities.length - 1);
  var midpoint = 0.5;
  var sharpness = 0;
  for (var index = 0; index < opacities.length; index++) {
    var x = rangeToUse[0] + delta * index;
    var y = opacities[index];
    nodes.push({
      x,
      y,
      midpoint,
      sharpness
    });
  }
  piecewiseFunction.setNodes(nodes);
}
function drawChart(ctx, area, values) {
  var style2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
    lineWidth: 1,
    strokeStyle: "#000"
  };
  var verticalScale = area[3];
  var horizontalScale = area[2] / (values.length - 1);
  var fill = !!style2.fillStyle;
  var offset = verticalScale + area[1];
  ctx.lineWidth = style2.lineWidth;
  ctx.strokeStyle = style2.strokeStyle;
  ctx.beginPath();
  ctx.moveTo(area[0], area[1] + area[3]);
  for (var index = 0; index < values.length; index++) {
    ctx.lineTo(area[0] + index * horizontalScale, Math.max(area[1], offset - values[index] * verticalScale));
  }
  if (fill) {
    ctx.fillStyle = style2.fillStyle;
    ctx.lineTo(area[0] + area[2], area[1] + area[3]);
    if (style2.clip) {
      ctx.clip();
      return;
    }
    ctx.fill();
  }
  ctx.stroke();
}
function updateColorCanvas(colorTransferFunction, width, rangeToUse, canvas) {
  var workCanvas = canvas || document.createElement("canvas");
  workCanvas.setAttribute("width", width);
  workCanvas.setAttribute("height", 256);
  var ctx = workCanvas.getContext("2d");
  var rgba = colorTransferFunction.getUint8Table(rangeToUse[0], rangeToUse[1], width, 4);
  var pixelsArea = ctx.getImageData(0, 0, width, 256);
  for (var lineIdx = 0; lineIdx < 256; lineIdx++) {
    pixelsArea.data.set(rgba, lineIdx * 4 * width);
  }
  var nbValues = 256 * width * 4;
  var lineSize = width * 4;
  for (var i = 3; i < nbValues; i += 4) {
    pixelsArea.data[i] = 255 - Math.floor(i / lineSize);
  }
  ctx.putImageData(pixelsArea, 0, 0);
  return workCanvas;
}
function updateColorCanvasFromImage(img, width, canvas) {
  var workCanvas = canvas || document.createElement("canvas");
  workCanvas.setAttribute("width", width);
  workCanvas.setAttribute("height", 256);
  var ctx = workCanvas.getContext("2d");
  ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, 256);
  return workCanvas;
}
function normalizeCoordinates(x, y, subRectangeArea) {
  var zoomRange = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [0, 1];
  return [zoomRange[0] + (x - subRectangeArea[0]) / subRectangeArea[2] * (zoomRange[1] - zoomRange[0]), (y - subRectangeArea[1]) / subRectangeArea[3]];
}
function findGaussian(x, gaussians) {
  var distances = gaussians.map(function(g) {
    return Math.abs(g.position - x);
  });
  var min = Math.min.apply(Math, _toConsumableArray(distances));
  return distances.indexOf(min);
}
function createListener(callback) {
  var preventDefault = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return function(e) {
    var offsetX = e.offsetX, offsetY = e.offsetY;
    if (preventDefault) {
      e.preventDefault();
    }
    callback(offsetX, offsetY);
  };
}
function createTouchClickListener() {
  var id = TOUCH_CLICK.length;
  for (var _len = arguments.length, callbacks = new Array(_len), _key = 0; _key < _len; _key++) {
    callbacks[_key] = arguments[_key];
  }
  TOUCH_CLICK.push({
    callbacks,
    timeout: 0,
    deltaT: 200,
    count: 0,
    ready: false
  });
  return id;
}
function processTouchClicks() {
  TOUCH_CLICK.filter(function(t) {
    return t.ready;
  }).forEach(function(touchHandle) {
    touchHandle.callbacks.forEach(function(callback) {
      if (callback.touches === touchHandle.touches && callback.clicks === touchHandle.count) {
        callback.action.apply(callback, _toConsumableArray(touchHandle.singleTouche));
      }
    });
    touchHandle.ts = 0;
    touchHandle.count = 0;
    touchHandle.touches = 0;
    touchHandle.ready = false;
  });
}
function createTouchListener(id, callback) {
  var nbTouches = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var preventDefault = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  return function(e) {
    var targetBounds = e.target.getBoundingClientRect();
    var relativeTouches = Array.prototype.map.call(e.touches, function(t) {
      return [t.pageX - targetBounds.left, t.pageY - targetBounds.top];
    });
    var singleTouche = relativeTouches.reduce(function(a, b) {
      return [a[0] + b[0], a[1] + b[1]];
    }, [0, 0]).map(function(v) {
      return v / e.touches.length;
    });
    if (e.type === "touchstart") {
      clearTimeout(TOUCH_CLICK[id].timeout);
      TOUCH_CLICK[id].ts = e.timeStamp;
      TOUCH_CLICK[id].singleTouche = singleTouche;
      TOUCH_CLICK[id].touches = e.touches.length;
    } else if (e.type === "touchmove") {
      TOUCH_CLICK[id].ts = 0;
      TOUCH_CLICK[id].count = 0;
      TOUCH_CLICK[id].ready = false;
    } else if (e.type === "touchend") {
      if (e.timeStamp - TOUCH_CLICK[id].ts < TOUCH_CLICK[id].deltaT) {
        TOUCH_CLICK[id].count += 1;
        TOUCH_CLICK[id].ready = true;
        if (preventDefault) {
          e.preventDefault();
        }
        TOUCH_CLICK[id].timeout = setTimeout(processTouchClicks, TOUCH_CLICK[id].deltaT);
      } else {
        TOUCH_CLICK[id].ready = false;
      }
    }
    if (e.touches.length === nbTouches) {
      callback.apply(void 0, _toConsumableArray(singleTouche));
      if (preventDefault) {
        e.preventDefault();
      }
    }
  };
}
function listenerSelector(condition, ok, ko) {
  return function(e) {
    return condition() ? ok(e) : ko(e);
  };
}
function rescaleArray(array, focusArea) {
  if (!focusArea) {
    return array;
  }
  var maxIdx = array.length - 1;
  var idxRange = focusArea.map(function(v) {
    return Math.round(v * maxIdx);
  });
  return array.slice(idxRange[0], idxRange[1] + 1);
}
function rescaleValue(value, focusArea) {
  if (!focusArea) {
    return value;
  }
  return (value - focusArea[0]) / (focusArea[1] - focusArea[0]);
}
var STATIC = {
  applyGaussianToPiecewiseFunction,
  computeOpacities,
  createListener,
  drawChart,
  findGaussian,
  listenerSelector,
  normalizeCoordinates
};
function vtkPiecewiseGaussianWidget(publicAPI, model) {
  model.classHierarchy.push("vtkPiecewiseGaussianWidget");
  if (!model.canvas) {
    model.canvas = document.createElement("canvas");
  }
  publicAPI.setContainer = function(el) {
    if (model.container && model.container !== el) {
      model.container.removeChild(model.canvas);
    }
    if (model.container !== el) {
      model.container = el;
      if (model.container) {
        model.container.appendChild(model.canvas);
      }
      publicAPI.modified();
    }
  };
  publicAPI.setGaussians = function(gaussians) {
    if (model.gaussians === gaussians) {
      return;
    }
    model.gaussians = gaussians;
    model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);
    publicAPI.invokeOpacityChange(publicAPI);
    publicAPI.modified();
  };
  publicAPI.addGaussian = function(position, height, width, xBias, yBias) {
    var nextIndex = model.gaussians.length;
    model.gaussians.push({
      position,
      height,
      width,
      xBias,
      yBias
    });
    model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);
    publicAPI.invokeOpacityChange(publicAPI);
    publicAPI.modified();
    return nextIndex;
  };
  publicAPI.removeGaussian = function(index) {
    model.gaussians.splice(index, 1);
    model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);
    publicAPI.invokeOpacityChange(publicAPI);
    publicAPI.modified();
  };
  publicAPI.setSize = function(width, height) {
    model.canvas.setAttribute("width", width);
    model.canvas.setAttribute("height", height);
    if (model.size[0] !== width || model.size[1] !== height) {
      model.size = [width, height];
      model.colorCanvasMTime = 0;
      publicAPI.modified();
    }
  };
  publicAPI.updateStyle = function(style2) {
    model.style = _objectSpread(_objectSpread({}, model.style), style2);
    publicAPI.modified();
  };
  publicAPI.setDataArray = function(array) {
    var _ref6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref6$numberOfBinToCo = _ref6.numberOfBinToConsiders, numberOfBinToConsiders = _ref6$numberOfBinToCo === void 0 ? 1 : _ref6$numberOfBinToCo, _ref6$numberOfBinsToS = _ref6.numberOfBinsToSkip, numberOfBinsToSkip = _ref6$numberOfBinsToS === void 0 ? 1 : _ref6$numberOfBinsToS, _ref6$numberOfCompone = _ref6.numberOfComponents, numberOfComponents = _ref6$numberOfCompone === void 0 ? 1 : _ref6$numberOfCompone, _ref6$component = _ref6.component, component = _ref6$component === void 0 ? 0 : _ref6$component;
    model.histogram = null;
    model.histogramArray = array;
    model.dataRange = arrayRange(array, component, numberOfComponents);
    var _model$dataRange = _slicedToArray(model.dataRange, 2), min = _model$dataRange[0], max = _model$dataRange[1];
    var maxNumberOfWorkers = 4;
    var arrayStride = Math.floor(array.length / maxNumberOfWorkers) || 1;
    arrayStride += arrayStride % numberOfComponents;
    var arrayIndex = 0;
    var workerChunks = [];
    var workers = [];
    while (arrayIndex < array.length) {
      var worker = new WorkerFactory();
      workers.push(worker);
      var workerPromise = new import_webworker_promise.default(worker);
      var arrayStart = arrayIndex;
      var arrayEnd = Math.min(arrayIndex + arrayStride, array.length - 1);
      var subArray = new array.constructor(array.slice(arrayStart, arrayEnd + 1));
      workerChunks.push(workerPromise.postMessage({
        array: subArray,
        component,
        numberOfComponents,
        min,
        max,
        numberOfBins: model.numberOfBins
      }, [subArray.buffer]));
      arrayIndex += arrayStride;
    }
    Promise.all(workerChunks).then(function(subHistograms) {
      workers.forEach(function(worker2) {
        return worker2.terminate();
      });
      model.histogram = new Float32Array(model.numberOfBins);
      model.histogram.fill(0);
      subHistograms.forEach(function(subHistogram) {
        for (var i2 = 0, len2 = subHistogram.length; i2 < len2; ++i2) {
          model.histogram[i2] += subHistogram[i2];
        }
      });
      var sampleSize = Math.min(numberOfBinToConsiders, model.histogram.length - numberOfBinsToSkip);
      var sortedArray = Array.from(model.histogram);
      sortedArray.sort(function(a, b) {
        return Number(a) - Number(b);
      });
      for (var i = 0; i < numberOfBinsToSkip; i++) {
        sortedArray.pop();
      }
      while (sortedArray.length > sampleSize) {
        sortedArray.shift();
      }
      var mean = sortedArray.reduce(function(a, b) {
        return a + b;
      }, 0) / sampleSize;
      for (var _i = 0, len = model.histogram.length; _i < len; ++_i) {
        model.histogram[_i] /= mean;
      }
      publicAPI.modified();
      setTimeout(publicAPI.render, 0);
    });
    publicAPI.modified();
  };
  publicAPI.onClick = function(x, y) {
    var _normalizeCoordinates = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null), _normalizeCoordinates2 = _slicedToArray(_normalizeCoordinates, 2), xNormalized = _normalizeCoordinates2[0], yNormalized = _normalizeCoordinates2[1];
    if (xNormalized < 0 && model.style.iconSize > 1) {
      var delta = model.style.iconSize + model.style.padding;
      var offset = delta;
      var buttonIdx = 0;
      while (y > offset) {
        buttonIdx += 1;
        offset += delta;
      }
      switch (buttonIdx) {
        case 0: {
          var gaussianIdx = publicAPI.addGaussian(0, 1, 0.1, 0, 0);
          var gaussian = model.gaussians[gaussianIdx];
          var originalGaussian = _objectSpread({}, gaussian);
          var action = ACTIONS.adjustPosition;
          model.activeGaussian = gaussianIdx;
          model.selectedGaussian = gaussianIdx;
          macro.setImmediate(function() {
            publicAPI.onDown(x, y);
            model.dragAction = {
              originalXY: [0, 0],
              action,
              gaussian,
              originalGaussian
            };
          });
          break;
        }
        case 1: {
          if (model.selectedGaussian !== -1) {
            publicAPI.removeGaussian(model.selectedGaussian);
          }
          break;
        }
        default: {
          model.selectedGaussian = -1;
          model.dragAction = null;
        }
      }
    } else if (xNormalized < 0 || xNormalized > 1 || yNormalized < 0 || yNormalized > 1) {
      model.selectedGaussian = -1;
      model.dragAction = null;
    } else {
      var newSelected = findGaussian(xNormalized, model.gaussians);
      if (newSelected !== model.selectedGaussian) {
        model.selectedGaussian = newSelected;
        publicAPI.modified();
      }
    }
    return true;
  };
  publicAPI.onHover = function(x, y) {
    var tolerance = 20 / model.canvas.height;
    var _normalizeCoordinates3 = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null), _normalizeCoordinates4 = _slicedToArray(_normalizeCoordinates3, 2), xNormalized = _normalizeCoordinates4[0], yNormalized = _normalizeCoordinates4[1];
    var _normalizeCoordinates5 = normalizeCoordinates(x, y, model.graphArea), _normalizeCoordinates6 = _slicedToArray(_normalizeCoordinates5, 1), xNormalizedAbs = _normalizeCoordinates6[0];
    var newActive = xNormalized < 0 ? model.selectedGaussian : findGaussian(xNormalized, model.gaussians);
    model.canvas.style.cursor = "default";
    var gaussian = model.gaussians[newActive];
    if (model.enableRangeZoom && xNormalizedAbs >= 0 && y < model.graphArea[1] - 6) {
      var thirdDelta = (model.rangeZoom[1] - model.rangeZoom[0]) / 3;
      if (xNormalizedAbs < model.rangeZoom[0] + thirdDelta || xNormalizedAbs > model.rangeZoom[1] - thirdDelta) {
        model.canvas.style.cursor = ACTION_TO_CURSOR.adjustZoom;
      } else {
        model.canvas.style.cursor = ACTION_TO_CURSOR.adjustPosition;
      }
      model.dragAction = {
        rangeZoom: model.rangeZoom,
        action: ACTIONS.adjustZoom
      };
    } else if (gaussian && xNormalizedAbs >= 0) {
      var invY = 1 - yNormalized;
      var actionName = null;
      if (invY > gaussian.height + tolerance) {
        actionName = "adjustPosition";
      } else if (invY > gaussian.height - tolerance) {
        if (Math.abs(xNormalized - gaussian.position) < tolerance) {
          actionName = "adjustHeight";
        } else {
          actionName = "adjustPosition";
        }
      } else if (invY > gaussian.height * 0.5 + tolerance) {
        actionName = "adjustPosition";
      } else if (invY > gaussian.height * 0.5 - tolerance) {
        if (Math.abs(xNormalized - gaussian.position) < tolerance) {
          actionName = "adjustBias";
        } else {
          actionName = "adjustPosition";
        }
      } else if (invY > tolerance) {
        actionName = "adjustPosition";
      } else {
        actionName = "adjustWidth";
      }
      model.canvas.style.cursor = ACTION_TO_CURSOR[actionName];
      var action = ACTIONS[actionName];
      var originalGaussian = _objectSpread({}, gaussian);
      model.dragAction = {
        originalXY: [xNormalized, yNormalized],
        action,
        gaussian,
        originalGaussian
      };
    }
    if (newActive !== model.activeGaussian) {
      model.activeGaussian = newActive;
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.onDown = function(x, y) {
    if (!model.mouseIsDown) {
      publicAPI.invokeAnimation(true);
    }
    model.mouseIsDown = true;
    var xNormalized = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null)[0];
    var newSelected = findGaussian(xNormalized, model.gaussians);
    model.gaussianSide = 0;
    var gaussian = model.gaussians[newSelected];
    if (gaussian) {
      model.gaussianSide = gaussian.position - xNormalized;
    }
    if (newSelected !== model.selectedGaussian && xNormalized > 0) {
      model.selectedGaussian = newSelected;
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.onDrag = function(x, y) {
    if (model.dragAction) {
      var _normalizeCoordinates7 = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null), _normalizeCoordinates8 = _slicedToArray(_normalizeCoordinates7, 2), xNormalized = _normalizeCoordinates8[0], yNormalized = _normalizeCoordinates8[1];
      var action = model.dragAction.action;
      if (action(xNormalized, yNormalized, _objectSpread({
        gaussianSide: model.gaussianSide,
        model,
        publicAPI
      }, model.dragAction))) {
        model.opacities = computeOpacities(model.gaussians, model.piecewiseSize);
        publicAPI.invokeOpacityChange(publicAPI, true);
      }
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.onUp = function(x, y) {
    if (model.mouseIsDown) {
      publicAPI.invokeAnimation(false);
    }
    model.mouseIsDown = false;
    return true;
  };
  publicAPI.onLeave = function(x, y) {
    publicAPI.onUp(x, y);
    model.canvas.style.cursor = "default";
    model.activeGaussian = -1;
    publicAPI.modified();
    return true;
  };
  publicAPI.onAddGaussian = function(x, y) {
    var _normalizeCoordinates9 = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null), _normalizeCoordinates10 = _slicedToArray(_normalizeCoordinates9, 2), xNormalized = _normalizeCoordinates10[0], yNormalized = _normalizeCoordinates10[1];
    if (xNormalized >= 0) {
      publicAPI.addGaussian(xNormalized, 1 - yNormalized, 0.1, 0, 0);
    }
    return true;
  };
  publicAPI.onRemoveGaussian = function(x, y) {
    var xNormalized = normalizeCoordinates(x, y, model.graphArea, model.enableRangeZoom ? model.rangeZoom : null)[0];
    var newSelected = findGaussian(xNormalized, model.gaussians);
    if (xNormalized >= 0 && newSelected !== -1) {
      publicAPI.removeGaussian(newSelected);
    }
    return true;
  };
  publicAPI.bindMouseListeners = function() {
    if (!model.listeners) {
      var isDown = function isDown2() {
        return !!model.mouseIsDown;
      };
      var touchId = createTouchClickListener({
        clicks: 1,
        touches: 1,
        action: publicAPI.onClick
      }, {
        clicks: 2,
        touches: 1,
        action: publicAPI.onAddGaussian
      }, {
        clicks: 2,
        touches: 2,
        action: publicAPI.onRemoveGaussian
      });
      model.listeners = {
        mousemove: listenerSelector(isDown, createListener(publicAPI.onDrag), createListener(publicAPI.onHover)),
        dblclick: createListener(publicAPI.onAddGaussian),
        contextmenu: createListener(publicAPI.onRemoveGaussian),
        click: createListener(publicAPI.onClick),
        mouseup: createListener(publicAPI.onUp),
        mousedown: createListener(publicAPI.onDown),
        mouseout: createListener(publicAPI.onLeave),
        touchstart: createTouchListener(touchId, macro.chain(publicAPI.onHover, publicAPI.onDown)),
        touchmove: listenerSelector(isDown, createTouchListener(touchId, publicAPI.onDrag), createTouchListener(touchId, publicAPI.onHover)),
        touchend: createTouchListener(touchId, publicAPI.onUp, 0)
      };
      Object.keys(model.listeners).forEach(function(eventType) {
        model.canvas.addEventListener(eventType, model.listeners[eventType], false);
      });
    }
  };
  publicAPI.unbindMouseListeners = function() {
    if (model.listeners) {
      Object.keys(model.listeners).forEach(function(eventType) {
        model.canvas.removeEventListener(eventType, model.listeners[eventType]);
      });
      delete model.listeners;
    }
  };
  publicAPI.render = function() {
    var ctx = model.canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    var _model$size = _slicedToArray(model.size, 2), width = _model$size[0], height = _model$size[1];
    var offset = model.style.padding;
    var graphArea = [Math.floor(model.style.iconSize + offset), Math.floor(offset), Math.ceil(width - 2 * offset - model.style.iconSize), Math.ceil(height - 2 * offset)];
    var zoomControlHeight = model.style.zoomControlHeight;
    if (model.enableRangeZoom) {
      graphArea[1] += Math.floor(zoomControlHeight);
      graphArea[3] -= Math.floor(zoomControlHeight);
    }
    model.graphArea = graphArea;
    ctx.clearRect(0, 0, width, height);
    ctx.lineJoin = "round";
    ctx.fillStyle = model.style.backgroundColor;
    ctx.fillRect.apply(ctx, graphArea);
    if (model.style.iconSize > 1) {
      var halfSize = Math.round(model.style.iconSize / 2 - model.style.strokeWidth);
      var center = Math.round(halfSize + offset + model.style.strokeWidth);
      ctx.beginPath();
      ctx.lineWidth = model.style.buttonStrokeWidth;
      ctx.strokeStyle = model.style.buttonStrokeColor;
      ctx.arc(center - offset / 2, center, halfSize, 0, 2 * Math.PI, false);
      ctx.fillStyle = model.style.buttonFillColor;
      ctx.fill();
      ctx.stroke();
      ctx.moveTo(center - halfSize + model.style.strokeWidth + 2 - offset / 2, center);
      ctx.lineTo(center + halfSize - model.style.strokeWidth - 2 - offset / 2, center);
      ctx.stroke();
      ctx.moveTo(center - offset / 2, center - halfSize + model.style.strokeWidth + 2);
      ctx.lineTo(center - offset / 2, center + halfSize - model.style.strokeWidth - 2);
      ctx.stroke();
      if (model.selectedGaussian === -1) {
        ctx.fillStyle = model.style.buttonDisableFillColor;
        ctx.lineWidth = model.style.buttonDisableStrokeWidth;
        ctx.strokeStyle = model.style.buttonDisableStrokeColor;
      } else {
        ctx.fillStyle = model.style.buttonFillColor;
        ctx.lineWidth = model.style.buttonStrokeWidth;
        ctx.strokeStyle = model.style.buttonStrokeColor;
      }
      ctx.beginPath();
      ctx.arc(center - offset / 2, center + offset / 2 + model.style.iconSize, halfSize, 0, 2 * Math.PI, false);
      ctx.fill();
      ctx.stroke();
      ctx.moveTo(center - halfSize + model.style.strokeWidth + 2 - offset / 2, center + offset / 2 + model.style.iconSize);
      ctx.lineTo(center + halfSize - model.style.strokeWidth - 2 - offset / 2, center + offset / 2 + model.style.iconSize);
      ctx.stroke();
    }
    if (model.histogram) {
      drawChart(ctx, graphArea, rescaleArray(model.histogram, model.rangeZoom), {
        lineWidth: 1,
        strokeStyle: model.style.histogramColor,
        fillStyle: model.style.histogramColor
      });
    }
    drawChart(ctx, graphArea, rescaleArray(model.opacities, model.enableRangeZoom && model.rangeZoom), {
      lineWidth: model.style.strokeWidth,
      strokeStyle: model.style.strokeColor
    });
    if (model.colorTransferFunction && model.colorTransferFunction.getSize()) {
      var rangeToUse = model.dataRange || model.colorTransferFunction.getMappingRange();
      if (!model.colorCanvas || model.colorCanvasMTime !== model.colorTransferFunction.getMTime()) {
        model.colorCanvasMTime = model.colorTransferFunction.getMTime();
        model.colorCanvas = updateColorCanvas(model.colorTransferFunction, graphArea[2], rangeToUse, model.colorCanvas);
      }
      ctx.save();
      drawChart(ctx, graphArea, rescaleArray(model.opacities, model.enableRangeZoom && model.rangeZoom), {
        lineWidth: 1,
        strokeStyle: "rgba(0,0,0,0)",
        fillStyle: "rgba(0,0,0,1)",
        clip: true
      });
      if (model.enableRangeZoom) {
        ctx.drawImage(model.colorCanvas, model.rangeZoom[0] * graphArea[2], 0, graphArea[2], graphArea[3], graphArea[0], graphArea[1], graphArea[2] / (model.rangeZoom[1] - model.rangeZoom[0]), graphArea[3]);
      } else {
        ctx.drawImage(model.colorCanvas, graphArea[0], graphArea[1]);
      }
      ctx.restore();
    } else if (model.backgroundImage) {
      model.colorCanvas = updateColorCanvasFromImage(model.backgroundImage, graphArea[2], model.colorCanvas);
      ctx.save();
      drawChart(ctx, graphArea, rescaleArray(model.opacities, model.enableRangeZoom && model.rangeZoom), {
        lineWidth: 1,
        strokeStyle: "rgba(0,0,0,0)",
        fillStyle: "rgba(0,0,0,1)",
        clip: true
      });
      ctx.drawImage(model.colorCanvas, graphArea[0], graphArea[1]);
      ctx.restore();
    }
    if (model.enableRangeZoom) {
      ctx.fillStyle = model.style.zoomControlColor;
      ctx.beginPath();
      ctx.rect(graphArea[0] + model.rangeZoom[0] * graphArea[2], 0, (model.rangeZoom[1] - model.rangeZoom[0]) * graphArea[2], zoomControlHeight);
      ctx.fill();
    }
    var activeGaussian = model.gaussians[model.activeGaussian] || model.gaussians[model.selectedGaussian];
    if (activeGaussian) {
      var activeOpacities = computeOpacities([activeGaussian], graphArea[2]);
      drawChart(ctx, graphArea, rescaleArray(activeOpacities, model.enableRangeZoom && model.rangeZoom), {
        lineWidth: model.style.activeStrokeWidth,
        strokeStyle: model.style.activeColor
      });
      var xCenter = graphArea[0] + rescaleValue(activeGaussian.position, model.enableRangeZoom && model.rangeZoom) * graphArea[2];
      var yTop = graphArea[1] + (1 - activeGaussian.height) * graphArea[3];
      var yMiddle = graphArea[1] + (1 - 0.5 * activeGaussian.height) * graphArea[3];
      var yBottom = graphArea[1] + graphArea[3];
      var widthInPixel = activeGaussian.width * graphArea[2];
      if (model.enableRangeZoom) {
        widthInPixel /= model.rangeZoom[1] - model.rangeZoom[0];
      }
      ctx.lineWidth = model.style.handleWidth;
      ctx.strokeStyle = model.style.handleColor;
      ctx.fillStyle = model.style.backgroundColor;
      ctx.beginPath();
      ctx.moveTo(xCenter, graphArea[1] + (1 - activeGaussian.height) * graphArea[3]);
      ctx.lineTo(xCenter, graphArea[1] + graphArea[3]);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(xCenter, yTop, 6, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
      var radius = Math.min(widthInPixel * 0.1, activeGaussian.height * graphArea[3] * 0.2);
      ctx.beginPath();
      ctx.rect(xCenter - radius, yMiddle - radius, radius * 2, radius * 2);
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      var sliderWidth = widthInPixel * 0.8;
      ctx.rect(xCenter - sliderWidth, yBottom - 5, 2 * sliderWidth, 10);
      ctx.fill();
      ctx.stroke();
    }
  };
  publicAPI.getOpacityNodes = function(dataRange) {
    var rangeToUse = dataRange || model.dataRange;
    var delta = (rangeToUse[1] - rangeToUse[0]) / (model.opacities.length - 1);
    var nodes = [];
    var midpoint = 0.5;
    var sharpness = 0;
    for (var index = 0; index < model.opacities.length; index++) {
      var x = rangeToUse[0] + delta * index;
      var y = model.opacities[index];
      nodes.push({
        x,
        y,
        midpoint,
        sharpness
      });
    }
    return nodes;
  };
  publicAPI.applyOpacity = function(piecewiseFunction, dataRange) {
    var nodes = publicAPI.getOpacityNodes(dataRange);
    piecewiseFunction.setNodes(nodes);
  };
  publicAPI.getOpacityRange = function(dataRange) {
    var rangeToUse = dataRange || model.dataRange;
    var delta = (rangeToUse[1] - rangeToUse[0]) / (model.opacities.length - 1);
    var minIndex = model.opacities.length - 1;
    var maxIndex = 0;
    for (var index = 0; index < model.opacities.length; index++) {
      if (model.opacities[index] > 0) {
        minIndex = Math.min(minIndex, index);
      }
      if (model.opacities[index] > 0) {
        maxIndex = Math.max(maxIndex, index);
      }
    }
    return [rangeToUse[0] + minIndex * delta, rangeToUse[0] + maxIndex * delta];
  };
  var enableZoom = publicAPI.setEnableRangeZoom;
  publicAPI.setEnableRangeZoom = function(v) {
    var change = enableZoom(v);
    if (change) {
      model.colorCanvasMTime = 0;
      model.rangeZoom = [0, 1];
    }
    return change;
  };
  var rangeZoom = publicAPI.setRangeZoom;
  publicAPI.setRangeZoom = function() {
    var change = rangeZoom.apply(void 0, arguments);
    if (change) {
      model.colorCanvasMTime = 0;
    }
    return change;
  };
  publicAPI.onModified(function() {
    return publicAPI.render();
  });
  publicAPI.setSize.apply(publicAPI, _toConsumableArray(model.size));
}
var DEFAULT_VALUES = {
  histogram: [],
  numberOfBins: 256,
  histogramArray: null,
  dataRange: [0, 1],
  gaussians: [],
  opacities: [],
  size: [600, 300],
  piecewiseSize: 256,
  colorCanvasMTime: 0,
  gaussianMinimumHeight: 0.05,
  style: {
    backgroundColor: "rgba(255, 255, 255, 1)",
    histogramColor: "rgba(200, 200, 200, 0.5)",
    strokeColor: "rgb(0, 0, 0)",
    activeColor: "rgb(0, 0, 150)",
    buttonDisableFillColor: "rgba(255, 255, 255, 0.5)",
    buttonDisableStrokeColor: "rgba(0, 0, 0, 0.5)",
    buttonStrokeColor: "rgba(0, 0, 0, 1)",
    buttonFillColor: "rgba(255, 255, 255, 1)",
    handleColor: "rgb(0, 150, 0)",
    strokeWidth: 2,
    activeStrokeWidth: 3,
    buttonStrokeWidth: 1.5,
    handleWidth: 3,
    iconSize: 20,
    padding: 10,
    zoomControlHeight: 10,
    zoomControlColor: "#999"
  },
  activeGaussian: -1,
  selectedGaussian: -1,
  enableRangeZoom: true,
  rangeZoom: [0, 1]
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["piecewiseSize", "numberOfBins", "colorTransferFunction", "backgroundImage", "enableRangeZoom", "gaussianMinimumHeight"]);
  macro.setGetArray(publicAPI, model, ["rangeZoom"], 2);
  macro.get(publicAPI, model, ["size", "canvas", "gaussians"]);
  macro.event(publicAPI, model, "opacityChange");
  macro.event(publicAPI, model, "animation");
  macro.event(publicAPI, model, "zoomChange");
  vtkPiecewiseGaussianWidget(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkPiecewiseGaussianWidget");
var vtkPiecewiseGaussianWidget$1 = _objectSpread({
  newInstance,
  extend
}, STATIC);

// node_modules/@kitware/vtk.js/Interaction/UI/Icons/Logo.svg.js
var svgLogo = '<svg viewBox="0 0 196 196" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M67.77 157.024a86.095 86.095 0 01-2.3 9.306c-.977 3.206-2.44 6.116-4.392 8.73-1.952 2.614-4.531 4.758-7.738 6.43-3.206 1.674-7.284 2.51-12.233 2.51-6.343 0-11.501-1.55-15.474-4.653-3.974-3.102-6.518-7.301-7.633-12.599l16.102-5.228c.279 1.882 1.01 3.485 2.196 4.81 1.185 1.324 2.753 1.986 4.705 1.986 3.067 0 5.262-1.08 6.587-3.24 1.324-2.162 2.265-4.88 2.823-8.156l8.574-48.933h17.565l-8.783 49.037zm58.029-31.053c-1.394-1.883-3.137-3.311-5.228-4.287-2.091-.976-4.426-1.464-7.005-1.464-1.185 0-2.44.157-3.764.47a10.815 10.815 0 00-3.608 1.569 9.806 9.806 0 00-2.718 2.77c-.732 1.116-1.098 2.475-1.098 4.078 0 2.091.819 3.747 2.457 4.967 1.638 1.22 3.921 2.352 6.849 3.398 3.206 1.115 6.064 2.352 8.573 3.712 2.51 1.359 4.636 2.91 6.378 4.652 1.743 1.743 3.067 3.712 3.974 5.908.906 2.196 1.359 4.688 1.359 7.476 0 4.461-.924 8.26-2.77 11.397-1.848 3.136-4.236 5.698-7.163 7.685-2.928 1.986-6.204 3.433-9.829 4.339-3.624.906-7.214 1.359-10.769 1.359-2.649 0-5.298-.244-7.946-.732a42.608 42.608 0 01-7.633-2.143 31.681 31.681 0 01-6.796-3.608c-2.092-1.463-3.869-3.136-5.333-5.018l12.86-10.456c1.465 2.23 3.625 4.043 6.483 5.437 2.858 1.394 5.751 2.091 8.679 2.091 1.533 0 3.014-.157 4.443-.47 1.43-.314 2.701-.837 3.817-1.569a8.267 8.267 0 002.666-2.823c.662-1.15.993-2.527.993-4.13 0-2.579-1.045-4.618-3.136-6.117-2.092-1.498-4.88-2.84-8.365-4.025a58.492 58.492 0 01-6.849-2.823c-2.126-1.046-3.973-2.335-5.541-3.869-1.569-1.533-2.823-3.363-3.764-5.489-.941-2.126-1.412-4.688-1.412-7.685 0-3.764.784-7.162 2.353-10.194a23.324 23.324 0 016.43-7.738c2.719-2.126 5.89-3.764 9.515-4.914 3.624-1.15 7.493-1.725 11.606-1.725 2.16 0 4.356.21 6.587.627a35.853 35.853 0 016.43 1.83 28.502 28.502 0 015.699 2.98c1.742 1.185 3.206 2.544 4.39 4.078L125.8 125.97z" fill="#8A8B8A"/><rect fill="#1C4678" transform="rotate(45 169.749 159.749)" x="152.249" y="142.249" width="35" height="35" rx="17.5"/><path fill="#1C4678" d="M7.775 11l20.483 86.069h22.53l34.24-71.408H63.841L42.91 70.03 28.259 11zM88.663 25.344h50.476l-8.093 16.562-17.246-.049-9.652 54.62H85.609l9.572-54.535H80.99zM141.366 25.344l16.072.066-4.414 24.987h2.388l16.856-25.053h20.975l-22.442 33.403 13.203 54.063h-20.94l-10.652-44.43h-2.296l-5.125 28.135h-21.024l9.763-55.043z"/><path fill="#8A8B8A" d="M3 11h3.182l20.864 85.944h-3.187zM58.102 25.344h2.788L43.747 61.155l-.955-3.866zM88.608 44.469h2.883l-9.157 52.096H79.4zM126.785 44.469h2.924l-9.186 52.046H117.6zM166.38 25.344h3.594l-12.582 18.854 1.316-7.545zM150.902 74.75l8.917 37.613h-3.311l-7.075-29.073z"/></g></svg>';

// node_modules/@kitware/vtk.js/Interaction/UI/Icons/Contrast.svg.js
var svgEdge = '<svg viewBox="0 0 180 180" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient x1="100%" y1="50%" x2="0%" y2="50%" id="a"><stop stop-color="#FFF" offset="0%"/><stop stop-color="#FFF" offset="49.416%"/><stop offset="49.677%"/><stop offset="100%"/></linearGradient></defs><circle cx="90" cy="90" r="80" stroke-width="10" stroke="#000" fill="url(#a)" fill-rule="evenodd"/></svg>';

// node_modules/@kitware/vtk.js/Interaction/UI/Icons/Spacing.svg.js
var svgSpacing = '<svg viewBox="0 0 180 180" xmlns="http://www.w3.org/2000/svg"><g stroke="#000" stroke-width="10" fill="none" fill-rule="evenodd" stroke-linecap="square"><path d="M10 90h160M10 133.488V47M170 133.488V47M90 133.488V47"/></g></svg>';

// node_modules/@kitware/vtk.js/Interaction/UI/VolumeController/VolumeController.module.css.js
var css_248z = ".VolumeController-module_container__2HNSO {\n  display: flex;\n  align-items: stretch;\n  flex-direction: column;\n  justify-content: space-between;\n  position: absolute;\n  top: 5px;\n  left: 5px;\n  background: rgba(128, 128, 128, 0.5);\n  border-radius: 5px;\n  padding: 2px;\n  border: 0.5px solid black;\n  box-sizing: border-box;\n}\n\n.VolumeController-module_line__3rtqL {\n  display: flex;\n  flex-direction: row;\n  flex: 1;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.VolumeController-module_button__2T-xL {\n  cursor: pointer;\n  width: 1rem;\n  margin-left: 5px;\n  margin-right: 5px;\n}\n\n.VolumeController-module_button__2T-xL svg {\n  width: 1rem;\n  height: 1rem;\n}\n\n.VolumeController-module_sliderEntry__27XSC {\n  flex: 1;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n}\n\n.VolumeController-module_sliderIcon__U8YAZ {\n  height: 1rem;\n}\n\n.VolumeController-module_slider__3PS68 {\n  flex: 1;\n  min-height: 1rem;\n  width: 5px;\n}\n\n.VolumeController-module_piecewiseEditor__2_jav {\n  flex: 1;\n}\n\n.VolumeController-module_select__7mbfS {\n  flex: 1;\n  border: none;\n  background: transparent;\n  color: white;\n  border: none;\n  -moz-appearance: none;\n  width: 5px;\n}\n\n.VolumeController-module_select__7mbfS select:focus {\n  outline: none;\n  border: none;\n}\n\n.VolumeController-module_presets__1h4j5 {\n}\n\n.VolumeController-module_shadow__29K9t {\n}\n\n.VolumeController-module_buttonDarkBG__3W1zO {\n}\n\n.VolumeController-module_presetsDarkBG__2ZI2W {\n  color: white;\n}\n\n.VolumeController-module_presetsDarkBG__2ZI2W option {\n  color: black;\n}\n\n.VolumeController-module_shadowDarkBG__WHYZ- {\n  color: white;\n}\n\n.VolumeController-module_shadowDarkBG__WHYZ- option {\n  color: black;\n}\n\n.VolumeController-module_buttonBrightBG__2dstz {\n}\n\n.VolumeController-module_presetsBrightBG__3_VRC {\n  color: black;\n}\n\n.VolumeController-module_presetsBrightBG__3_VRC option {\n  color: white;\n}\n\n.VolumeController-module_shadowBrightBG__YCHpe {\n  color: black;\n}\n\n.VolumeController-module_shadowBrightBG__YCHpe option {\n  color: white;\n}\n";
var style = { "container": "VolumeController-module_container__2HNSO", "line": "VolumeController-module_line__3rtqL", "button": "VolumeController-module_button__2T-xL", "sliderEntry": "VolumeController-module_sliderEntry__27XSC", "sliderIcon": "VolumeController-module_sliderIcon__U8YAZ VolumeController-module_button__2T-xL", "slider": "VolumeController-module_slider__3PS68", "piecewiseEditor": "VolumeController-module_piecewiseEditor__2_jav", "select": "VolumeController-module_select__7mbfS", "presets": "VolumeController-module_presets__1h4j5 VolumeController-module_select__7mbfS", "shadow": "VolumeController-module_shadow__29K9t VolumeController-module_select__7mbfS", "buttonDarkBG": "VolumeController-module_buttonDarkBG__3W1zO VolumeController-module_button__2T-xL", "presetsDarkBG": "VolumeController-module_presetsDarkBG__2ZI2W VolumeController-module_presets__1h4j5 VolumeController-module_select__7mbfS", "shadowDarkBG": "VolumeController-module_shadowDarkBG__WHYZ- VolumeController-module_shadow__29K9t VolumeController-module_select__7mbfS", "buttonBrightBG": "VolumeController-module_buttonBrightBG__2dstz VolumeController-module_button__2T-xL", "presetsBrightBG": "VolumeController-module_presetsBrightBG__3_VRC VolumeController-module_presets__1h4j5 VolumeController-module_select__7mbfS", "shadowBrightBG": "VolumeController-module_shadowBrightBG__YCHpe VolumeController-module_shadow__29K9t VolumeController-module_select__7mbfS" };
styleInject(css_248z);

// node_modules/@kitware/vtk.js/Interaction/UI/VolumeController.js
var PRESETS_OPTIONS = vtkColorMaps2.rgbPresetNames.map(function(name) {
  return '<option value="'.concat(name, '">').concat(name, "</option>");
});
function vtkVolumeController(publicAPI, model) {
  model.classHierarchy.push("vtkVolumeController");
  model.el = document.createElement("div");
  model.el.setAttribute("class", style.container);
  model.widget = vtkPiecewiseGaussianWidget$1.newInstance({
    numberOfBins: 256,
    size: model.size
  });
  function updateUseShadow() {
    var useShadow = !!Number(model.el.querySelector(".js-shadow").value);
    model.actor.getProperty().setShade(useShadow);
    model.renderWindow.render();
  }
  function updateColorMapPreset() {
    var sourceDS = model.actor.getMapper().getInputData();
    if (!sourceDS) {
      return;
    }
    var dataArray = sourceDS.getPointData().getScalars() || sourceDS.getPointData().getArrays()[0];
    var dataRange = model.rescaleColorMap ? model.colorDataRange : dataArray.getRange();
    var preset = vtkColorMaps2.getPresetByName(model.el.querySelector(".js-color-preset").value);
    var lookupTable = model.actor.getProperty().getRGBTransferFunction(0);
    lookupTable.applyColorMap(preset);
    lookupTable.setMappingRange.apply(lookupTable, _toConsumableArray(dataRange));
    lookupTable.updateRange();
    model.renderWindow.render();
  }
  function updateSpacing() {
    var value = Number(model.el.querySelector(".js-spacing").value);
    var sourceDS = model.actor.getMapper().getInputData();
    var sampleDistance = 0.7 * Math.sqrt(sourceDS.getSpacing().map(function(v) {
      return v * v;
    }).reduce(function(a, b) {
      return a + b;
    }, 0));
    model.actor.getMapper().setSampleDistance(sampleDistance * Math.pow(2, value * 3 - 1.5));
    model.renderWindow.render();
  }
  function updateEdgeGradient() {
    var value = Number(model.el.querySelector(".js-edge").value);
    if (value === 0) {
      model.actor.getProperty().setUseGradientOpacity(0, false);
    } else {
      var sourceDS = model.actor.getMapper().getInputData();
      var dataArray = sourceDS.getPointData().getScalars() || sourceDS.getPointData().getArrays()[0];
      var dataRange = dataArray.getRange();
      model.actor.getProperty().setUseGradientOpacity(0, true);
      var minV = Math.max(0, value - 0.3) / 0.7;
      model.actor.getProperty().setGradientOpacityMinimumValue(0, (dataRange[1] - dataRange[0]) * 0.2 * minV * minV);
      model.actor.getProperty().setGradientOpacityMaximumValue(0, (dataRange[1] - dataRange[0]) * 1 * value * value);
    }
    model.renderWindow.render();
  }
  publicAPI.setupContent = function(renderWindow, actor, isBackgroundDark) {
    var useShadow = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "1";
    var presetName = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "erdc_rainbow_bright";
    publicAPI.setActor(actor);
    publicAPI.setRenderWindow(renderWindow);
    var sourceDS = model.actor.getMapper().getInputData();
    var dataArray = sourceDS.getPointData().getScalars() || sourceDS.getPointData().getArrays()[0];
    var lookupTable = model.actor.getProperty().getRGBTransferFunction(0);
    var piecewiseFunction = model.actor.getProperty().getScalarOpacity(0);
    var stylePostFix = isBackgroundDark ? "DarkBG" : "BrightBG";
    var localStyle = {};
    ["button", "presets", "shadow"].forEach(function(name) {
      localStyle[name] = style["".concat(name).concat(stylePostFix)];
    });
    model.el.innerHTML = '\n      <div class="'.concat(style.line, '">\n        <div class="').concat(localStyle.button, ' js-button">').concat(svgLogo, '</div>\n        <select class="').concat(localStyle.shadow, ' js-shadow js-toggle">\n          <option value="1">Use Shadow</option>\n          <option value="0">No Shadow</option>\n        </select>\n        <select class="').concat(localStyle.presets, ' js-color-preset js-toggle">\n          ').concat(PRESETS_OPTIONS, '\n        </select>\n      </div>\n      <div class="').concat(style.line, ' js-toggle">\n        <div class="').concat(style.sliderEntry, '">\n          <div class="').concat(style.sliderIcon, '">').concat(svgSpacing, '</div>\n          <input type="range" min="0" max="1" value="0.4" step="0.01" class="').concat(style.slider, ' js-spacing" />\n        </div>\n        <div class="').concat(style.sliderEntry, '">\n          <div class="').concat(style.sliderIcon, '">').concat(svgEdge, '</div>\n          <input type="range" min="0" max="1" value="0.2" step="0.01" class="').concat(style.slider, ' js-edge" />\n        </div>\n      </div>\n      <div class="').concat(style.piecewiseEditor, ' js-pwf js-toggle"></div>\n    ');
    var domToggleButton = model.el.querySelector(".js-button");
    var domShadow = model.el.querySelector(".js-shadow");
    var domPreset = model.el.querySelector(".js-color-preset");
    var domSpacing = model.el.querySelector(".js-spacing");
    var domEdge = model.el.querySelector(".js-edge");
    var widgetContainer = model.el.querySelector(".js-pwf");
    model.widget.updateStyle({
      backgroundColor: "rgba(255, 255, 255, 0.6)",
      histogramColor: "rgba(100, 100, 100, 0.5)",
      strokeColor: "rgb(0, 0, 0)",
      activeColor: "rgb(255, 255, 255)",
      handleColor: "rgb(50, 150, 50)",
      buttonDisableFillColor: "rgba(255, 255, 255, 0.5)",
      buttonDisableStrokeColor: "rgba(0, 0, 0, 0.5)",
      buttonStrokeColor: "rgba(0, 0, 0, 1)",
      buttonFillColor: "rgba(255, 255, 255, 1)",
      strokeWidth: 2,
      activeStrokeWidth: 3,
      buttonStrokeWidth: 1.5,
      handleWidth: 3,
      iconSize: 0,
      padding: 10
    });
    model.widget.addGaussian(0.5, 1, 0.5, 0.5, 0.4);
    model.widget.setDataArray(dataArray.getData());
    model.widget.setColorTransferFunction(lookupTable);
    model.widget.applyOpacity(piecewiseFunction);
    model.widget.setContainer(widgetContainer);
    model.widget.bindMouseListeners();
    model.colorDataRange = model.widget.getOpacityRange();
    domToggleButton.addEventListener("click", publicAPI.toggleVisibility);
    domShadow.addEventListener("change", updateUseShadow);
    domPreset.addEventListener("change", updateColorMapPreset);
    domSpacing.addEventListener("input", updateSpacing);
    domEdge.addEventListener("input", updateEdgeGradient);
    model.widget.onOpacityChange(function() {
      model.widget.applyOpacity(piecewiseFunction);
      model.colorDataRange = model.widget.getOpacityRange();
      if (model.rescaleColorMap) {
        updateColorMapPreset();
      }
      if (!model.renderWindow.getInteractor().isAnimating()) {
        model.renderWindow.render();
      }
    });
    model.widget.onAnimation(function(start) {
      if (start) {
        model.renderWindow.getInteractor().requestAnimation(model.widget);
      } else {
        model.renderWindow.getInteractor().cancelAnimation(model.widget);
        model.renderWindow.render();
      }
    });
    lookupTable.onModified(function() {
      model.widget.render();
      if (!model.renderWindow.getInteractor().isAnimating()) {
        model.renderWindow.render();
      }
    });
    domShadow.value = Number(useShadow) ? "1" : "0";
    domPreset.value = presetName;
    updateUseShadow();
    updateColorMapPreset();
    updateSpacing();
    updateEdgeGradient();
  };
  publicAPI.setContainer = function(el) {
    if (model.container && model.container !== el) {
      model.container.removeChild(model.el);
    }
    if (model.container !== el) {
      model.container = el;
      if (model.container) {
        model.container.appendChild(model.el);
      }
      publicAPI.modified();
    }
  };
  var rescaleColorMap = publicAPI.setRescaleColorMap;
  publicAPI.setRescaleColorMap = function(value) {
    if (rescaleColorMap(value)) {
      updateColorMapPreset();
      return true;
    }
    return false;
  };
  publicAPI.toggleVisibility = function() {
    publicAPI.setExpanded(!publicAPI.getExpanded());
  };
  publicAPI.setExpanded = function(expanded) {
    var elements = model.el.querySelectorAll(".js-toggle");
    var count = elements.length;
    model.expanded = expanded;
    if (model.expanded) {
      while (count--) {
        elements[count].style.display = "flex";
      }
    } else {
      while (count--) {
        elements[count].style.display = "none";
      }
    }
  };
  publicAPI.getExpanded = function() {
    return model.expanded;
  };
  publicAPI.setSize = model.widget.setSize;
  publicAPI.render = model.widget.render;
  publicAPI.onAnimation = model.widget.onAnimation;
  publicAPI.onModified(publicAPI.render);
  publicAPI.setSize.apply(publicAPI, _toConsumableArray(model.size));
}
var DEFAULT_VALUES2 = {
  size: [600, 300],
  expanded: true,
  rescaleColorMap: false
};
function extend2(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["actor", "renderWindow", "rescaleColorMap"]);
  macro.get(publicAPI, model, ["widget"]);
  vtkVolumeController(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend2, "vtkVolumeController");
var vtkVolumeController$1 = {
  newInstance: newInstance2,
  extend: extend2
};

// dep:@kitware_vtk__js_Interaction_UI_VolumeController
var kitware_vtk_js_Interaction_UI_VolumeController_default = vtkVolumeController$1;
export {
  kitware_vtk_js_Interaction_UI_VolumeController_default as default,
  extend2 as extend,
  newInstance2 as newInstance
};
//# sourceMappingURL=@kitware_vtk__js_Interaction_UI_VolumeController.js.map
