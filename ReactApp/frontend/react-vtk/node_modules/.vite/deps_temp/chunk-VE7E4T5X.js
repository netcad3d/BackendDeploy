import {
  Device,
  Input,
  vtkRenderWindowInteractor$1
} from "./chunk-QYAAEY2I.js";
import {
  degreesFromRadians
} from "./chunk-FOWOP5PK.js";
import {
  macro
} from "./chunk-OTTIIP4A.js";
import {
  _defineProperty
} from "./chunk-HKWV5KNA.js";

// node_modules/@kitware/vtk.js/Rendering/Core/InteractorObserver.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var vtkErrorMacro = macro.vtkErrorMacro;
var VOID = macro.VOID;
function computeWorldToDisplay(renderer, x, y, z) {
  var view = renderer.getRenderWindow().getViews()[0];
  return view.worldToDisplay(x, y, z, renderer);
}
function computeDisplayToWorld(renderer, x, y, z) {
  var view = renderer.getRenderWindow().getViews()[0];
  return view.displayToWorld(x, y, z, renderer);
}
var STATIC = {
  computeWorldToDisplay,
  computeDisplayToWorld
};
function vtkInteractorObserver(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorObserver");
  var superClass = _objectSpread({}, publicAPI);
  function unsubscribeFromEvents() {
    while (model.subscribedEvents.length) {
      model.subscribedEvents.pop().unsubscribe();
    }
  }
  function subscribeToEvents() {
    vtkRenderWindowInteractor$1.handledEvents.forEach(function(eventName) {
      if (publicAPI["handle".concat(eventName)]) {
        model.subscribedEvents.push(model._interactor["on".concat(eventName)](function(callData) {
          if (model.processEvents) {
            return publicAPI["handle".concat(eventName)](callData);
          }
          return VOID;
        }, model.priority));
      }
    });
  }
  publicAPI.setInteractor = function(i) {
    if (i === model._interactor) {
      return;
    }
    unsubscribeFromEvents();
    model._interactor = i;
    if (i && model.enabled) {
      subscribeToEvents();
    }
    publicAPI.modified();
  };
  publicAPI.setEnabled = function(enable) {
    if (enable === model.enabled) {
      return;
    }
    unsubscribeFromEvents();
    if (enable) {
      if (model._interactor) {
        subscribeToEvents();
      } else {
        vtkErrorMacro("\n          The interactor must be set before subscribing to events\n        ");
      }
    }
    model.enabled = enable;
    publicAPI.modified();
  };
  publicAPI.computeDisplayToWorld = function(renderer, x, y, z) {
    if (!renderer) {
      return null;
    }
    return model._interactor.getView().displayToWorld(x, y, z, renderer);
  };
  publicAPI.computeWorldToDisplay = function(renderer, x, y, z) {
    if (!renderer) {
      return null;
    }
    return model._interactor.getView().worldToDisplay(x, y, z, renderer);
  };
  publicAPI.setPriority = function(priority) {
    var modified = superClass.setPriority(priority);
    if (modified && model._interactor) {
      unsubscribeFromEvents();
      subscribeToEvents();
    }
  };
}
var DEFAULT_VALUES = {
  enabled: true,
  priority: 0,
  processEvents: true,
  subscribedEvents: []
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "InteractionEvent");
  macro.event(publicAPI, model, "StartInteractionEvent");
  macro.event(publicAPI, model, "EndInteractionEvent");
  macro.get(publicAPI, model, ["_interactor", "enabled"]);
  macro.setGet(publicAPI, model, ["priority", "processEvents"]);
  macro.moveToProtected(publicAPI, model, ["interactor"]);
  vtkInteractorObserver(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkInteractorObserver");
var vtkInteractorObserver$1 = _objectSpread({
  newInstance,
  extend
}, STATIC);

// node_modules/@kitware/vtk.js/Rendering/Core/InteractorStyle/Constants.js
var States = {
  IS_START: 0,
  IS_NONE: 0,
  IS_ROTATE: 1,
  IS_PAN: 2,
  IS_SPIN: 3,
  IS_DOLLY: 4,
  IS_CAMERA_POSE: 11,
  IS_WINDOW_LEVEL: 1024,
  IS_SLICE: 1025
};
var vtkInteractorStyleConstants = {
  States
};

// node_modules/@kitware/vtk.js/Rendering/Core/InteractorStyle.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var States2 = vtkInteractorStyleConstants.States;
var stateNames = {
  Rotate: States2.IS_ROTATE,
  Pan: States2.IS_PAN,
  Spin: States2.IS_SPIN,
  Dolly: States2.IS_DOLLY,
  CameraPose: States2.IS_CAMERA_POSE,
  WindowLevel: States2.IS_WINDOW_LEVEL,
  Slice: States2.IS_SLICE
};
function vtkInteractorStyle(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorStyle");
  Object.keys(stateNames).forEach(function(key) {
    macro.event(publicAPI, model, "Start".concat(key, "Event"));
    publicAPI["start".concat(key)] = function() {
      if (model.state !== States2.IS_NONE) {
        return;
      }
      model.state = stateNames[key];
      model._interactor.requestAnimation(publicAPI);
      publicAPI.invokeStartInteractionEvent({
        type: "StartInteractionEvent"
      });
      publicAPI["invokeStart".concat(key, "Event")]({
        type: "Start".concat(key, "Event")
      });
    };
    macro.event(publicAPI, model, "End".concat(key, "Event"));
    publicAPI["end".concat(key)] = function() {
      if (model.state !== stateNames[key]) {
        return;
      }
      model.state = States2.IS_NONE;
      model._interactor.cancelAnimation(publicAPI);
      publicAPI.invokeEndInteractionEvent({
        type: "EndInteractionEvent"
      });
      publicAPI["invokeEnd".concat(key, "Event")]({
        type: "End".concat(key, "Event")
      });
      model._interactor.render();
    };
  });
  publicAPI.handleKeyPress = function(callData) {
    var rwi = model._interactor;
    var ac = null;
    switch (callData.key) {
      case "r":
      case "R":
        callData.pokedRenderer.resetCamera();
        rwi.render();
        break;
      case "w":
      case "W":
        ac = callData.pokedRenderer.getActors();
        ac.forEach(function(anActor) {
          var prop = anActor.getProperty();
          if (prop.setRepresentationToWireframe) {
            prop.setRepresentationToWireframe();
          }
        });
        rwi.render();
        break;
      case "s":
      case "S":
        ac = callData.pokedRenderer.getActors();
        ac.forEach(function(anActor) {
          var prop = anActor.getProperty();
          if (prop.setRepresentationToSurface) {
            prop.setRepresentationToSurface();
          }
        });
        rwi.render();
        break;
      case "v":
      case "V":
        ac = callData.pokedRenderer.getActors();
        ac.forEach(function(anActor) {
          var prop = anActor.getProperty();
          if (prop.setRepresentationToPoints) {
            prop.setRepresentationToPoints();
          }
        });
        rwi.render();
        break;
    }
  };
}
var DEFAULT_VALUES2 = {
  state: States2.IS_NONE,
  handleObservers: 1,
  autoAdjustCameraClippingRange: 1
};
function extend2(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  vtkInteractorObserver$1.extend(publicAPI, model, initialValues);
  vtkInteractorStyle(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend2, "vtkInteractorStyle");
var vtkInteractorStyle$1 = _objectSpread2({
  newInstance: newInstance2,
  extend: extend2
}, vtkInteractorStyleConstants);

// node_modules/@kitware/vtk.js/Interaction/Style/InteractorStyleTrackballCamera.js
var States3 = vtkInteractorStyleConstants.States;
function vtkInteractorStyleTrackballCamera(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorStyleTrackballCamera");
  publicAPI.handleMouseMove = function(callData) {
    var pos = callData.position;
    var renderer = callData.pokedRenderer;
    switch (model.state) {
      case States3.IS_ROTATE:
        publicAPI.handleMouseRotate(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
      case States3.IS_PAN:
        publicAPI.handleMousePan(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
      case States3.IS_DOLLY:
        publicAPI.handleMouseDolly(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
      case States3.IS_SPIN:
        publicAPI.handleMouseSpin(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
    }
    model.previousPosition = pos;
  };
  publicAPI.handleButton3D = function(ed) {
    if (ed && ed.pressed && ed.device === Device.RightController && (ed.input === Input.Trigger || ed.input === Input.TrackPad)) {
      publicAPI.startCameraPose();
      return;
    }
    if (ed && !ed.pressed && ed.device === Device.RightController && (ed.input === Input.Trigger || ed.input === Input.TrackPad) && model.state === States3.IS_CAMERA_POSE) {
      publicAPI.endCameraPose();
    }
  };
  publicAPI.handleMove3D = function(ed) {
    switch (model.state) {
      case States3.IS_CAMERA_POSE:
        publicAPI.updateCameraPose(ed);
        break;
    }
  };
  publicAPI.updateCameraPose = function(ed) {
    var camera = ed.pokedRenderer.getActiveCamera();
    var oldTrans = camera.getPhysicalTranslation();
    var speed = 0.5;
    var pscale = speed * 0.05 * camera.getPhysicalScale();
    var dir = camera.physicalOrientationToWorldDirection([ed.orientation.x, ed.orientation.y, ed.orientation.z, ed.orientation.w]);
    camera.setPhysicalTranslation(oldTrans[0] + dir[0] * pscale, oldTrans[1] + dir[1] * pscale, oldTrans[2] + dir[2] * pscale);
  };
  publicAPI.handleLeftButtonPress = function(callData) {
    var pos = callData.position;
    model.previousPosition = pos;
    if (callData.shiftKey) {
      if (callData.controlKey || callData.altKey) {
        publicAPI.startDolly();
      } else {
        publicAPI.startPan();
      }
    } else {
      if (callData.controlKey || callData.altKey) {
        publicAPI.startSpin();
      } else {
        publicAPI.startRotate();
      }
    }
  };
  publicAPI.handleLeftButtonRelease = function() {
    switch (model.state) {
      case States3.IS_DOLLY:
        publicAPI.endDolly();
        break;
      case States3.IS_PAN:
        publicAPI.endPan();
        break;
      case States3.IS_SPIN:
        publicAPI.endSpin();
        break;
      case States3.IS_ROTATE:
        publicAPI.endRotate();
        break;
    }
  };
  publicAPI.handleStartMouseWheel = function(callData) {
    publicAPI.startDolly();
    publicAPI.handleMouseWheel(callData);
  };
  publicAPI.handleEndMouseWheel = function() {
    publicAPI.endDolly();
  };
  publicAPI.handleStartPinch = function(callData) {
    model.previousScale = callData.scale;
    publicAPI.startDolly();
  };
  publicAPI.handleEndPinch = function() {
    publicAPI.endDolly();
  };
  publicAPI.handleStartRotate = function(callData) {
    model.previousRotation = callData.rotation;
    publicAPI.startRotate();
  };
  publicAPI.handleEndRotate = function() {
    publicAPI.endRotate();
  };
  publicAPI.handleStartPan = function(callData) {
    model.previousTranslation = callData.translation;
    publicAPI.startPan();
  };
  publicAPI.handleEndPan = function() {
    publicAPI.endPan();
  };
  publicAPI.handlePinch = function(callData) {
    publicAPI.dollyByFactor(callData.pokedRenderer, callData.scale / model.previousScale);
    model.previousScale = callData.scale;
  };
  publicAPI.handlePan = function(callData) {
    var camera = callData.pokedRenderer.getActiveCamera();
    var viewFocus = camera.getFocalPoint();
    viewFocus = publicAPI.computeWorldToDisplay(callData.pokedRenderer, viewFocus[0], viewFocus[1], viewFocus[2]);
    var focalDepth = viewFocus[2];
    var trans = callData.translation;
    var lastTrans = model.previousTranslation;
    var newPickPoint = publicAPI.computeDisplayToWorld(callData.pokedRenderer, viewFocus[0] + trans[0] - lastTrans[0], viewFocus[1] + trans[1] - lastTrans[1], focalDepth);
    var oldPickPoint = publicAPI.computeDisplayToWorld(callData.pokedRenderer, viewFocus[0], viewFocus[1], focalDepth);
    var motionVector = [];
    motionVector[0] = oldPickPoint[0] - newPickPoint[0];
    motionVector[1] = oldPickPoint[1] - newPickPoint[1];
    motionVector[2] = oldPickPoint[2] - newPickPoint[2];
    viewFocus = camera.getFocalPoint();
    var viewPoint = camera.getPosition();
    camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
    camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
    if (model._interactor.getLightFollowCamera()) {
      callData.pokedRenderer.updateLightsGeometryToFollowCamera();
    }
    camera.orthogonalizeViewUp();
    model.previousTranslation = callData.translation;
  };
  publicAPI.handleRotate = function(callData) {
    var camera = callData.pokedRenderer.getActiveCamera();
    camera.roll(callData.rotation - model.previousRotation);
    camera.orthogonalizeViewUp();
    model.previousRotation = callData.rotation;
  };
  publicAPI.handleMouseRotate = function(renderer, position) {
    if (!model.previousPosition) {
      return;
    }
    var rwi = model._interactor;
    var dx = position.x - model.previousPosition.x;
    var dy = position.y - model.previousPosition.y;
    var size = rwi.getView().getViewportSize(renderer);
    var deltaElevation = -0.1;
    var deltaAzimuth = -0.1;
    if (size[0] && size[1]) {
      deltaElevation = -20 / size[1];
      deltaAzimuth = -20 / size[0];
    }
    var rxf = dx * deltaAzimuth * model.motionFactor;
    var ryf = dy * deltaElevation * model.motionFactor;
    var camera = renderer.getActiveCamera();
    if (!Number.isNaN(rxf) && !Number.isNaN(ryf)) {
      camera.azimuth(rxf);
      camera.elevation(ryf);
      camera.orthogonalizeViewUp();
    }
    if (model.autoAdjustCameraClippingRange) {
      renderer.resetCameraClippingRange();
    }
    if (rwi.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
  publicAPI.handleMouseSpin = function(renderer, position) {
    if (!model.previousPosition) {
      return;
    }
    var rwi = model._interactor;
    var camera = renderer.getActiveCamera();
    var center = rwi.getView().getViewportCenter(renderer);
    var oldAngle = degreesFromRadians(Math.atan2(model.previousPosition.y - center[1], model.previousPosition.x - center[0]));
    var newAngle = degreesFromRadians(Math.atan2(position.y - center[1], position.x - center[0])) - oldAngle;
    if (!Number.isNaN(newAngle)) {
      camera.roll(newAngle);
      camera.orthogonalizeViewUp();
    }
  };
  publicAPI.handleMousePan = function(renderer, position) {
    if (!model.previousPosition) {
      return;
    }
    var camera = renderer.getActiveCamera();
    var viewFocus = camera.getFocalPoint();
    viewFocus = publicAPI.computeWorldToDisplay(renderer, viewFocus[0], viewFocus[1], viewFocus[2]);
    var focalDepth = viewFocus[2];
    var newPickPoint = publicAPI.computeDisplayToWorld(renderer, position.x, position.y, focalDepth);
    var oldPickPoint = publicAPI.computeDisplayToWorld(renderer, model.previousPosition.x, model.previousPosition.y, focalDepth);
    var motionVector = [];
    motionVector[0] = oldPickPoint[0] - newPickPoint[0];
    motionVector[1] = oldPickPoint[1] - newPickPoint[1];
    motionVector[2] = oldPickPoint[2] - newPickPoint[2];
    viewFocus = camera.getFocalPoint();
    var viewPoint = camera.getPosition();
    camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
    camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
    if (model._interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
  publicAPI.handleMouseDolly = function(renderer, position) {
    if (!model.previousPosition) {
      return;
    }
    var dy = position.y - model.previousPosition.y;
    var rwi = model._interactor;
    var center = rwi.getView().getViewportCenter(renderer);
    var dyf = model.motionFactor * dy / center[1];
    publicAPI.dollyByFactor(renderer, Math.pow(1.1, dyf));
  };
  publicAPI.handleMouseWheel = function(callData) {
    var dyf = 1 - callData.spinY / model.zoomFactor;
    publicAPI.dollyByFactor(callData.pokedRenderer, dyf);
  };
  publicAPI.dollyByFactor = function(renderer, factor) {
    if (Number.isNaN(factor)) {
      return;
    }
    var camera = renderer.getActiveCamera();
    if (camera.getParallelProjection()) {
      camera.setParallelScale(camera.getParallelScale() / factor);
    } else {
      camera.dolly(factor);
      if (model.autoAdjustCameraClippingRange) {
        renderer.resetCameraClippingRange();
      }
    }
    if (model._interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
}
var DEFAULT_VALUES3 = {
  motionFactor: 10,
  zoomFactor: 10
};
function extend3(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  vtkInteractorStyle$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["motionFactor", "zoomFactor"]);
  vtkInteractorStyleTrackballCamera(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend3, "vtkInteractorStyleTrackballCamera");
var vtkInteractorStyleTrackballCamera$1 = {
  newInstance: newInstance3,
  extend: extend3
};

export {
  extend3 as extend,
  newInstance3 as newInstance,
  vtkInteractorStyleTrackballCamera$1
};
//# sourceMappingURL=chunk-VE7E4T5X.js.map
