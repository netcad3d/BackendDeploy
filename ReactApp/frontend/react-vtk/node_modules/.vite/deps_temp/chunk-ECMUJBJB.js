import {
  HalfFloat,
  vtkWebGPUBufferManager$1,
  vtkWebGPUSampler$1,
  vtkWebGPUTypes
} from "./chunk-WDDAGUM6.js";
import {
  vtkTexture$1
} from "./chunk-BVZBITDV.js";
import {
  macro
} from "./chunk-OTTIIP4A.js";

// node_modules/@kitware/vtk.js/Rendering/WebGPU/TextureView.js
function vtkWebGPUTextureView(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUTextureView");
  publicAPI.create = function(texture, options) {
    model.texture = texture;
    model.options = options;
    model.options.dimension = model.options.dimension || "2d";
    model.options.label = model.label;
    model.textureHandle = texture.getHandle();
    model.handle = model.textureHandle.createView(model.options);
    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
    var tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.texture.getFormat());
    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
  };
  publicAPI.createFromTextureHandle = function(textureHandle, options) {
    model.texture = null;
    model.options = options;
    model.options.dimension = model.options.dimension || "2d";
    model.options.label = model.label;
    model.textureHandle = textureHandle;
    model.handle = model.textureHandle.createView(model.options);
    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
    var tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(options.format);
    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
    model.bindGroupTime.modified();
  };
  publicAPI.getBindGroupEntry = function() {
    var foo = {
      resource: publicAPI.getHandle()
    };
    return foo;
  };
  publicAPI.getShaderCode = function(binding, group) {
    var ttype = "f32";
    if (model.bindGroupLayoutEntry.texture.sampleType === "sint") {
      ttype = "i32";
    } else if (model.bindGroupLayoutEntry.texture.sampleType === "uint") {
      ttype = "u32";
    }
    var result = "@binding(".concat(binding, ") @group(").concat(group, ") var ").concat(model.label, ": texture_").concat(model.options.dimension, "<").concat(ttype, ">;");
    if (model.bindGroupLayoutEntry.texture.sampleType === "depth") {
      result = "@binding(".concat(binding, ") @group(").concat(group, ") var ").concat(model.label, ": texture_depth_").concat(model.options.dimension, ";");
    }
    return result;
  };
  publicAPI.addSampler = function(device, options) {
    var newSamp = vtkWebGPUSampler$1.newInstance({
      label: "".concat(model.label, "Sampler")
    });
    newSamp.create(device, options);
    publicAPI.setSampler(newSamp);
  };
  publicAPI.getBindGroupTime = function() {
    if (model.texture && model.texture.getHandle() !== model.textureHandle) {
      model.textureHandle = model.texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupTime.modified();
    }
    return model.bindGroupTime;
  };
  publicAPI.getHandle = function() {
    if (model.texture && model.texture.getHandle() !== model.textureHandle) {
      model.textureHandle = model.texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupTime.modified();
    }
    return model.handle;
  };
}
var DEFAULT_VALUES = {
  texture: null,
  handle: null,
  sampler: null,
  label: null
};
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  model.bindGroupLayoutEntry = {
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    texture: {
      sampleType: "float",
      viewDimension: "2d"
    }
  };
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "texture"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "label", "sampler"]);
  vtkWebGPUTextureView(publicAPI, model);
}
var newInstance = macro.newInstance(extend);
var vtkWebGPUTextureView$1 = {
  newInstance,
  extend
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Texture.js
var BufferUsage = vtkWebGPUBufferManager$1.BufferUsage;
function vtkWebGPUTexture(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUTexture");
  publicAPI.create = function(device, options) {
    model.device = device;
    model.width = options.width;
    model.height = options.height;
    model.depth = options.depth ? options.depth : 1;
    var dimension = model.depth === 1 ? "2d" : "3d";
    model.format = options.format ? options.format : "rgba8unorm";
    model.mipLevel = options.mipLevel ? options.mipLevel : 0;
    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    model.handle = model.device.getHandle().createTexture({
      size: [model.width, model.height, model.depth],
      format: model.format,
      usage: model.usage,
      label: model.label,
      dimension,
      mipLevelCount: model.mipLevel + 1
    });
  };
  publicAPI.assignFromHandle = function(device, handle, options) {
    model.device = device;
    model.handle = handle;
    model.width = options.width;
    model.height = options.height;
    model.depth = options.depth ? options.depth : 1;
    model.format = options.format ? options.format : "rgba8unorm";
    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
  };
  publicAPI.writeImageData = function(req) {
    var nativeArray = [];
    if (req.canvas) {
      model.device.getHandle().queue.copyExternalImageToTexture({
        source: req.canvas,
        flipY: req.flip
      }, {
        texture: model.handle,
        premultipliedAlpha: true
      }, [model.width, model.height, model.depth]);
      model.ready = true;
      return;
    }
    if (req.jsImageData && !req.nativeArray) {
      req.width = req.jsImageData.width;
      req.height = req.jsImageData.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      req.nativeArray = req.jsImageData.data;
    }
    var tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
    var bufferBytesPerRow = model.width * tDetails.stride;
    var fixAll = function fixAll2(arr, height, depth) {
      var inWidthInBytes = arr.length / (height * depth) * arr.BYTES_PER_ELEMENT;
      var halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
      if (halfFloat || inWidthInBytes % 256) {
        var inArray = arr;
        var inWidth = inWidthInBytes / inArray.BYTES_PER_ELEMENT;
        var outBytesPerElement = tDetails.elementSize;
        var outWidthInBytes = 256 * Math.floor((inWidth * outBytesPerElement + 255) / 256);
        var outWidth = outWidthInBytes / outBytesPerElement;
        var outArray = macro.newTypedArray(halfFloat ? "Uint16Array" : inArray.constructor.name, outWidth * height * depth);
        for (var v = 0; v < height * depth; v++) {
          if (halfFloat) {
            for (var i = 0; i < inWidth; i++) {
              outArray[v * outWidth + i] = HalfFloat.toHalf(inArray[v * inWidth + i]);
            }
          } else {
            outArray.set(inArray.subarray(v * inWidth, (v + 1) * inWidth), v * outWidth);
          }
        }
        return [outArray, outWidthInBytes];
      }
      return [arr, inWidthInBytes];
    };
    if (req.nativeArray) {
      nativeArray = req.nativeArray;
    }
    if (req.image) {
      var canvas = document.createElement("canvas");
      canvas.width = req.image.width;
      canvas.height = req.image.height;
      var ctx = canvas.getContext("2d");
      ctx.translate(0, canvas.height);
      ctx.scale(1, -1);
      ctx.drawImage(req.image, 0, 0, req.image.width, req.image.height, 0, 0, canvas.width, canvas.height);
      var imageData = ctx.getImageData(0, 0, req.image.width, req.image.height);
      nativeArray = imageData.data;
    }
    var cmdEnc = model.device.createCommandEncoder();
    if (publicAPI.getDimensionality() !== 3) {
      var mips = vtkTexture$1.generateMipmaps(nativeArray, model.width, model.height, model.mipLevel);
      var currentWidth = model.width;
      var currentHeight = model.height;
      for (var m = 0; m <= model.mipLevel; m++) {
        var fix = fixAll(mips[m], currentHeight, 1);
        bufferBytesPerRow = fix[1];
        var buffRequest = {
          dataArray: req.dataArray ? req.dataArray : null,
          nativeArray: fix[0],
          usage: BufferUsage.Texture
        };
        var buff = model.device.getBufferManager().getBuffer(buffRequest);
        cmdEnc.copyBufferToTexture({
          buffer: buff.getHandle(),
          offset: 0,
          bytesPerRow: bufferBytesPerRow,
          rowsPerImage: currentHeight
        }, {
          texture: model.handle,
          mipLevel: m
        }, [currentWidth, currentHeight, 1]);
        currentWidth /= 2;
        currentHeight /= 2;
      }
      model.device.submitCommandEncoder(cmdEnc);
      model.ready = true;
    } else {
      var _fix = fixAll(nativeArray, model.height, model.depth);
      bufferBytesPerRow = _fix[1];
      var _buffRequest = {
        dataArray: req.dataArray ? req.dataArray : null,
        usage: BufferUsage.Texture
      };
      _buffRequest.nativeArray = _fix[0];
      var _buff = model.device.getBufferManager().getBuffer(_buffRequest);
      cmdEnc.copyBufferToTexture({
        buffer: _buff.getHandle(),
        offset: 0,
        bytesPerRow: bufferBytesPerRow,
        rowsPerImage: model.height
      }, {
        texture: model.handle
      }, [model.width, model.height, model.depth]);
      model.device.submitCommandEncoder(cmdEnc);
      model.ready = true;
    }
  };
  publicAPI.getScale = function() {
    var tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
    var halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
    return halfFloat ? 1 : 255;
  };
  publicAPI.getNumberOfComponents = function() {
    var tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
    return tDetails.numComponents;
  };
  publicAPI.getDimensionality = function() {
    var dims = 0;
    if (model.width > 1)
      dims++;
    if (model.height > 1)
      dims++;
    if (model.depth > 1)
      dims++;
    return dims;
  };
  publicAPI.resizeToMatch = function(tex) {
    if (tex.getWidth() !== model.width || tex.getHeight() !== model.height || tex.getDepth() !== model.depth) {
      model.width = tex.getWidth();
      model.height = tex.getHeight();
      model.depth = tex.getDepth();
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        usage: model.usage,
        label: model.label
      });
    }
  };
  publicAPI.resize = function(width, height) {
    var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    if (width !== model.width || height !== model.height || depth !== model.depth) {
      model.width = width;
      model.height = height;
      model.depth = depth;
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        usage: model.usage,
        label: model.label
      });
    }
  };
  publicAPI.createView = function(label) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!options.dimension) {
      options.dimension = model.depth === 1 ? "2d" : "3d";
    }
    var view = vtkWebGPUTextureView$1.newInstance({
      label
    });
    view.create(publicAPI, options);
    return view;
  };
}
var DEFAULT_VALUES2 = {
  device: null,
  handle: null,
  buffer: null,
  ready: false,
  label: null
};
function extend2(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["handle", "ready", "width", "height", "depth", "format", "usage"]);
  macro.setGet(publicAPI, model, ["device", "label"]);
  vtkWebGPUTexture(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend2);
var vtkWebGPUTexture$1 = {
  newInstance: newInstance2,
  extend: extend2
};

export {
  vtkWebGPUTextureView$1,
  vtkWebGPUTexture$1
};
//# sourceMappingURL=chunk-ECMUJBJB.js.map
